{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","bitflags","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","-C","metadata=515ee2c10c45bde6","-C","extra-filename=-515ee2c10c45bde6","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--cap-lints","allow","--cfg","bitflags_const_fn","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libbitflags-515ee2c10c45bde6.rmeta"},"prelude":{"crate_id":{"name":"bitflags","disambiguator":[1258995681021104935,10120995213895226001]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","num":1,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","num":2,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","num":3,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","byte_start":467,"byte_end":42910,"line_start":11,"line_end":1430,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","byte_start":467,"byte_end":42910,"line_start":11,"line_end":1430,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":7},{"krate":0,"index":8},{"krate":0,"index":9}],"decl_id":null,"docs":" A typesafe bitmask flag generator useful for sets of C-style bitmask flags.\n It can be used for creating typesafe wrappers around C APIs.\n\n The `bitflags!` macro generates a `struct` that manages a set of flags. The\n flags should only be defined for integer types, otherwise unexpected type\n errors may occur at compile time.\n\n # Example\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n bitflags! {\n     struct Flags: u32 {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n     }\n }\n\n fn main() {\n     let e1 = Flags::A | Flags::C;\n     let e2 = Flags::B | Flags::C;\n     assert_eq!((e1 | e2), Flags::ABC);   // union\n     assert_eq!((e1 & e2), Flags::C);     // intersection\n     assert_eq!((e1 - e2), Flags::A);     // set difference\n     assert_eq!(!e2, Flags::A);           // set complement\n }\n ```\n\n See [`example_generated::Flags`](./example_generated/struct.Flags.html) for documentation of code\n generated by the above `bitflags!` expansion.\n\n The generated `struct`s can also be extended with type and trait\n implementations:\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n use std::fmt;\n\n bitflags! {\n     struct Flags: u32 {\n         const A = 0b00000001;\n         const B = 0b00000010;\n     }\n }\n\n impl Flags {\n     pub fn clear(&mut self) {\n         self.bits = 0;  // The `bits` field can be accessed from within the\n                         // same module where the `bitflags!` macro was invoked.\n     }\n }\n\n impl fmt::Display for Flags {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"hi!\")\n     }\n }\n\n fn main() {\n     let mut flags = Flags::A | Flags::B;\n     flags.clear();\n     assert!(flags.is_empty());\n     assert_eq!(format!(\"{}\", flags), \"hi!\");\n     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n }\n ```\n\n # Visibility\n\n The generated struct and its associated flag constants are not exported\n out of the current module by default. A definition can be exported out of\n the current module by adding `pub` before `flags`:\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n mod example {\n     bitflags! {\n         pub struct Flags1: u32 {\n             const A = 0b00000001;\n         }\n     }\n     bitflags! {\n #       pub\n         struct Flags2: u32 {\n             const B = 0b00000010;\n         }\n     }\n }\n\n fn main() {\n     let flag1 = example::Flags1::A;\n     let flag2 = example::Flags2::B; // error: const `B` is private\n }\n ```\n\n # Attributes\n\n Attributes can be attached to the generated `struct` by placing them\n before the `flags` keyword.\n\n # Trait implementations\n\n The `Copy`, `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and `Hash`\n traits automatically derived for the `struct` using the `derive` attribute.\n Additional traits can be derived by providing an explicit `derive`\n attribute on `flags`.\n\n The `Extend` and `FromIterator` traits are implemented for the `struct`,\n too: `Extend` adds the union of the instances of the `struct` iterated over,\n while `FromIterator` calculates the union.\n\n The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` trait is also\n implemented by displaying the bits value of the internal struct.\n\n ## Operators\n\n The following operator traits are implemented for the generated `struct`:\n\n - `BitOr` and `BitOrAssign`: union\n - `BitAnd` and `BitAndAssign`: intersection\n - `BitXor` and `BitXorAssign`: toggle\n - `Sub` and `SubAssign`: set difference\n - `Not`: set complement\n\n # Methods\n\n The following methods are defined for the generated `struct`:\n\n - `empty`: an empty set of flags\n - `all`: the set of all defined flags\n - `bits`: the raw value of the flags currently stored\n - `from_bits`: convert from underlying bit representation, unless that\n                representation contains bits that do not correspond to a\n                defined flag\n - `from_bits_truncate`: convert from underlying bit representation, dropping\n                         any bits that do not correspond to defined flags\n - `from_bits_unchecked`: convert from underlying bit representation, keeping\n                          all bits (even those not corresponding to defined\n                          flags)\n - `is_empty`: `true` if no flags are currently stored\n - `is_all`: `true` if currently set flags exactly equal all defined flags\n - `intersects`: `true` if there are flags common to both `self` and `other`\n - `contains`: `true` all of the flags in `other` are contained within `self`\n - `insert`: inserts the specified flags in-place\n - `remove`: removes the specified flags in-place\n - `toggle`: the specified flags will be inserted if not present, and removed\n             if they are.\n - `set`: inserts or removes the specified flags depending on the passed value\n\n ## Default\n\n The `Default` trait is not automatically implemented for the generated struct.\n\n If your default value is equal to `0` (which is the same value as calling `empty()`\n on the generated struct), you can simply derive `Default`:\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n bitflags! {\n     // Results in default value with bits: 0\n     #[derive(Default)]\n     struct Flags: u32 {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n     }\n }\n\n fn main() {\n     let derived_default: Flags = Default::default();\n     assert_eq!(derived_default.bits(), 0);\n }\n ```\n\n If your default value is not equal to `0` you need to implement `Default` yourself:\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n bitflags! {\n     struct Flags: u32 {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n     }\n }\n\n // explicit `Default` implementation\n impl Default for Flags {\n     fn default() -> Flags {\n         Flags::A | Flags::C\n     }\n }\n\n fn main() {\n     let implemented_default: Flags = Default::default();\n     assert_eq!(implemented_default, (Flags::A | Flags::C));\n }\n ```\n\n # Zero Flags\n\n Flags with a value equal to zero will have some strange behavior that one should be aware of.\n\n ```\n #[macro_use]\n extern crate bitflags;\n\n bitflags! {\n     struct Flags: u32 {\n         const NONE = 0b00000000;\n         const SOME = 0b00000001;\n     }\n }\n\n fn main() {\n     let empty = Flags::empty();\n     let none = Flags::NONE;\n     let some = Flags::SOME;\n\n     // Zero flags are treated as always present\n     assert!(empty.contains(Flags::NONE));\n     assert!(none.contains(Flags::NONE));\n     assert!(some.contains(Flags::NONE));\n\n     // Zero flags will be ignored when testing for emptiness\n     assert!(none.is_empty());\n }\n ```\n","sig":null,"attributes":[{"value":"no_std","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\bitflags-1.2.1\\src\\lib.rs","byte_start":7846,"byte_end":7856,"line_start":253,"line_end":253,"column_start":1,"column_end":11}}]}],"impls":[],"refs":[],"macro_refs":[],"relations":[]}