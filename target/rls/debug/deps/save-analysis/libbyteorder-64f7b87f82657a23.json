{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","byteorder","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"std\"","-C","metadata=64f7b87f82657a23","-C","extra-filename=-64f7b87f82657a23","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--cap-lints","allow","--cfg","byteorder_i128","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libbyteorder-64f7b87f82657a23.rmeta"},"prelude":{"crate_id":{"name":"byteorder","disambiguator":[373764108737062493,6998070977021925776]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":1,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":2,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":0,"byte_end":103311,"line_start":1,"line_end":3328,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":17},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":2688,"byte_end":2700,"line_start":89,"line_end":89,"column_start":14,"column_end":26},"alias_span":null,"name":"ReadBytesExt","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":103},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":2702,"byte_end":2715,"line_start":89,"line_end":89,"column_start":28,"column_end":41},"alias_span":null,"name":"WriteBytesExt","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":0,"byte_end":103311,"line_start":1,"line_end":3328,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":7},{"krate":0,"index":8},{"krate":0,"index":11},{"krate":0,"index":165},{"krate":0,"index":166},{"krate":0,"index":167},{"krate":0,"index":168},{"krate":0,"index":169},{"krate":0,"index":170},{"krate":0,"index":171},{"krate":0,"index":175},{"krate":0,"index":319},{"krate":0,"index":336},{"krate":0,"index":335},{"krate":0,"index":333},{"krate":0,"index":330},{"krate":0,"index":331},{"krate":0,"index":327},{"krate":0,"index":325},{"krate":0,"index":322},{"krate":0,"index":323},{"krate":0,"index":320},{"krate":0,"index":244},{"krate":0,"index":246},{"krate":0,"index":338},{"krate":0,"index":355},{"krate":0,"index":354},{"krate":0,"index":352},{"krate":0,"index":349},{"krate":0,"index":350},{"krate":0,"index":346},{"krate":0,"index":344},{"krate":0,"index":341},{"krate":0,"index":342},{"krate":0,"index":339},{"krate":0,"index":247},{"krate":0,"index":249},{"krate":0,"index":250},{"krate":0,"index":251},{"krate":0,"index":252},{"krate":0,"index":253},{"krate":0,"index":254},{"krate":0,"index":255},{"krate":0,"index":256},{"krate":0,"index":257},{"krate":0,"index":288}],"decl_id":null,"docs":"This crate provides convenience methods for encoding and decoding numbers in\neither [big-endian or little-endian order].\n\nThe organization of the crate is pretty simple. A trait, [`ByteOrder`], specifies\nbyte conversion methods for each type of number in Rust (sans numbers that have\na platform dependent size like `usize` and `isize`). Two types, [`BigEndian`]\nand [`LittleEndian`] implement these methods. Finally, [`ReadBytesExt`] and\n[`WriteBytesExt`] provide convenience methods available to all types that\nimplement [`Read`] and [`Write`].\n\nAn alias, [`NetworkEndian`], for [`BigEndian`] is provided to help improve\ncode clarity.\n\nAn additional alias, [`NativeEndian`], is provided for the endianness of the\nlocal platform. This is convenient when serializing data for use and\nconversions are not desired.\n\n# Examples\n\nRead unsigned 16 bit big-endian integers from a [`Read`] type:\n\n```rust\nuse std::io::Cursor;\nuse byteorder::{BigEndian, ReadBytesExt};\n\nlet mut rdr = Cursor::new(vec![2, 5, 3, 0]);\n// Note that we use type parameters to indicate which kind of byte order\n// we want!\nassert_eq!(517, rdr.read_u16::<BigEndian>().unwrap());\nassert_eq!(768, rdr.read_u16::<BigEndian>().unwrap());\n```\n\nWrite unsigned 16 bit little-endian integers to a [`Write`] type:\n\n```rust\nuse byteorder::{LittleEndian, WriteBytesExt};\n\nlet mut wtr = vec![];\nwtr.write_u16::<LittleEndian>(517).unwrap();\nwtr.write_u16::<LittleEndian>(768).unwrap();\nassert_eq!(wtr, vec![5, 2, 0, 3]);\n```\n\n# Optional Features\n\nThis crate optionally provides support for 128 bit values (`i128` and `u128`)\nwhen built with the `i128` feature enabled.\n\nThis crate can also be used without the standard library.\n\n# Alternatives\n\nNote that as of Rust 1.32, the standard numeric types provide built-in methods\nlike `to_le_bytes` and `from_le_bytes`, which support some of the same use\ncases.\n\n[big-endian or little-endian order]: https://en.wikipedia.org/wiki/Endianness\n[`ByteOrder`]: trait.ByteOrder.html\n[`BigEndian`]: enum.BigEndian.html\n[`LittleEndian`]: enum.LittleEndian.html\n[`ReadBytesExt`]: trait.ReadBytesExt.html\n[`WriteBytesExt`]: trait.WriteBytesExt.html\n[`NetworkEndian`]: type.NetworkEndian.html\n[`NativeEndian`]: type.NativeEndian.html\n[`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n[`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n","sig":null,"attributes":[{"value":"deny(missing_docs)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":2349,"byte_end":2371,"line_start":70,"line_end":70,"column_start":1,"column_end":23}}]},{"kind":"Trait","id":{"krate":0,"index":17},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":104192,"byte_end":104204,"line_start":28,"line_end":28,"column_start":11,"column_end":23},"name":"ReadBytesExt","qualname":"::io::ReadBytesExt","value":"ReadBytesExt: io::Read","parent":null,"children":[{"krate":0,"index":18},{"krate":0,"index":20},{"krate":0,"index":22},{"krate":0,"index":25},{"krate":0,"index":28},{"krate":0,"index":31},{"krate":0,"index":34},{"krate":0,"index":37},{"krate":0,"index":40},{"krate":0,"index":43},{"krate":0,"index":46},{"krate":0,"index":49},{"krate":0,"index":52},{"krate":0,"index":55},{"krate":0,"index":58},{"krate":0,"index":61},{"krate":0,"index":64},{"krate":0,"index":67},{"krate":0,"index":70},{"krate":0,"index":73},{"krate":0,"index":76},{"krate":0,"index":78},{"krate":0,"index":80},{"krate":0,"index":82},{"krate":0,"index":84},{"krate":0,"index":85},{"krate":0,"index":87},{"krate":0,"index":89},{"krate":0,"index":91},{"krate":0,"index":93},{"krate":0,"index":95},{"krate":0,"index":97},{"krate":0,"index":99}],"decl_id":null,"docs":" Extends [`Read`] with methods for reading numbers. (For `std::io`.)\n\n Most of the methods defined here have an unconstrained type parameter that\n must be explicitly instantiated. Typically, it is instantiated with either\n the [`BigEndian`] or [`LittleEndian`] types defined in this crate.\n\n # Examples\n\n Read unsigned 16 bit big-endian integers from a [`Read`]:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![2, 5, 3, 0]);\n assert_eq!(517, rdr.read_u16::<BigEndian>().unwrap());\n assert_eq!(768, rdr.read_u16::<BigEndian>().unwrap());\n ```\n\n [`BigEndian`]: enum.BigEndian.html\n [`LittleEndian`]: enum.LittleEndian.html\n [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":18},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":104986,"byte_end":104993,"line_start":53,"line_end":53,"column_start":8,"column_end":15},"name":"read_u8","qualname":"::io::ReadBytesExt::read_u8","value":"fn (&mut self) -> Result<u8>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 8 bit integer from the underlying reader.\n\n Note that since this reads a single byte, no byte order conversions\n are used. It is included for completeness.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read unsigned 8 bit integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::ReadBytesExt;\n\n let mut rdr = Cursor::new(vec![2, 5]);\n assert_eq!(2, rdr.read_u8().unwrap());\n assert_eq!(5, rdr.read_u8().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":104969,"byte_end":104978,"line_start":52,"line_end":52,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":20},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":105889,"byte_end":105896,"line_start":83,"line_end":83,"column_start":8,"column_end":15},"name":"read_i8","qualname":"::io::ReadBytesExt::read_i8","value":"fn (&mut self) -> Result<i8>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 8 bit integer from the underlying reader.\n\n Note that since this reads a single byte, no byte order conversions\n are used. It is included for completeness.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read signed 8 bit integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::ReadBytesExt;\n\n let mut rdr = Cursor::new(vec![0x02, 0xfb]);\n assert_eq!(2, rdr.read_i8().unwrap());\n assert_eq!(-5, rdr.read_i8().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":105872,"byte_end":105881,"line_start":82,"line_end":82,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":22},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":106725,"byte_end":106733,"line_start":110,"line_end":110,"column_start":8,"column_end":16},"name":"read_u16","qualname":"::io::ReadBytesExt::read_u16","value":"fn <T> (&mut self) -> Result<u16>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 16 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read unsigned 16 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![2, 5, 3, 0]);\n assert_eq!(517, rdr.read_u16::<BigEndian>().unwrap());\n assert_eq!(768, rdr.read_u16::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":106708,"byte_end":106717,"line_start":109,"line_end":109,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":25},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":107590,"byte_end":107598,"line_start":137,"line_end":137,"column_start":8,"column_end":16},"name":"read_i16","qualname":"::io::ReadBytesExt::read_i16","value":"fn <T> (&mut self) -> Result<i16>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 16 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read signed 16 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x00, 0xc1, 0xff, 0x7c]);\n assert_eq!(193, rdr.read_i16::<BigEndian>().unwrap());\n assert_eq!(-132, rdr.read_i16::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":107573,"byte_end":107582,"line_start":136,"line_end":136,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":28},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":108390,"byte_end":108398,"line_start":163,"line_end":163,"column_start":8,"column_end":16},"name":"read_u24","qualname":"::io::ReadBytesExt::read_u24","value":"fn <T> (&mut self) -> Result<u32>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 24 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read unsigned 24 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x00, 0x01, 0x0b]);\n assert_eq!(267, rdr.read_u24::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":108373,"byte_end":108382,"line_start":162,"line_end":162,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":31},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":109188,"byte_end":109196,"line_start":189,"line_end":189,"column_start":8,"column_end":16},"name":"read_i24","qualname":"::io::ReadBytesExt::read_i24","value":"fn <T> (&mut self) -> Result<i32>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 24 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read signed 24 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0xff, 0x7a, 0x33]);\n assert_eq!(-34253, rdr.read_i24::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":109171,"byte_end":109180,"line_start":188,"line_end":188,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":34},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":109994,"byte_end":110002,"line_start":215,"line_end":215,"column_start":8,"column_end":16},"name":"read_u32","qualname":"::io::ReadBytesExt::read_u32","value":"fn <T> (&mut self) -> Result<u32>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 32 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read unsigned 32 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x00, 0x00, 0x01, 0x0b]);\n assert_eq!(267, rdr.read_u32::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":109977,"byte_end":109986,"line_start":214,"line_end":214,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":37},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":110798,"byte_end":110806,"line_start":241,"line_end":241,"column_start":8,"column_end":16},"name":"read_i32","qualname":"::io::ReadBytesExt::read_i32","value":"fn <T> (&mut self) -> Result<i32>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 32 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read signed 32 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0xff, 0xff, 0x7a, 0x33]);\n assert_eq!(-34253, rdr.read_i32::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":110781,"byte_end":110790,"line_start":240,"line_end":240,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":40},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":111628,"byte_end":111636,"line_start":267,"line_end":267,"column_start":8,"column_end":16},"name":"read_u48","qualname":"::io::ReadBytesExt::read_u48","value":"fn <T> (&mut self) -> Result<u64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 48 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read unsigned 48 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0xb6, 0x71, 0x6b, 0xdc, 0x2b, 0x31]);\n assert_eq!(200598257150769, rdr.read_u48::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":111611,"byte_end":111620,"line_start":266,"line_end":266,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":43},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":112454,"byte_end":112462,"line_start":293,"line_end":293,"column_start":8,"column_end":16},"name":"read_i48","qualname":"::io::ReadBytesExt::read_i48","value":"fn <T> (&mut self) -> Result<i64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 48 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read signed 48 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x9d, 0x71, 0xab, 0xe7, 0x97, 0x8f]);\n assert_eq!(-108363435763825, rdr.read_i48::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":112437,"byte_end":112446,"line_start":292,"line_end":292,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":46},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":113298,"byte_end":113306,"line_start":319,"line_end":319,"column_start":8,"column_end":16},"name":"read_u64","qualname":"::io::ReadBytesExt::read_u64","value":"fn <T> (&mut self) -> Result<u64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 64 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read an unsigned 64 bit big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83]);\n assert_eq!(918733457491587, rdr.read_u64::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":113281,"byte_end":113290,"line_start":318,"line_end":318,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":49},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":114116,"byte_end":114124,"line_start":345,"line_end":345,"column_start":8,"column_end":16},"name":"read_i64","qualname":"::io::ReadBytesExt::read_i64","value":"fn <T> (&mut self) -> Result<i64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 64 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a signed 64 bit big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0]);\n assert_eq!(i64::min_value(), rdr.read_i64::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":114099,"byte_end":114108,"line_start":344,"line_end":344,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":52},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115092,"byte_end":115101,"line_start":375,"line_end":375,"column_start":8,"column_end":17},"name":"read_u128","qualname":"::io::ReadBytesExt::read_u128","value":"fn <T> (&mut self) -> Result<u128>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned 128 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read an unsigned 128 bit big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83,\n     0x00, 0x03, 0x43, 0x95, 0x4d, 0x60, 0x86, 0x83\n ]);\n assert_eq!(16947640962301618749969007319746179, rdr.read_u128::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115048,"byte_end":115070,"line_start":373,"line_end":373,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115075,"byte_end":115084,"line_start":374,"line_end":374,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":55},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115969,"byte_end":115978,"line_start":402,"line_end":402,"column_start":8,"column_end":17},"name":"read_i128","qualname":"::io::ReadBytesExt::read_i128","value":"fn <T> (&mut self) -> Result<i128>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed 128 bit integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a signed 128 bit big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n assert_eq!(i128::min_value(), rdr.read_i128::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115925,"byte_end":115947,"line_start":400,"line_end":400,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":115952,"byte_end":115961,"line_start":401,"line_end":401,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":58},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":116770,"byte_end":116779,"line_start":427,"line_end":427,"column_start":8,"column_end":17},"name":"read_uint","qualname":"::io::ReadBytesExt::read_uint","value":"fn <T> (&mut self, nbytes: usize) -> Result<u64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned n-bytes integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read an unsigned n-byte big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0x80, 0x74, 0xfa]);\n assert_eq!(8418554, rdr.read_uint::<BigEndian>(3).unwrap());\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":116753,"byte_end":116762,"line_start":426,"line_end":426,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":61},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":117609,"byte_end":117617,"line_start":452,"line_end":452,"column_start":8,"column_end":16},"name":"read_int","qualname":"::io::ReadBytesExt::read_int","value":"fn <T> (&mut self, nbytes: usize) -> Result<i64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed n-bytes integer from the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read an unsigned n-byte big-endian integer from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0xc1, 0xff, 0x7c]);\n assert_eq!(-4063364, rdr.read_int::<BigEndian>(3).unwrap());\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":117592,"byte_end":117601,"line_start":451,"line_end":451,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":64},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":117929,"byte_end":117941,"line_start":461,"line_end":461,"column_start":8,"column_end":20},"name":"read_uint128","qualname":"::io::ReadBytesExt::read_uint128","value":"fn <T> (&mut self, nbytes: usize) -> Result<u128>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads an unsigned n-bytes integer from the underlying reader.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":117885,"byte_end":117907,"line_start":459,"line_end":459,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":117912,"byte_end":117921,"line_start":460,"line_end":460,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":67},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":118256,"byte_end":118267,"line_start":470,"line_end":470,"column_start":8,"column_end":19},"name":"read_int128","qualname":"::io::ReadBytesExt::read_int128","value":"fn <T> (&mut self, nbytes: usize) -> Result<i128>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a signed n-bytes integer from the underlying reader.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":118212,"byte_end":118234,"line_start":468,"line_end":468,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":118239,"byte_end":118248,"line_start":469,"line_end":469,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":70},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":119234,"byte_end":119242,"line_start":501,"line_end":501,"column_start":8,"column_end":16},"name":"read_f32","qualname":"::io::ReadBytesExt::read_f32","value":"fn <T> (&mut self) -> Result<f32>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a IEEE754 single-precision (4 bytes) floating point number from\n the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a big-endian single-precision floating point number from a `Read`:\n\n ```rust\n use std::f32;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x49, 0x0f, 0xdb,\n ]);\n assert_eq!(f32::consts::PI, rdr.read_f32::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":119217,"byte_end":119226,"line_start":500,"line_end":500,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":73},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":120185,"byte_end":120193,"line_start":532,"line_end":532,"column_start":8,"column_end":16},"name":"read_f64","qualname":"::io::ReadBytesExt::read_f64","value":"fn <T> (&mut self) -> Result<f64>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a IEEE754 double-precision (8 bytes) floating point number from\n the underlying reader.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a big-endian double-precision floating point number from a `Read`:\n\n ```rust\n use std::f64;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18,\n ]);\n assert_eq!(f64::consts::PI, rdr.read_f64::<BigEndian>().unwrap());\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":120168,"byte_end":120177,"line_start":531,"line_end":531,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":76},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":121234,"byte_end":121247,"line_start":564,"line_end":564,"column_start":8,"column_end":21},"name":"read_u16_into","qualname":"::io::ReadBytesExt::read_u16_into","value":"fn <T> (&mut self, dst: &mut [u16]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of unsigned 16 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of unsigned 16 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![2, 5, 3, 0]);\n let mut dst = [0; 2];\n rdr.read_u16_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":121217,"byte_end":121226,"line_start":563,"line_end":563,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":78},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":122377,"byte_end":122390,"line_start":599,"line_end":599,"column_start":8,"column_end":21},"name":"read_u32_into","qualname":"::io::ReadBytesExt::read_u32_into","value":"fn <T> (&mut self, dst: &mut [u32]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of unsigned 32 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of unsigned 32 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0, 0, 2, 5, 0, 0, 3, 0]);\n let mut dst = [0; 2];\n rdr.read_u32_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":122360,"byte_end":122369,"line_start":598,"line_end":598,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":80},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":123579,"byte_end":123592,"line_start":637,"line_end":637,"column_start":8,"column_end":21},"name":"read_u64_into","qualname":"::io::ReadBytesExt::read_u64_into","value":"fn <T> (&mut self, dst: &mut [u64]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of unsigned 64 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of unsigned 64 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0, 0, 0, 0, 0, 0, 2, 5,\n     0, 0, 0, 0, 0, 0, 3, 0,\n ]);\n let mut dst = [0; 2];\n rdr.read_u64_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":123562,"byte_end":123571,"line_start":636,"line_end":636,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":82},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":124859,"byte_end":124873,"line_start":676,"line_end":676,"column_start":8,"column_end":22},"name":"read_u128_into","qualname":"::io::ReadBytesExt::read_u128_into","value":"fn <T> (&mut self, dst: &mut [u128]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of unsigned 128 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of unsigned 128 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5,\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n ]);\n let mut dst = [0; 2];\n rdr.read_u128_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":124815,"byte_end":124837,"line_start":674,"line_end":674,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":124842,"byte_end":124851,"line_start":675,"line_end":675,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":84},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":126333,"byte_end":126345,"line_start":719,"line_end":719,"column_start":8,"column_end":20},"name":"read_i8_into","qualname":"::io::ReadBytesExt::read_i8_into","value":"fn (&mut self, dst: &mut [i8]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of signed 8 bit integers from the underlying reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n Note that since each `i8` is a single byte, no byte order conversions\n are used. This method is included because it provides a safe, simple\n way for the caller to read into a `&mut [i8]` buffer. (Without this\n method, the caller would have to either use `unsafe` code or convert\n each byte to `i8` individually.)\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of signed 8 bit integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![2, 251, 3]);\n let mut dst = [0; 3];\n rdr.read_i8_into(&mut dst).unwrap();\n assert_eq!([2, -5, 3], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":126316,"byte_end":126325,"line_start":718,"line_end":718,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":85},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":127362,"byte_end":127375,"line_start":750,"line_end":750,"column_start":8,"column_end":21},"name":"read_i16_into","qualname":"::io::ReadBytesExt::read_i16_into","value":"fn <T> (&mut self, dst: &mut [i16]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of signed 16 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of signed 16 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![2, 5, 3, 0]);\n let mut dst = [0; 2];\n rdr.read_i16_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":127345,"byte_end":127354,"line_start":749,"line_end":749,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":87},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":128501,"byte_end":128514,"line_start":785,"line_end":785,"column_start":8,"column_end":21},"name":"read_i32_into","qualname":"::io::ReadBytesExt::read_i32_into","value":"fn <T> (&mut self, dst: &mut [i32]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of signed 32 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of signed 32 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![0, 0, 2, 5, 0, 0, 3, 0]);\n let mut dst = [0; 2];\n rdr.read_i32_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":128484,"byte_end":128493,"line_start":784,"line_end":784,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":89},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":129699,"byte_end":129712,"line_start":823,"line_end":823,"column_start":8,"column_end":21},"name":"read_i64_into","qualname":"::io::ReadBytesExt::read_i64_into","value":"fn <T> (&mut self, dst: &mut [i64]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of signed 64 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of signed 64 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0, 0, 0, 0, 0, 0, 2, 5,\n     0, 0, 0, 0, 0, 0, 3, 0,\n ]);\n let mut dst = [0; 2];\n rdr.read_i64_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":129682,"byte_end":129691,"line_start":822,"line_end":822,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":91},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":130975,"byte_end":130989,"line_start":862,"line_end":862,"column_start":8,"column_end":22},"name":"read_i128_into","qualname":"::io::ReadBytesExt::read_i128_into","value":"fn <T> (&mut self, dst: &mut [i128]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of signed 128 bit integers from the underlying\n reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of signed 128 bit big-endian integers from a `Read`:\n\n ```rust\n use std::io::Cursor;\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5,\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,\n ]);\n let mut dst = [0; 2];\n rdr.read_i128_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([517, 768], dst);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":130931,"byte_end":130953,"line_start":860,"line_end":860,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":130958,"byte_end":130967,"line_start":861,"line_end":861,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":93},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":132302,"byte_end":132315,"line_start":906,"line_end":906,"column_start":8,"column_end":21},"name":"read_f32_into","qualname":"::io::ReadBytesExt::read_f32_into","value":"fn <T> (&mut self, dst: &mut [f32]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of IEEE754 single-precision (4 bytes) floating\n point numbers from the underlying reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of big-endian single-precision floating point number\n from a `Read`:\n\n ```rust\n use std::f32;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x49, 0x0f, 0xdb,\n     0x3f, 0x80, 0x00, 0x00,\n ]);\n let mut dst = [0.0; 2];\n rdr.read_f32_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([f32::consts::PI, 1.0], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":132285,"byte_end":132294,"line_start":905,"line_end":905,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":95},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":133816,"byte_end":133839,"line_start":955,"line_end":955,"column_start":8,"column_end":31},"name":"read_f32_into_unchecked","qualname":"::io::ReadBytesExt::read_f32_into_unchecked","value":"fn <T> (&mut self, dst: &mut [f32]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" **DEPRECATED**.\n\n This method is deprecated. Use `read_f32_into` instead.\n\n Reads a sequence of IEEE754 single-precision (4 bytes) floating\n point numbers from the underlying reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of big-endian single-precision floating point number\n from a `Read`:\n\n ```rust\n use std::f32;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x49, 0x0f, 0xdb,\n     0x3f, 0x80, 0x00, 0x00,\n ]);\n let mut dst = [0.0; 2];\n rdr.read_f32_into_unchecked::<BigEndian>(&mut dst).unwrap();\n assert_eq!([f32::consts::PI, 1.0], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":133723,"byte_end":133732,"line_start":953,"line_end":953,"column_start":5,"column_end":14}},{"value":"deprecated(since = \"1.2.0\", note = \"please use `read_f32_into` instead\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":133737,"byte_end":133808,"line_start":954,"line_end":954,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":97},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":135073,"byte_end":135086,"line_start":994,"line_end":994,"column_start":8,"column_end":21},"name":"read_f64_into","qualname":"::io::ReadBytesExt::read_f64_into","value":"fn <T> (&mut self, dst: &mut [f64]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" Reads a sequence of IEEE754 double-precision (8 bytes) floating\n point numbers from the underlying reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of big-endian single-precision floating point number\n from a `Read`:\n\n ```rust\n use std::f64;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18,\n     0x3f, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n ]);\n let mut dst = [0.0; 2];\n rdr.read_f64_into::<BigEndian>(&mut dst).unwrap();\n assert_eq!([f64::consts::PI, 1.0], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":135056,"byte_end":135065,"line_start":993,"line_end":993,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":99},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":136886,"byte_end":136909,"line_start":1049,"line_end":1049,"column_start":8,"column_end":31},"name":"read_f64_into_unchecked","qualname":"::io::ReadBytesExt::read_f64_into_unchecked","value":"fn <T> (&mut self, dst: &mut [f64]) -> Result<()>","parent":{"krate":0,"index":17},"children":[],"decl_id":null,"docs":" **DEPRECATED**.\n\n This method is deprecated. Use `read_f64_into` instead.\n\n Reads a sequence of IEEE754 double-precision (8 bytes) floating\n point numbers from the underlying reader.\n\n The given buffer is either filled completely or an error is returned.\n If an error is returned, the contents of `dst` are unspecified.\n\n # Safety\n\n This method is unsafe because there are no guarantees made about the\n floating point values. In particular, this method does not check for\n signaling NaNs, which may result in undefined behavior.\n\n # Errors\n\n This method returns the same errors as [`Read::read_exact`].\n\n [`Read::read_exact`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact\n\n # Examples\n\n Read a sequence of big-endian single-precision floating point number\n from a `Read`:\n\n ```rust\n use std::f64;\n use std::io::Cursor;\n\n use byteorder::{BigEndian, ReadBytesExt};\n\n let mut rdr = Cursor::new(vec![\n     0x40, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18,\n     0x3f, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n ]);\n let mut dst = [0.0; 2];\n rdr.read_f64_into_unchecked::<BigEndian>(&mut dst).unwrap();\n assert_eq!([f64::consts::PI, 1.0], dst);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":136793,"byte_end":136802,"line_start":1047,"line_end":1047,"column_start":5,"column_end":14}},{"value":"deprecated(since = \"1.2.0\", note = \"please use `read_f64_into` instead\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":136807,"byte_end":136878,"line_start":1048,"line_end":1048,"column_start":5,"column_end":76}}]},{"kind":"Trait","id":{"krate":0,"index":103},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":137961,"byte_end":137974,"line_start":1083,"line_end":1083,"column_start":11,"column_end":24},"name":"WriteBytesExt","qualname":"::io::WriteBytesExt","value":"WriteBytesExt: io::Write","parent":null,"children":[{"krate":0,"index":104},{"krate":0,"index":105},{"krate":0,"index":106},{"krate":0,"index":109},{"krate":0,"index":112},{"krate":0,"index":115},{"krate":0,"index":118},{"krate":0,"index":121},{"krate":0,"index":124},{"krate":0,"index":127},{"krate":0,"index":130},{"krate":0,"index":133},{"krate":0,"index":136},{"krate":0,"index":139},{"krate":0,"index":142},{"krate":0,"index":145},{"krate":0,"index":148},{"krate":0,"index":151},{"krate":0,"index":154},{"krate":0,"index":157}],"decl_id":null,"docs":" Extends [`Write`] with methods for writing numbers. (For `std::io`.)\n\n Most of the methods defined here have an unconstrained type parameter that\n must be explicitly instantiated. Typically, it is instantiated with either\n the [`BigEndian`] or [`LittleEndian`] types defined in this crate.\n\n # Examples\n\n Write unsigned 16 bit big-endian integers to a [`Write`]:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = vec![];\n wtr.write_u16::<BigEndian>(517).unwrap();\n wtr.write_u16::<BigEndian>(768).unwrap();\n assert_eq!(wtr, vec![2, 5, 3, 0]);\n ```\n\n [`BigEndian`]: enum.BigEndian.html\n [`LittleEndian`]: enum.LittleEndian.html\n [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":104},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":138728,"byte_end":138736,"line_start":1108,"line_end":1108,"column_start":8,"column_end":16},"name":"write_u8","qualname":"::io::WriteBytesExt::write_u8","value":"fn (&mut self, n: u8) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 8 bit integer to the underlying writer.\n\n Note that since this writes a single byte, no byte order conversions\n are used. It is included for completeness.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 8 bit integers to a `Write`:\n\n ```rust\n use byteorder::WriteBytesExt;\n\n let mut wtr = Vec::new();\n wtr.write_u8(2).unwrap();\n wtr.write_u8(5).unwrap();\n assert_eq!(wtr, b\"\\x02\\x05\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":138711,"byte_end":138720,"line_start":1107,"line_end":1107,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":105},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":139543,"byte_end":139551,"line_start":1136,"line_end":1136,"column_start":8,"column_end":16},"name":"write_i8","qualname":"::io::WriteBytesExt::write_i8","value":"fn (&mut self, n: i8) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 8 bit integer to the underlying writer.\n\n Note that since this writes a single byte, no byte order conversions\n are used. It is included for completeness.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 8 bit integers to a `Write`:\n\n ```rust\n use byteorder::WriteBytesExt;\n\n let mut wtr = Vec::new();\n wtr.write_i8(2).unwrap();\n wtr.write_i8(-5).unwrap();\n assert_eq!(wtr, b\"\\x02\\xfb\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":139526,"byte_end":139535,"line_start":1135,"line_end":1135,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":106},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":140298,"byte_end":140307,"line_start":1161,"line_end":1161,"column_start":8,"column_end":17},"name":"write_u16","qualname":"::io::WriteBytesExt::write_u16","value":"fn <T> (&mut self, n: u16) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 16 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 16 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_u16::<BigEndian>(517).unwrap();\n wtr.write_u16::<BigEndian>(768).unwrap();\n assert_eq!(wtr, b\"\\x02\\x05\\x03\\x00\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":140281,"byte_end":140290,"line_start":1160,"line_end":1160,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":109},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":141124,"byte_end":141133,"line_start":1188,"line_end":1188,"column_start":8,"column_end":17},"name":"write_i16","qualname":"::io::WriteBytesExt::write_i16","value":"fn <T> (&mut self, n: i16) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 16 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 16 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_i16::<BigEndian>(193).unwrap();\n wtr.write_i16::<BigEndian>(-132).unwrap();\n assert_eq!(wtr, b\"\\x00\\xc1\\xff\\x7c\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":141107,"byte_end":141116,"line_start":1187,"line_end":1187,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":112},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":141965,"byte_end":141974,"line_start":1215,"line_end":1215,"column_start":8,"column_end":17},"name":"write_u24","qualname":"::io::WriteBytesExt::write_u24","value":"fn <T> (&mut self, n: u32) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 24 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 24 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_u24::<BigEndian>(267).unwrap();\n wtr.write_u24::<BigEndian>(120111).unwrap();\n assert_eq!(wtr, b\"\\x00\\x01\\x0b\\x01\\xd5\\x2f\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":141948,"byte_end":141957,"line_start":1214,"line_end":1214,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":115},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":142804,"byte_end":142813,"line_start":1242,"line_end":1242,"column_start":8,"column_end":17},"name":"write_i24","qualname":"::io::WriteBytesExt::write_i24","value":"fn <T> (&mut self, n: i32) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 24 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 24 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_i24::<BigEndian>(-34253).unwrap();\n wtr.write_i24::<BigEndian>(120111).unwrap();\n assert_eq!(wtr, b\"\\xff\\x7a\\x33\\x01\\xd5\\x2f\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":142787,"byte_end":142796,"line_start":1241,"line_end":1241,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":118},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":143657,"byte_end":143666,"line_start":1269,"line_end":1269,"column_start":8,"column_end":17},"name":"write_u32","qualname":"::io::WriteBytesExt::write_u32","value":"fn <T> (&mut self, n: u32) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 32 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 32 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_u32::<BigEndian>(267).unwrap();\n wtr.write_u32::<BigEndian>(1205419366).unwrap();\n assert_eq!(wtr, b\"\\x00\\x00\\x01\\x0b\\x47\\xd9\\x3d\\x66\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":143640,"byte_end":143649,"line_start":1268,"line_end":1268,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":121},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":144508,"byte_end":144517,"line_start":1296,"line_end":1296,"column_start":8,"column_end":17},"name":"write_i32","qualname":"::io::WriteBytesExt::write_i32","value":"fn <T> (&mut self, n: i32) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 32 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 32 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_i32::<BigEndian>(-34253).unwrap();\n wtr.write_i32::<BigEndian>(1205419366).unwrap();\n assert_eq!(wtr, b\"\\xff\\xff\\x7a\\x33\\x47\\xd9\\x3d\\x66\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":144491,"byte_end":144500,"line_start":1295,"line_end":1295,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":124},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":145381,"byte_end":145390,"line_start":1323,"line_end":1323,"column_start":8,"column_end":17},"name":"write_u48","qualname":"::io::WriteBytesExt::write_u48","value":"fn <T> (&mut self, n: u64) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 48 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 48 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_u48::<BigEndian>(52360336390828).unwrap();\n wtr.write_u48::<BigEndian>(541).unwrap();\n assert_eq!(wtr, b\"\\x2f\\x9f\\x17\\x40\\x3a\\xac\\x00\\x00\\x00\\x00\\x02\\x1d\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":145364,"byte_end":145373,"line_start":1322,"line_end":1322,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":127},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":146250,"byte_end":146259,"line_start":1350,"line_end":1350,"column_start":8,"column_end":17},"name":"write_i48","qualname":"::io::WriteBytesExt::write_i48","value":"fn <T> (&mut self, n: i64) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 48 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 48 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_i48::<BigEndian>(-108363435763825).unwrap();\n wtr.write_i48::<BigEndian>(77).unwrap();\n assert_eq!(wtr, b\"\\x9d\\x71\\xab\\xe7\\x97\\x8f\\x00\\x00\\x00\\x00\\x00\\x4d\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":146233,"byte_end":146242,"line_start":1349,"line_end":1349,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":130},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":147140,"byte_end":147149,"line_start":1377,"line_end":1377,"column_start":8,"column_end":17},"name":"write_u64","qualname":"::io::WriteBytesExt::write_u64","value":"fn <T> (&mut self, n: u64) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 64 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write unsigned 64 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_u64::<BigEndian>(918733457491587).unwrap();\n wtr.write_u64::<BigEndian>(143).unwrap();\n assert_eq!(wtr, b\"\\x00\\x03\\x43\\x95\\x4d\\x60\\x86\\x83\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8f\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":147123,"byte_end":147132,"line_start":1376,"line_end":1376,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":133},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148039,"byte_end":148048,"line_start":1404,"line_end":1404,"column_start":8,"column_end":17},"name":"write_i64","qualname":"::io::WriteBytesExt::write_i64","value":"fn <T> (&mut self, n: i64) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 64 bit integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write signed 64 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_i64::<BigEndian>(i64::min_value()).unwrap();\n wtr.write_i64::<BigEndian>(i64::max_value()).unwrap();\n assert_eq!(wtr, b\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148022,"byte_end":148031,"line_start":1403,"line_end":1403,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":136},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148316,"byte_end":148326,"line_start":1413,"line_end":1413,"column_start":8,"column_end":18},"name":"write_u128","qualname":"::io::WriteBytesExt::write_u128","value":"fn <T> (&mut self, n: u128) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned 128 bit integer to the underlying writer.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148272,"byte_end":148294,"line_start":1411,"line_end":1411,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148299,"byte_end":148308,"line_start":1412,"line_end":1412,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":139},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148594,"byte_end":148604,"line_start":1422,"line_end":1422,"column_start":8,"column_end":18},"name":"write_i128","qualname":"::io::WriteBytesExt::write_i128","value":"fn <T> (&mut self, n: i128) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed 128 bit integer to the underlying writer.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148550,"byte_end":148572,"line_start":1420,"line_end":1420,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":148577,"byte_end":148586,"line_start":1421,"line_end":1421,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":142},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":149647,"byte_end":149657,"line_start":1454,"line_end":1454,"column_start":8,"column_end":18},"name":"write_uint","qualname":"::io::WriteBytesExt::write_uint","value":"fn <T> (&mut self, n: u64, nbytes: usize) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned n-bytes integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Panics\n\n If the given integer is not representable in the given number of bytes,\n this method panics. If `nbytes > 8`, this method panics.\n\n # Examples\n\n Write unsigned 40 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_uint::<BigEndian>(312550384361, 5).unwrap();\n wtr.write_uint::<BigEndian>(43, 5).unwrap();\n assert_eq!(wtr, b\"\\x48\\xc5\\x74\\x62\\xe9\\x00\\x00\\x00\\x00\\x2b\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":149630,"byte_end":149639,"line_start":1453,"line_end":1453,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":145},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":150777,"byte_end":150786,"line_start":1490,"line_end":1490,"column_start":8,"column_end":17},"name":"write_int","qualname":"::io::WriteBytesExt::write_int","value":"fn <T> (&mut self, n: i64, nbytes: usize) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed n-bytes integer to the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Panics\n\n If the given integer is not representable in the given number of bytes,\n this method panics. If `nbytes > 8`, this method panics.\n\n # Examples\n\n Write signed 56 bit big-endian integers to a `Write`:\n\n ```rust\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_int::<BigEndian>(-3548172039376767, 7).unwrap();\n wtr.write_int::<BigEndian>(43, 7).unwrap();\n assert_eq!(wtr, b\"\\xf3\\x64\\xf4\\xd1\\xfd\\xb0\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x2b\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":150760,"byte_end":150769,"line_start":1489,"line_end":1489,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":148},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151273,"byte_end":151286,"line_start":1506,"line_end":1506,"column_start":8,"column_end":21},"name":"write_uint128","qualname":"::io::WriteBytesExt::write_uint128","value":"fn <T> (&mut self, n: u128, nbytes: usize) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes an unsigned n-bytes integer to the underlying writer.\n\n If the given integer is not representable in the given number of bytes,\n this method panics. If `nbytes > 16`, this method panics.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151229,"byte_end":151251,"line_start":1504,"line_end":1504,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151256,"byte_end":151265,"line_start":1505,"line_end":1505,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":151},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151776,"byte_end":151788,"line_start":1522,"line_end":1522,"column_start":8,"column_end":20},"name":"write_int128","qualname":"::io::WriteBytesExt::write_int128","value":"fn <T> (&mut self, n: i128, nbytes: usize) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a signed n-bytes integer to the underlying writer.\n\n If the given integer is not representable in the given number of bytes,\n this method panics. If `nbytes > 16`, this method panics.\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151732,"byte_end":151754,"line_start":1520,"line_end":1520,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":151759,"byte_end":151768,"line_start":1521,"line_end":1521,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":154},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":152727,"byte_end":152736,"line_start":1555,"line_end":1555,"column_start":8,"column_end":17},"name":"write_f32","qualname":"::io::WriteBytesExt::write_f32","value":"fn <T> (&mut self, n: f32) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a IEEE754 single-precision (4 bytes) floating point number to\n the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write a big-endian single-precision floating point number to a `Write`:\n\n ```rust\n use std::f32;\n\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_f32::<BigEndian>(f32::consts::PI).unwrap();\n assert_eq!(wtr, b\"\\x40\\x49\\x0f\\xdb\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":152710,"byte_end":152719,"line_start":1554,"line_end":1554,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":157},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":153621,"byte_end":153630,"line_start":1584,"line_end":1584,"column_start":8,"column_end":17},"name":"write_f64","qualname":"::io::WriteBytesExt::write_f64","value":"fn <T> (&mut self, n: f64) -> Result<()>","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":" Writes a IEEE754 double-precision (8 bytes) floating point number to\n the underlying writer.\n\n # Errors\n\n This method returns the same errors as [`Write::write_all`].\n\n [`Write::write_all`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all\n\n # Examples\n\n Write a big-endian double-precision floating point number to a `Write`:\n\n ```rust\n use std::f64;\n\n use byteorder::{BigEndian, WriteBytesExt};\n\n let mut wtr = Vec::new();\n wtr.write_f64::<BigEndian>(f64::consts::PI).unwrap();\n assert_eq!(wtr, b\"\\x40\\x09\\x21\\xfb\\x54\\x44\\x2d\\x18\");\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":153604,"byte_end":153613,"line_start":1583,"line_end":1583,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":172},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":4472,"byte_end":4478,"line_start":182,"line_end":182,"column_start":15,"column_end":21},"name":"Sealed","qualname":"::private::Sealed","value":"Sealed","parent":null,"children":[],"decl_id":null,"docs":" Sealed stops crates other than byteorder from implementing any traits\n that use it.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":175},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5724,"byte_end":5733,"line_start":222,"line_end":222,"column_start":11,"column_end":20},"name":"ByteOrder","qualname":"::ByteOrder","value":"ByteOrder: Clone + Copy + Debug + Default + Eq + Hash + Ord + PartialEq + PartialOrd +\nprivate::Sealed","parent":null,"children":[{"krate":0,"index":176},{"krate":0,"index":177},{"krate":0,"index":178},{"krate":0,"index":179},{"krate":0,"index":180},{"krate":0,"index":181},{"krate":0,"index":182},{"krate":0,"index":183},{"krate":0,"index":184},{"krate":0,"index":185},{"krate":0,"index":186},{"krate":0,"index":187},{"krate":0,"index":188},{"krate":0,"index":189},{"krate":0,"index":190},{"krate":0,"index":191},{"krate":0,"index":192},{"krate":0,"index":193},{"krate":0,"index":194},{"krate":0,"index":195},{"krate":0,"index":196},{"krate":0,"index":197},{"krate":0,"index":198},{"krate":0,"index":199},{"krate":0,"index":200},{"krate":0,"index":201},{"krate":0,"index":202},{"krate":0,"index":203},{"krate":0,"index":204},{"krate":0,"index":205},{"krate":0,"index":206},{"krate":0,"index":207},{"krate":0,"index":208},{"krate":0,"index":209},{"krate":0,"index":210},{"krate":0,"index":211},{"krate":0,"index":212},{"krate":0,"index":213},{"krate":0,"index":214},{"krate":0,"index":215},{"krate":0,"index":216},{"krate":0,"index":217},{"krate":0,"index":218},{"krate":0,"index":219},{"krate":0,"index":220},{"krate":0,"index":221},{"krate":0,"index":222},{"krate":0,"index":223},{"krate":0,"index":224},{"krate":0,"index":225},{"krate":0,"index":226},{"krate":0,"index":227},{"krate":0,"index":228},{"krate":0,"index":229},{"krate":0,"index":230},{"krate":0,"index":231},{"krate":0,"index":232},{"krate":0,"index":233},{"krate":0,"index":234},{"krate":0,"index":235},{"krate":0,"index":236},{"krate":0,"index":237},{"krate":0,"index":238},{"krate":0,"index":239},{"krate":0,"index":240},{"krate":0,"index":241},{"krate":0,"index":242},{"krate":0,"index":243}],"decl_id":null,"docs":" `ByteOrder` describes types that can serialize integers as bytes.\n\n Note that `Self` does not appear anywhere in this trait's definition!\n Therefore, in order to use it, you'll need to use syntax like\n `T::read_u16(&[0, 1])` where `T` implements `ByteOrder`.\n\n This crate provides two types that implement `ByteOrder`: [`BigEndian`]\n and [`LittleEndian`].\n This trait is sealed and cannot be implemented for callers to avoid\n breaking backwards compatibility when adding new derived traits.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_u32(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u32(&buf));\n ```\n\n Write and read `i16` numbers in big endian order:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut buf = [0; 2];\n BigEndian::write_i16(&mut buf, -5_000);\n assert_eq!(-5_000, BigEndian::read_i16(&buf));\n ```\n\n [`BigEndian`]: enum.BigEndian.html\n [`LittleEndian`]: enum.LittleEndian.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":176},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5968,"byte_end":5976,"line_start":231,"line_end":231,"column_start":8,"column_end":16},"name":"read_u16","qualname":"::ByteOrder::read_u16","value":"fn (buf: &[u8]) -> u16","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 16 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 2`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":177},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":6485,"byte_end":6493,"line_start":250,"line_end":250,"column_start":8,"column_end":16},"name":"read_u24","qualname":"::ByteOrder::read_u24","value":"fn (buf: &[u8]) -> u32","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 24 bit integer from `buf`, stored in u32.\n\n # Panics\n\n Panics when `buf.len() < 3`.\n\n # Examples\n\n Write and read 24 bit `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_u24(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u24(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":178},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":7026,"byte_end":7034,"line_start":271,"line_end":271,"column_start":8,"column_end":16},"name":"read_u32","qualname":"::ByteOrder::read_u32","value":"fn (buf: &[u8]) -> u32","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 32 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_u32(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u32(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":179},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":7559,"byte_end":7567,"line_start":290,"line_end":290,"column_start":8,"column_end":16},"name":"read_u48","qualname":"::ByteOrder::read_u48","value":"fn (buf: &[u8]) -> u64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 48 bit integer from `buf`, stored in u64.\n\n # Panics\n\n Panics when `buf.len() < 6`.\n\n # Examples\n\n Write and read 48 bit `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 6];\n LittleEndian::write_u48(&mut buf, 1_000_000_000_000);\n assert_eq!(1_000_000_000_000, LittleEndian::read_u48(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":180},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":8100,"byte_end":8108,"line_start":311,"line_end":311,"column_start":8,"column_end":16},"name":"read_u64","qualname":"::ByteOrder::read_u64","value":"fn (buf: &[u8]) -> u64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 64 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 8];\n LittleEndian::write_u64(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u64(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":181},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":8628,"byte_end":8637,"line_start":331,"line_end":331,"column_start":8,"column_end":17},"name":"read_u128","qualname":"::ByteOrder::read_u128","value":"fn (buf: &[u8]) -> u128","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned 128 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 16`.\n\n # Examples\n\n Write and read `u128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 16];\n LittleEndian::write_u128(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u128(&buf));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":8598,"byte_end":8620,"line_start":330,"line_end":330,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":182},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":9181,"byte_end":9190,"line_start":351,"line_end":351,"column_start":8,"column_end":17},"name":"read_uint","qualname":"::ByteOrder::read_uint","value":"fn (buf: &[u8], nbytes: usize) -> u64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned n-bytes integer from `buf`.\n\n # Panics\n\n Panics when `nbytes < 1` or `nbytes > 8` or\n `buf.len() < nbytes`\n\n # Examples\n\n Write and read an n-byte number in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_uint(&mut buf, 1_000_000, 3);\n assert_eq!(1_000_000, LittleEndian::read_uint(&buf, 3));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":183},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":9782,"byte_end":9794,"line_start":372,"line_end":372,"column_start":8,"column_end":20},"name":"read_uint128","qualname":"::ByteOrder::read_uint128","value":"fn (buf: &[u8], nbytes: usize) -> u128","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads an unsigned n-bytes integer from `buf`.\n\n # Panics\n\n Panics when `nbytes < 1` or `nbytes > 16` or\n `buf.len() < nbytes`\n\n # Examples\n\n Write and read an n-byte number in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_uint128(&mut buf, 1_000_000, 3);\n assert_eq!(1_000_000, LittleEndian::read_uint128(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":9752,"byte_end":9774,"line_start":371,"line_end":371,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":184},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":10292,"byte_end":10301,"line_start":391,"line_end":391,"column_start":8,"column_end":17},"name":"write_u16","qualname":"::ByteOrder::write_u16","value":"fn (buf: &mut [u8], n: u16) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 16 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 2`.\n\n # Examples\n\n Write and read `u16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 2];\n LittleEndian::write_u16(&mut buf, 1_000);\n assert_eq!(1_000, LittleEndian::read_u16(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":185},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":10818,"byte_end":10827,"line_start":410,"line_end":410,"column_start":8,"column_end":17},"name":"write_u24","qualname":"::ByteOrder::write_u24","value":"fn (buf: &mut [u8], n: u32) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 24 bit integer `n` to `buf`, stored in u32.\n\n # Panics\n\n Panics when `buf.len() < 3`.\n\n # Examples\n\n Write and read 24 bit `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_u24(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u24(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":186},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":11372,"byte_end":11381,"line_start":431,"line_end":431,"column_start":8,"column_end":17},"name":"write_u32","qualname":"::ByteOrder::write_u32","value":"fn (buf: &mut [u8], n: u32) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 32 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_u32(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u32(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":187},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":11914,"byte_end":11923,"line_start":450,"line_end":450,"column_start":8,"column_end":17},"name":"write_u48","qualname":"::ByteOrder::write_u48","value":"fn (buf: &mut [u8], n: u64) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 48 bit integer `n` to `buf`, stored in u64.\n\n # Panics\n\n Panics when `buf.len() < 6`.\n\n # Examples\n\n Write and read 48 bit `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 6];\n LittleEndian::write_u48(&mut buf, 1_000_000_000_000);\n assert_eq!(1_000_000_000_000, LittleEndian::read_u48(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":188},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":12468,"byte_end":12477,"line_start":471,"line_end":471,"column_start":8,"column_end":17},"name":"write_u64","qualname":"::ByteOrder::write_u64","value":"fn (buf: &mut [u8], n: u64) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 64 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 8];\n LittleEndian::write_u64(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u64(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":189},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":13005,"byte_end":13015,"line_start":491,"line_end":491,"column_start":8,"column_end":18},"name":"write_u128","qualname":"::ByteOrder::write_u128","value":"fn (buf: &mut [u8], n: u128) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned 128 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 16`.\n\n # Examples\n\n Write and read `u128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 16];\n LittleEndian::write_u128(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u128(&buf));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":12975,"byte_end":12997,"line_start":490,"line_end":490,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":190},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":13605,"byte_end":13615,"line_start":511,"line_end":511,"column_start":8,"column_end":18},"name":"write_uint","qualname":"::ByteOrder::write_uint","value":"fn (buf: &mut [u8], n: u64, nbytes: usize) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned integer `n` to `buf` using only `nbytes`.\n\n # Panics\n\n If `n` is not representable in `nbytes`, or if `nbytes` is `> 8`, then\n this method panics.\n\n # Examples\n\n Write and read an n-byte number in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_uint(&mut buf, 1_000_000, 3);\n assert_eq!(1_000_000, LittleEndian::read_uint(&buf, 3));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":191},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":14253,"byte_end":14266,"line_start":532,"line_end":532,"column_start":8,"column_end":21},"name":"write_uint128","qualname":"::ByteOrder::write_uint128","value":"fn (buf: &mut [u8], n: u128, nbytes: usize) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes an unsigned integer `n` to `buf` using only `nbytes`.\n\n # Panics\n\n If `n` is not representable in `nbytes`, or if `nbytes` is `> 16`, then\n this method panics.\n\n # Examples\n\n Write and read an n-byte number in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_uint128(&mut buf, 1_000_000, 3);\n assert_eq!(1_000_000, LittleEndian::read_uint128(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":14223,"byte_end":14245,"line_start":531,"line_end":531,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":192},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":14779,"byte_end":14787,"line_start":552,"line_end":552,"column_start":8,"column_end":16},"name":"read_i16","qualname":"::ByteOrder::read_i16","value":"fn (buf: &[u8]) -> i16","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 16 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 2`.\n\n # Examples\n\n Write and read `i16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 2];\n LittleEndian::write_i16(&mut buf, -1_000);\n assert_eq!(-1_000, LittleEndian::read_i16(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":14762,"byte_end":14771,"line_start":551,"line_end":551,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":193},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":15351,"byte_end":15359,"line_start":574,"line_end":574,"column_start":8,"column_end":16},"name":"read_i24","qualname":"::ByteOrder::read_i24","value":"fn (buf: &[u8]) -> i32","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 24 bit integer from `buf`, stored in i32.\n\n # Panics\n\n Panics when `buf.len() < 3`.\n\n # Examples\n\n Write and read 24 bit `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_i24(&mut buf, -1_000_000);\n assert_eq!(-1_000_000, LittleEndian::read_i24(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":15334,"byte_end":15343,"line_start":573,"line_end":573,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":194},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":15904,"byte_end":15912,"line_start":596,"line_end":596,"column_start":8,"column_end":16},"name":"read_i32","qualname":"::ByteOrder::read_i32","value":"fn (buf: &[u8]) -> i32","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 32 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_i32(&mut buf, -1_000_000);\n assert_eq!(-1_000_000, LittleEndian::read_i32(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":15887,"byte_end":15896,"line_start":595,"line_end":595,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":195},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":16492,"byte_end":16500,"line_start":618,"line_end":618,"column_start":8,"column_end":16},"name":"read_i48","qualname":"::ByteOrder::read_i48","value":"fn (buf: &[u8]) -> i64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 48 bit integer from `buf`, stored in i64.\n\n # Panics\n\n Panics when `buf.len() < 6`.\n\n # Examples\n\n Write and read 48 bit `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 6];\n LittleEndian::write_i48(&mut buf, -1_000_000_000_000);\n assert_eq!(-1_000_000_000_000, LittleEndian::read_i48(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":16475,"byte_end":16484,"line_start":617,"line_end":617,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":196},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":17053,"byte_end":17061,"line_start":640,"line_end":640,"column_start":8,"column_end":16},"name":"read_i64","qualname":"::ByteOrder::read_i64","value":"fn (buf: &[u8]) -> i64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 64 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 8];\n LittleEndian::write_i64(&mut buf, -1_000_000_000);\n assert_eq!(-1_000_000_000, LittleEndian::read_i64(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":17036,"byte_end":17045,"line_start":639,"line_end":639,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":197},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":17644,"byte_end":17653,"line_start":663,"line_end":663,"column_start":8,"column_end":17},"name":"read_i128","qualname":"::ByteOrder::read_i128","value":"fn (buf: &[u8]) -> i128","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed 128 bit integer from `buf`.\n\n # Panics\n\n Panics when `buf.len() < 16`.\n\n # Examples\n\n Write and read `i128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 16];\n LittleEndian::write_i128(&mut buf, -1_000_000_000);\n assert_eq!(-1_000_000_000, LittleEndian::read_i128(&buf));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":17600,"byte_end":17622,"line_start":661,"line_end":661,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":17627,"byte_end":17636,"line_start":662,"line_end":662,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":198},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":18251,"byte_end":18259,"line_start":686,"line_end":686,"column_start":8,"column_end":16},"name":"read_int","qualname":"::ByteOrder::read_int","value":"fn (buf: &[u8], nbytes: usize) -> i64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed n-bytes integer from `buf`.\n\n # Panics\n\n Panics when `nbytes < 1` or `nbytes > 8` or\n `buf.len() < nbytes`\n\n # Examples\n\n Write and read n-length signed numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_int(&mut buf, -1_000, 3);\n assert_eq!(-1_000, LittleEndian::read_int(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":18234,"byte_end":18243,"line_start":685,"line_end":685,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":199},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":18926,"byte_end":18937,"line_start":710,"line_end":710,"column_start":8,"column_end":19},"name":"read_int128","qualname":"::ByteOrder::read_int128","value":"fn (buf: &[u8], nbytes: usize) -> i128","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a signed n-bytes integer from `buf`.\n\n # Panics\n\n Panics when `nbytes < 1` or `nbytes > 16` or\n `buf.len() < nbytes`\n\n # Examples\n\n Write and read n-length signed numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_int128(&mut buf, -1_000, 3);\n assert_eq!(-1_000, LittleEndian::read_int128(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":18882,"byte_end":18904,"line_start":708,"line_end":708,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":18909,"byte_end":18918,"line_start":709,"line_end":709,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":200},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":19555,"byte_end":19563,"line_start":733,"line_end":733,"column_start":8,"column_end":16},"name":"read_f32","qualname":"::ByteOrder::read_f32","value":"fn (buf: &[u8]) -> f32","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a IEEE754 single-precision (4 bytes) floating point number.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `f32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let e = 2.71828;\n let mut buf = [0; 4];\n LittleEndian::write_f32(&mut buf, e);\n assert_eq!(e, LittleEndian::read_f32(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":19538,"byte_end":19547,"line_start":732,"line_end":732,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":201},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":20183,"byte_end":20191,"line_start":756,"line_end":756,"column_start":8,"column_end":16},"name":"read_f64","qualname":"::ByteOrder::read_f64","value":"fn (buf: &[u8]) -> f64","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads a IEEE754 double-precision (8 bytes) floating point number.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `f64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let phi = 1.6180339887;\n let mut buf = [0; 8];\n LittleEndian::write_f64(&mut buf, phi);\n assert_eq!(phi, LittleEndian::read_f64(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":20166,"byte_end":20175,"line_start":755,"line_end":755,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":202},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":20764,"byte_end":20773,"line_start":778,"line_end":778,"column_start":8,"column_end":17},"name":"write_i16","qualname":"::ByteOrder::write_i16","value":"fn (buf: &mut [u8], n: i16) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 16 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 2`.\n\n # Examples\n\n Write and read `i16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 2];\n LittleEndian::write_i16(&mut buf, -1_000);\n assert_eq!(-1_000, LittleEndian::read_i16(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":20747,"byte_end":20756,"line_start":777,"line_end":777,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":203},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":21349,"byte_end":21358,"line_start":800,"line_end":800,"column_start":8,"column_end":17},"name":"write_i24","qualname":"::ByteOrder::write_i24","value":"fn (buf: &mut [u8], n: i32) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 24 bit integer `n` to `buf`, stored in i32.\n\n # Panics\n\n Panics when `buf.len() < 3`.\n\n # Examples\n\n Write and read 24 bit `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_i24(&mut buf, -1_000_000);\n assert_eq!(-1_000_000, LittleEndian::read_i24(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":21332,"byte_end":21341,"line_start":799,"line_end":799,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":204},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":21915,"byte_end":21924,"line_start":822,"line_end":822,"column_start":8,"column_end":17},"name":"write_i32","qualname":"::ByteOrder::write_i32","value":"fn (buf: &mut [u8], n: i32) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 32 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_i32(&mut buf, -1_000_000);\n assert_eq!(-1_000_000, LittleEndian::read_i32(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":21898,"byte_end":21907,"line_start":821,"line_end":821,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":205},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":22516,"byte_end":22525,"line_start":844,"line_end":844,"column_start":8,"column_end":17},"name":"write_i48","qualname":"::ByteOrder::write_i48","value":"fn (buf: &mut [u8], n: i64) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 48 bit integer `n` to `buf`, stored in i64.\n\n # Panics\n\n Panics when `buf.len() < 6`.\n\n # Examples\n\n Write and read 48 bit `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 6];\n LittleEndian::write_i48(&mut buf, -1_000_000_000_000);\n assert_eq!(-1_000_000_000_000, LittleEndian::read_i48(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":22499,"byte_end":22508,"line_start":843,"line_end":843,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":206},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":23090,"byte_end":23099,"line_start":866,"line_end":866,"column_start":8,"column_end":17},"name":"write_i64","qualname":"::ByteOrder::write_i64","value":"fn (buf: &mut [u8], n: i64) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 64 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 8];\n LittleEndian::write_i64(&mut buf, -1_000_000_000);\n assert_eq!(-1_000_000_000, LittleEndian::read_i64(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":23073,"byte_end":23082,"line_start":865,"line_end":865,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":207},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":23701,"byte_end":23711,"line_start":889,"line_end":889,"column_start":8,"column_end":18},"name":"write_i128","qualname":"::ByteOrder::write_i128","value":"fn (buf: &mut [u8], n: i128) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed 128 bit integer `n` to `buf`.\n\n # Panics\n\n Panics when `buf.len() < 16`.\n\n # Examples\n\n Write and read n-byte `i128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 16];\n LittleEndian::write_i128(&mut buf, -1_000_000_000);\n assert_eq!(-1_000_000_000, LittleEndian::read_i128(&buf));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":23657,"byte_end":23679,"line_start":887,"line_end":887,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":23684,"byte_end":23693,"line_start":888,"line_end":888,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":208},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":24352,"byte_end":24361,"line_start":912,"line_end":912,"column_start":8,"column_end":17},"name":"write_int","qualname":"::ByteOrder::write_int","value":"fn (buf: &mut [u8], n: i64, nbytes: usize) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed integer `n` to `buf` using only `nbytes`.\n\n # Panics\n\n If `n` is not representable in `nbytes`, or if `nbytes` is `> 8`, then\n this method panics.\n\n # Examples\n\n Write and read an n-byte number in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_int(&mut buf, -1_000, 3);\n assert_eq!(-1_000, LittleEndian::read_int(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":24335,"byte_end":24344,"line_start":911,"line_end":911,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":209},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":25080,"byte_end":25092,"line_start":936,"line_end":936,"column_start":8,"column_end":20},"name":"write_int128","qualname":"::ByteOrder::write_int128","value":"fn (buf: &mut [u8], n: i128, nbytes: usize) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a signed integer `n` to `buf` using only `nbytes`.\n\n # Panics\n\n If `n` is not representable in `nbytes`, or if `nbytes` is `> 16`, then\n this method panics.\n\n # Examples\n\n Write and read n-length signed numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 3];\n LittleEndian::write_int128(&mut buf, -1_000, 3);\n assert_eq!(-1_000, LittleEndian::read_int128(&buf, 3));\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":25036,"byte_end":25058,"line_start":934,"line_end":934,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":25063,"byte_end":25072,"line_start":935,"line_end":935,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":210},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":25722,"byte_end":25731,"line_start":959,"line_end":959,"column_start":8,"column_end":17},"name":"write_f32","qualname":"::ByteOrder::write_f32","value":"fn (buf: &mut [u8], n: f32) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a IEEE754 single-precision (4 bytes) floating point number.\n\n # Panics\n\n Panics when `buf.len() < 4`.\n\n # Examples\n\n Write and read `f32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let e = 2.71828;\n let mut buf = [0; 4];\n LittleEndian::write_f32(&mut buf, e);\n assert_eq!(e, LittleEndian::read_f32(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":25705,"byte_end":25714,"line_start":958,"line_end":958,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":211},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":26380,"byte_end":26389,"line_start":983,"line_end":983,"column_start":8,"column_end":17},"name":"write_f64","qualname":"::ByteOrder::write_f64","value":"fn (buf: &mut [u8], n: f64) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes a IEEE754 double-precision (8 bytes) floating point number.\n\n # Panics\n\n Panics when `buf.len() < 8`.\n\n # Examples\n\n Write and read `f64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let phi = 1.6180339887;\n let mut buf = [0; 8];\n LittleEndian::write_f64(&mut buf, phi);\n assert_eq!(phi, LittleEndian::read_f64(&buf));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":26363,"byte_end":26372,"line_start":982,"line_end":982,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":212},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":27164,"byte_end":27177,"line_start":1009,"line_end":1009,"column_start":8,"column_end":21},"name":"read_u16_into","qualname":"::ByteOrder::read_u16_into","value":"fn (src: &[u8], dst: &mut [u16]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads unsigned 16 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 2*dst.len()`.\n\n # Examples\n\n Write and read `u16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 8];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u16_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u16_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":213},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":27857,"byte_end":27870,"line_start":1032,"line_end":1032,"column_start":8,"column_end":21},"name":"read_u32_into","qualname":"::ByteOrder::read_u32_into","value":"fn (src: &[u8], dst: &mut [u32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads unsigned 32 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 4*dst.len()`.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u32_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":214},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":28550,"byte_end":28563,"line_start":1055,"line_end":1055,"column_start":8,"column_end":21},"name":"read_u64_into","qualname":"::ByteOrder::read_u64_into","value":"fn (src: &[u8], dst: &mut [u64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads unsigned 64 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 8*dst.len()`.\n\n # Examples\n\n Write and read `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u64_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":215},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":29275,"byte_end":29289,"line_start":1079,"line_end":1079,"column_start":8,"column_end":22},"name":"read_u128_into","qualname":"::ByteOrder::read_u128_into","value":"fn (src: &[u8], dst: &mut [u128]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads unsigned 128 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 16*dst.len()`.\n\n # Examples\n\n Write and read `u128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 64];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u128_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u128_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":29245,"byte_end":29267,"line_start":1078,"line_end":1078,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":216},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":29975,"byte_end":29988,"line_start":1103,"line_end":1103,"column_start":8,"column_end":21},"name":"read_i16_into","qualname":"::ByteOrder::read_i16_into","value":"fn (src: &[u8], dst: &mut [i16]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads signed 16 bit integers from `src` to `dst`.\n\n # Panics\n\n Panics when `buf.len() != 2*dst.len()`.\n\n # Examples\n\n Write and read `i16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 8];\n let numbers_given = [1, 2, 0x0f, 0xee];\n LittleEndian::write_i16_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i16_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":29958,"byte_end":29967,"line_start":1102,"line_end":1102,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":217},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":30842,"byte_end":30855,"line_start":1132,"line_end":1132,"column_start":8,"column_end":21},"name":"read_i32_into","qualname":"::ByteOrder::read_i32_into","value":"fn (src: &[u8], dst: &mut [i32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads signed 32 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 4*dst.len()`.\n\n # Examples\n\n Write and read `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i32_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":30825,"byte_end":30834,"line_start":1131,"line_end":1131,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":218},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":31710,"byte_end":31723,"line_start":1161,"line_end":1161,"column_start":8,"column_end":21},"name":"read_i64_into","qualname":"::ByteOrder::read_i64_into","value":"fn (src: &[u8], dst: &mut [i64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads signed 64 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 8*dst.len()`.\n\n # Examples\n\n Write and read `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i64_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":31693,"byte_end":31702,"line_start":1160,"line_end":1160,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":219},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":32610,"byte_end":32624,"line_start":1191,"line_end":1191,"column_start":8,"column_end":22},"name":"read_i128_into","qualname":"::ByteOrder::read_i128_into","value":"fn (src: &[u8], dst: &mut [i128]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads signed 128 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 16*dst.len()`.\n\n # Examples\n\n Write and read `i128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 64];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i128_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i128_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":32566,"byte_end":32588,"line_start":1189,"line_end":1189,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":32593,"byte_end":32602,"line_start":1190,"line_end":1190,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":220},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":33537,"byte_end":33550,"line_start":1221,"line_end":1221,"column_start":8,"column_end":21},"name":"read_f32_into","qualname":"::ByteOrder::read_f32_into","value":"fn (src: &[u8], dst: &mut [f32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads IEEE754 single-precision (4 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 4*dst.len()`.\n\n # Examples\n\n Write and read `f32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1.0, 2.0, 31.312e31, -11.32e19];\n LittleEndian::write_f32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n LittleEndian::read_f32_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":33520,"byte_end":33529,"line_start":1220,"line_end":1220,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":221},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":34642,"byte_end":34665,"line_start":1255,"line_end":1255,"column_start":8,"column_end":31},"name":"read_f32_into_unchecked","qualname":"::ByteOrder::read_f32_into_unchecked","value":"fn (src: &[u8], dst: &mut [f32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" **DEPRECATED**.\n\n This method is deprecated. Use `read_f32_into` instead.\n Reads IEEE754 single-precision (4 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 4*dst.len()`.\n\n # Examples\n\n Write and read `f32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1.0, 2.0, 31.312e31, -11.32e19];\n LittleEndian::write_f32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n LittleEndian::read_f32_into_unchecked(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":34549,"byte_end":34558,"line_start":1253,"line_end":1253,"column_start":5,"column_end":14}},{"value":"deprecated(since = \"1.3.0\", note = \"please use `read_f32_into` instead\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":34563,"byte_end":34634,"line_start":1254,"line_end":1254,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":222},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":35459,"byte_end":35472,"line_start":1282,"line_end":1282,"column_start":8,"column_end":21},"name":"read_f64_into","qualname":"::ByteOrder::read_f64_into","value":"fn (src: &[u8], dst: &mut [f64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Reads IEEE754 single-precision (4 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 8*dst.len()`.\n\n # Examples\n\n Write and read `f64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1.0, 2.0, 31.312e211, -11.32e91];\n LittleEndian::write_f64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n LittleEndian::read_f64_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":35442,"byte_end":35451,"line_start":1281,"line_end":1281,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":223},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":36573,"byte_end":36596,"line_start":1317,"line_end":1317,"column_start":8,"column_end":31},"name":"read_f64_into_unchecked","qualname":"::ByteOrder::read_f64_into_unchecked","value":"fn (src: &[u8], dst: &mut [f64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" **DEPRECATED**.\n\n This method is deprecated. Use `read_f64_into` instead.\n\n Reads IEEE754 single-precision (4 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 8*dst.len()`.\n\n # Examples\n\n Write and read `f64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1.0, 2.0, 31.312e211, -11.32e91];\n LittleEndian::write_f64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n LittleEndian::read_f64_into_unchecked(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":36480,"byte_end":36489,"line_start":1315,"line_end":1315,"column_start":5,"column_end":14}},{"value":"deprecated(since = \"1.3.0\", note = \"please use `read_f64_into` instead\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":36494,"byte_end":36565,"line_start":1316,"line_end":1316,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":224},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":37322,"byte_end":37336,"line_start":1342,"line_end":1342,"column_start":8,"column_end":22},"name":"write_u16_into","qualname":"::ByteOrder::write_u16_into","value":"fn (src: &[u16], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes unsigned 16 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 2*src.len()`.\n\n # Examples\n\n Write and read `u16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 8];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u16_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u16_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":225},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":38017,"byte_end":38031,"line_start":1365,"line_end":1365,"column_start":8,"column_end":22},"name":"write_u32_into","qualname":"::ByteOrder::write_u32_into","value":"fn (src: &[u32], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes unsigned 32 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 4*src.len()`.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u32_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":226},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":38712,"byte_end":38726,"line_start":1388,"line_end":1388,"column_start":8,"column_end":22},"name":"write_u64_into","qualname":"::ByteOrder::write_u64_into","value":"fn (src: &[u64], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes unsigned 64 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 8*src.len()`.\n\n # Examples\n\n Write and read `u64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u64_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":227},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":39439,"byte_end":39454,"line_start":1412,"line_end":1412,"column_start":8,"column_end":23},"name":"write_u128_into","qualname":"::ByteOrder::write_u128_into","value":"fn (src: &[u128], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes unsigned 128 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 16*src.len()`.\n\n # Examples\n\n Write and read `u128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 64];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_u128_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_u128_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":39409,"byte_end":39431,"line_start":1411,"line_end":1411,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":228},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":40129,"byte_end":40143,"line_start":1435,"line_end":1435,"column_start":8,"column_end":22},"name":"write_i16_into","qualname":"::ByteOrder::write_i16_into","value":"fn (src: &[i16], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes signed 16 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `buf.len() != 2*src.len()`.\n\n # Examples\n\n Write and read `i16` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 8];\n let numbers_given = [1, 2, 0x0f, 0xee];\n LittleEndian::write_i16_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i16_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":229},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":40980,"byte_end":40994,"line_start":1463,"line_end":1463,"column_start":8,"column_end":22},"name":"write_i32_into","qualname":"::ByteOrder::write_i32_into","value":"fn (src: &[i32], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes signed 32 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 4*src.len()`.\n\n # Examples\n\n Write and read `i32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i32_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":230},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":41831,"byte_end":41845,"line_start":1491,"line_end":1491,"column_start":8,"column_end":22},"name":"write_i64_into","qualname":"::ByteOrder::write_i64_into","value":"fn (src: &[i64], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes signed 64 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 8*src.len()`.\n\n # Examples\n\n Write and read `i64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i64_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":231},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":42714,"byte_end":42729,"line_start":1520,"line_end":1520,"column_start":8,"column_end":23},"name":"write_i128_into","qualname":"::ByteOrder::write_i128_into","value":"fn (src: &[i128], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes signed 128 bit integers from `src` into `dst`.\n\n # Panics\n\n Panics when `dst.len() != 16*src.len()`.\n\n # Examples\n\n Write and read `i128` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 64];\n let numbers_given = [1, 2, 0xf00f, 0xffee];\n LittleEndian::write_i128_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0; 4];\n LittleEndian::read_i128_into(&bytes, &mut numbers_got);\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":42684,"byte_end":42706,"line_start":1519,"line_end":1519,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":232},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":43655,"byte_end":43669,"line_start":1551,"line_end":1551,"column_start":8,"column_end":22},"name":"write_f32_into","qualname":"::ByteOrder::write_f32_into","value":"fn (src: &[f32], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes IEEE754 single-precision (4 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 4*dst.len()`.\n\n # Examples\n\n Write and read `f32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 16];\n let numbers_given = [1.0, 2.0, 31.312e31, -11.32e19];\n LittleEndian::write_f32_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n unsafe {\n     LittleEndian::read_f32_into(&bytes, &mut numbers_got);\n }\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":233},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":44593,"byte_end":44607,"line_start":1582,"line_end":1582,"column_start":8,"column_end":22},"name":"write_f64_into","qualname":"::ByteOrder::write_f64_into","value":"fn (src: &[f64], dst: &mut [u8]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Writes IEEE754 double-precision (8 bytes) floating point numbers from\n `src` into `dst`.\n\n # Panics\n\n Panics when `src.len() != 8*dst.len()`.\n\n # Examples\n\n Write and read `f64` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut bytes = [0; 32];\n let numbers_given = [1.0, 2.0, 31.312e211, -11.32e91];\n LittleEndian::write_f64_into(&numbers_given, &mut bytes);\n\n let mut numbers_got = [0.0; 4];\n unsafe {\n     LittleEndian::read_f64_into(&bytes, &mut numbers_got);\n }\n assert_eq!(numbers_given, numbers_got);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":234},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":45348,"byte_end":45362,"line_start":1606,"line_end":1606,"column_start":8,"column_end":22},"name":"from_slice_u16","qualname":"::ByteOrder::from_slice_u16","value":"fn (numbers: &mut [u16]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of unsigned 16 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_u16(&mut numbers);\n assert_eq!(numbers, [5u16.to_be(), 65000u16.to_be()]);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":235},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":45937,"byte_end":45951,"line_start":1625,"line_end":1625,"column_start":8,"column_end":22},"name":"from_slice_u32","qualname":"::ByteOrder::from_slice_u32","value":"fn (numbers: &mut [u32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of unsigned 32 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_u32(&mut numbers);\n assert_eq!(numbers, [5u32.to_be(), 65000u32.to_be()]);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":236},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":46526,"byte_end":46540,"line_start":1644,"line_end":1644,"column_start":8,"column_end":22},"name":"from_slice_u64","qualname":"::ByteOrder::from_slice_u64","value":"fn (numbers: &mut [u64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of unsigned 64 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_u64(&mut numbers);\n assert_eq!(numbers, [5u64.to_be(), 65000u64.to_be()]);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":237},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":47146,"byte_end":47161,"line_start":1664,"line_end":1664,"column_start":8,"column_end":23},"name":"from_slice_u128","qualname":"::ByteOrder::from_slice_u128","value":"fn (numbers: &mut [u128]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of unsigned 128 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_u128(&mut numbers);\n assert_eq!(numbers, [5u128.to_be(), 65000u128.to_be()]);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":47116,"byte_end":47138,"line_start":1663,"line_end":1663,"column_start":5,"column_end":27}}]},{"kind":"Method","id":{"krate":0,"index":238},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":47747,"byte_end":47761,"line_start":1684,"line_end":1684,"column_start":8,"column_end":22},"name":"from_slice_i16","qualname":"::ByteOrder::from_slice_i16","value":"fn (src: &mut [i16]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of signed 16 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 6500];\n BigEndian::from_slice_i16(&mut numbers);\n assert_eq!(numbers, [5i16.to_be(), 6500i16.to_be()]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":47730,"byte_end":47739,"line_start":1683,"line_end":1683,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":239},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":48499,"byte_end":48513,"line_start":1709,"line_end":1709,"column_start":8,"column_end":22},"name":"from_slice_i32","qualname":"::ByteOrder::from_slice_i32","value":"fn (src: &mut [i32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of signed 32 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_i32(&mut numbers);\n assert_eq!(numbers, [5i32.to_be(), 65000i32.to_be()]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":48482,"byte_end":48491,"line_start":1708,"line_end":1708,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":240},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":49251,"byte_end":49265,"line_start":1734,"line_end":1734,"column_start":8,"column_end":22},"name":"from_slice_i64","qualname":"::ByteOrder::from_slice_i64","value":"fn (src: &mut [i64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of signed 64 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_i64(&mut numbers);\n assert_eq!(numbers, [5i64.to_be(), 65000i64.to_be()]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":49234,"byte_end":49243,"line_start":1733,"line_end":1733,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":241},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":50034,"byte_end":50049,"line_start":1760,"line_end":1760,"column_start":8,"column_end":23},"name":"from_slice_i128","qualname":"::ByteOrder::from_slice_i128","value":"fn (src: &mut [i128]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of signed 128 bit integers to a particular\n endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n\n # Examples\n\n Convert the host platform's endianness to big-endian:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut numbers = [5, 65000];\n BigEndian::from_slice_i128(&mut numbers);\n assert_eq!(numbers, [5i128.to_be(), 65000i128.to_be()]);\n ```\n","sig":null,"attributes":[{"value":"cfg(byteorder_i128)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":49990,"byte_end":50012,"line_start":1758,"line_end":1758,"column_start":5,"column_end":27}},{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":50017,"byte_end":50026,"line_start":1759,"line_end":1759,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":242},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":50473,"byte_end":50487,"line_start":1772,"line_end":1772,"column_start":8,"column_end":22},"name":"from_slice_f32","qualname":"::ByteOrder::from_slice_f32","value":"fn (numbers: &mut [f32]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of IEEE754 single-precision (4 bytes) floating\n point numbers to a particular endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":243},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":50757,"byte_end":50771,"line_start":1779,"line_end":1779,"column_start":8,"column_end":22},"name":"from_slice_f64","qualname":"::ByteOrder::from_slice_f64","value":"fn (numbers: &mut [f64]) -> ()","parent":{"krate":0,"index":175},"children":[],"decl_id":null,"docs":" Converts the given slice of IEEE754 double-precision (8 bytes) floating\n point numbers to a particular endianness.\n\n If the endianness matches the endianness of the host platform, then\n this is a no-op.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":319},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":51282,"byte_end":51291,"line_start":1799,"line_end":1799,"column_start":10,"column_end":19},"name":"BigEndian","qualname":"::BigEndian","value":"BigEndian::{}","parent":null,"children":[],"decl_id":null,"docs":" Defines big-endian serialization.\n\n Note that this type has no value constructor. It is used purely at the\n type level.\n\n # Examples\n\n Write and read `u32` numbers in big endian order:\n\n ```rust\n use byteorder::{ByteOrder, BigEndian};\n\n let mut buf = [0; 4];\n BigEndian::write_u32(&mut buf, 1_000_000);\n assert_eq!(1_000_000, BigEndian::read_u32(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":246},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":51490,"byte_end":51492,"line_start":1810,"line_end":1810,"column_start":10,"column_end":12},"name":"BE","qualname":"::BE","value":"BigEndian","parent":null,"children":[],"decl_id":null,"docs":" A type alias for [`BigEndian`].\n\n [`BigEndian`]: enum.BigEndian.html\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":338},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":52007,"byte_end":52019,"line_start":1829,"line_end":1829,"column_start":10,"column_end":22},"name":"LittleEndian","qualname":"::LittleEndian","value":"LittleEndian::{}","parent":null,"children":[],"decl_id":null,"docs":" Defines little-endian serialization.\n\n Note that this type has no value constructor. It is used purely at the\n type level.\n\n # Examples\n\n Write and read `u32` numbers in little endian order:\n\n ```rust\n use byteorder::{ByteOrder, LittleEndian};\n\n let mut buf = [0; 4];\n LittleEndian::write_u32(&mut buf, 1_000_000);\n assert_eq!(1_000_000, LittleEndian::read_u32(&buf));\n ```\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":249},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":52236,"byte_end":52238,"line_start":1840,"line_end":1840,"column_start":10,"column_end":12},"name":"LE","qualname":"::LE","value":"LittleEndian","parent":null,"children":[],"decl_id":null,"docs":" A type alias for [`LittleEndian`].\n\n [`LittleEndian`]: enum.LittleEndian.html\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":250},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":52963,"byte_end":52976,"line_start":1866,"line_end":1866,"column_start":10,"column_end":23},"name":"NetworkEndian","qualname":"::NetworkEndian","value":"BigEndian","parent":null,"children":[],"decl_id":null,"docs":" Defines network byte order serialization.\n\n Network byte order is defined by [RFC 1700][1] to be big-endian, and is\n referred to in several protocol specifications.  This type is an alias of\n [`BigEndian`].\n\n [1]: https://tools.ietf.org/html/rfc1700\n\n Note that this type has no value constructor. It is used purely at the\n type level.\n\n # Examples\n\n Write and read `i16` numbers in big endian order:\n\n ```rust\n use byteorder::{ByteOrder, NetworkEndian, BigEndian};\n\n let mut buf = [0; 2];\n BigEndian::write_i16(&mut buf, -5_000);\n assert_eq!(-5_000, NetworkEndian::read_i16(&buf));\n ```\n\n [`BigEndian`]: enum.BigEndian.html\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":251},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":53290,"byte_end":53302,"line_start":1877,"line_end":1877,"column_start":10,"column_end":22},"name":"NativeEndian","qualname":"::NativeEndian","value":"LittleEndian","parent":null,"children":[],"decl_id":null,"docs":" Defines system native-endian serialization.\n\n Note that this type has no value constructor. It is used purely at the\n type level.\n\n On this platform, this is an alias for [`LittleEndian`].\n\n [`LittleEndian`]: enum.LittleEndian.html\n","sig":null,"attributes":[{"value":"cfg(target_endian = \"little\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":53248,"byte_end":53280,"line_start":1876,"line_end":1876,"column_start":1,"column_end":33}}]}],"impls":[{"id":0,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":137169,"byte_end":137170,"line_start":1059,"line_end":1059,"column_start":45,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":153919,"byte_end":153920,"line_start":1593,"line_end":1593,"column_start":47,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":4508,"byte_end":4520,"line_start":183,"line_end":183,"column_start":28,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":4551,"byte_end":4560,"line_start":184,"line_end":184,"column_start":28,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":51313,"byte_end":51322,"line_start":1801,"line_end":1801,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":245}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":52041,"byte_end":52053,"line_start":1831,"line_end":1831,"column_start":18,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":248}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":55543,"byte_end":55552,"line_start":1957,"line_end":1957,"column_start":20,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":258},{"krate":0,"index":259},{"krate":0,"index":260},{"krate":0,"index":261},{"krate":0,"index":262},{"krate":0,"index":264},{"krate":0,"index":266},{"krate":0,"index":267},{"krate":0,"index":268},{"krate":0,"index":269},{"krate":0,"index":270},{"krate":0,"index":272},{"krate":0,"index":274},{"krate":0,"index":275},{"krate":0,"index":276},{"krate":0,"index":277},{"krate":0,"index":278},{"krate":0,"index":279},{"krate":0,"index":280},{"krate":0,"index":281},{"krate":0,"index":282},{"krate":0,"index":283},{"krate":0,"index":284},{"krate":0,"index":285},{"krate":0,"index":286},{"krate":0,"index":287}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":61258,"byte_end":61270,"line_start":2172,"line_end":2172,"column_start":20,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":289},{"krate":0,"index":290},{"krate":0,"index":291},{"krate":0,"index":292},{"krate":0,"index":293},{"krate":0,"index":295},{"krate":0,"index":297},{"krate":0,"index":298},{"krate":0,"index":299},{"krate":0,"index":300},{"krate":0,"index":301},{"krate":0,"index":303},{"krate":0,"index":305},{"krate":0,"index":306},{"krate":0,"index":307},{"krate":0,"index":308},{"krate":0,"index":309},{"krate":0,"index":310},{"krate":0,"index":311},{"krate":0,"index":312},{"krate":0,"index":313},{"krate":0,"index":314},{"krate":0,"index":315},{"krate":0,"index":316},{"krate":0,"index":317},{"krate":0,"index":318}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":104210,"byte_end":104214,"line_start":28,"line_end":28,"column_start":29,"column_end":33},"kind":"SuperTrait","from":{"krate":1,"index":2849},"to":{"krate":0,"index":17}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":137169,"byte_end":137170,"line_start":1059,"line_end":1059,"column_start":45,"column_end":46},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":102},"to":{"krate":0,"index":17}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":137980,"byte_end":137985,"line_start":1083,"line_end":1083,"column_start":30,"column_end":35},"kind":"SuperTrait","from":{"krate":1,"index":2903},"to":{"krate":0,"index":103}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\io.rs","byte_start":153919,"byte_end":153920,"line_start":1593,"line_end":1593,"column_start":47,"column_end":48},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":161},"to":{"krate":0,"index":103}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":4508,"byte_end":4520,"line_start":183,"line_end":183,"column_start":28,"column_end":40},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":338},"to":{"krate":0,"index":172}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":4551,"byte_end":4560,"line_start":184,"line_end":184,"column_start":28,"column_end":37},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":319},"to":{"krate":0,"index":172}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5740,"byte_end":5745,"line_start":223,"line_end":223,"column_start":7,"column_end":12},"kind":"SuperTrait","from":{"krate":2,"index":2181},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5748,"byte_end":5752,"line_start":223,"line_end":223,"column_start":15,"column_end":19},"kind":"SuperTrait","from":{"krate":2,"index":1543},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5755,"byte_end":5760,"line_start":223,"line_end":223,"column_start":22,"column_end":27},"kind":"SuperTrait","from":{"krate":2,"index":7643},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5763,"byte_end":5770,"line_start":223,"line_end":223,"column_start":30,"column_end":37},"kind":"SuperTrait","from":{"krate":2,"index":2206},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5773,"byte_end":5775,"line_start":223,"line_end":223,"column_start":40,"column_end":42},"kind":"SuperTrait","from":{"krate":2,"index":2045},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5778,"byte_end":5782,"line_start":223,"line_end":223,"column_start":45,"column_end":49},"kind":"SuperTrait","from":{"krate":2,"index":7285},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5785,"byte_end":5788,"line_start":223,"line_end":223,"column_start":52,"column_end":55},"kind":"SuperTrait","from":{"krate":2,"index":2066},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5791,"byte_end":5800,"line_start":223,"line_end":223,"column_start":58,"column_end":67},"kind":"SuperTrait","from":{"krate":2,"index":2040},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5803,"byte_end":5813,"line_start":223,"line_end":223,"column_start":70,"column_end":80},"kind":"SuperTrait","from":{"krate":2,"index":2077},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":5829,"byte_end":5835,"line_start":224,"line_end":224,"column_start":16,"column_end":22},"kind":"SuperTrait","from":{"krate":0,"index":172},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":51313,"byte_end":51322,"line_start":1801,"line_end":1801,"column_start":18,"column_end":27},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":319},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":52041,"byte_end":52053,"line_start":1831,"line_end":1831,"column_start":18,"column_end":30},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":338},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":55543,"byte_end":55552,"line_start":1957,"line_end":1957,"column_start":20,"column_end":29},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":319},"to":{"krate":0,"index":175}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\byteorder-1.3.2\\src\\lib.rs","byte_start":61258,"byte_end":61270,"line_start":2172,"line_end":2172,"column_start":20,"column_end":32},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":338},"to":{"krate":0,"index":175}}]}