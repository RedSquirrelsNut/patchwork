{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","crossbeam_epoch","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"lazy_static\"","--cfg","feature=\"std\"","-C","metadata=ef047b4736e772bf","-C","extra-filename=-ef047b4736e772bf","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--extern","cfg_if=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libcfg_if-ea23fff8dcc69735.rmeta","--extern","crossbeam_utils=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libcrossbeam_utils-7691cda68fa03b20.rmeta","--extern","lazy_static=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\liblazy_static-79de1231268f023b.rmeta","--extern","memoffset=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libmemoffset-c288336f86b7c512.rmeta","--extern","scopeguard=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libscopeguard-f88443e170f6b83d.rmeta","--cap-lints","allow","--cfg","has_min_const_fn","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libcrossbeam_epoch-ef047b4736e772bf.rmeta"},"prelude":{"crate_id":{"name":"crossbeam_epoch","disambiguator":[17054536658623444655,6154134795048836908]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":1,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":2,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":14,"id":{"name":"cfg_if","disambiguator":[2442249708866091360,16714075183114805585]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":15,"id":{"name":"crossbeam_utils","disambiguator":[7709528671052336800,4286142518779901766]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":16,"id":{"name":"lazy_static","disambiguator":[17281579441627161632,7326486140096487162]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":17,"id":{"name":"memoffset","disambiguator":[16489986462602757596,1492316565336062603]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","num":18,"id":{"name":"scopeguard","disambiguator":[8293681837284562385,10699146686669501925]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":0,"byte_end":4102,"line_start":1,"line_end":106,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":57},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3712,"byte_end":3718,"line_start":92,"line_end":92,"column_start":32,"column_end":38},"alias_span":null,"name":"Atomic","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":29},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3720,"byte_end":3738,"line_start":92,"line_end":92,"column_start":40,"column_end":58},"alias_span":null,"name":"CompareAndSetError","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":40},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3740,"byte_end":3761,"line_start":92,"line_end":92,"column_start":60,"column_end":81},"alias_span":null,"name":"CompareAndSetOrdering","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":131},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3763,"byte_end":3768,"line_start":92,"line_end":92,"column_start":83,"column_end":88},"alias_span":null,"name":"Owned","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":127},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3770,"byte_end":3777,"line_start":92,"line_end":92,"column_start":90,"column_end":97},"alias_span":null,"name":"Pointer","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":182},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3779,"byte_end":3785,"line_start":92,"line_end":92,"column_start":99,"column_end":105},"alias_span":null,"name":"Shared","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":249},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3822,"byte_end":3831,"line_start":93,"line_end":93,"column_start":35,"column_end":44},"alias_span":null,"name":"Collector","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":263},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3833,"byte_end":3844,"line_start":93,"line_end":93,"column_start":46,"column_end":57},"alias_span":null,"name":"LocalHandle","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":343},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3877,"byte_end":3888,"line_start":94,"line_end":94,"column_start":31,"column_end":42},"alias_span":null,"name":"unprotected","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":319},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":3890,"byte_end":3895,"line_start":94,"line_end":94,"column_start":44,"column_end":49},"alias_span":null,"name":"Guard","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":610},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":4059,"byte_end":4076,"line_start":104,"line_end":104,"column_start":33,"column_end":50},"alias_span":null,"name":"default_collector","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":608},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":4078,"byte_end":4087,"line_start":104,"line_end":104,"column_start":52,"column_end":61},"alias_span":null,"name":"is_pinned","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":606},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":4089,"byte_end":4092,"line_start":104,"line_end":104,"column_start":63,"column_end":66},"alias_span":null,"name":"pin","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":0,"byte_end":4102,"line_start":1,"line_end":106,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":7},{"krate":0,"index":8},{"krate":0,"index":9},{"krate":0,"index":242},{"krate":0,"index":273},{"krate":0,"index":296},{"krate":0,"index":312},{"krate":0,"index":345},{"krate":0,"index":436},{"krate":0,"index":522},{"krate":0,"index":529},{"krate":0,"index":532},{"krate":0,"index":600},{"krate":0,"index":601},{"krate":0,"index":616}],"decl_id":null,"docs":" Epoch-based memory reclamation.\n\n An interesting problem concurrent collections deal with comes from the remove operation.\n Suppose that a thread removes an element from a lock-free map, while another thread is reading\n that same element at the same time. The first thread must wait until the second thread stops\n reading the element. Only then it is safe to destruct it.\n\n Programming languages that come with garbage collectors solve this problem trivially. The\n garbage collector will destruct the removed element when no thread can hold a reference to it\n anymore.\n\n This crate implements a basic memory reclamation mechanism, which is based on epochs. When an\n element gets removed from a concurrent collection, it is inserted into a pile of garbage and\n marked with the current epoch. Every time a thread accesses a collection, it checks the current\n epoch, attempts to increment it, and destructs some garbage that became so old that no thread\n can be referencing it anymore.\n\n That is the general mechanism behind epoch-based memory reclamation, but the details are a bit\n more complicated. Anyhow, memory reclamation is designed to be fully automatic and something\n users of concurrent collections don't have to worry much about.\n\n # Pointers\n\n Concurrent collections are built using atomic pointers. This module provides [`Atomic`], which\n is just a shared atomic pointer to a heap-allocated object. Loading an [`Atomic`] yields a\n [`Shared`], which is an epoch-protected pointer through which the loaded object can be safely\n read.\n\n # Pinning\n\n Before an [`Atomic`] can be loaded, a participant must be [`pin`]ned. By pinning a participant\n we declare that any object that gets removed from now on must not be destructed just\n yet. Garbage collection of newly removed objects is suspended until the participant gets\n unpinned.\n\n # Garbage\n\n Objects that get removed from concurrent collections must be stashed away until all currently\n pinned participants get unpinned. Such objects can be stored into a thread-local or global\n storage, where they are kept until the right time for their destruction comes.\n\n There is a global shared instance of garbage queue. You can [`defer`] the execution of an\n arbitrary function until the global epoch is advanced enough. Most notably, concurrent data\n structures may defer the deallocation of an object.\n\n # APIs\n\n For majority of use cases, just use the default garbage collector by invoking [`pin`]. If you\n want to create your own garbage collector, use the [`Collector`] API.\n\n [`Atomic`]: struct.Atomic.html\n [`Collector`]: struct.Collector.html\n [`Shared`]: struct.Shared.html\n [`pin`]: fn.pin.html\n [`defer`]: fn.defer.html\n","sig":null,"attributes":[{"value":"warn(missing_docs)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":2851,"byte_end":2873,"line_start":57,"line_end":57,"column_start":1,"column_end":23}},{"value":"warn(missing_debug_implementations)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\lib.rs","byte_start":2874,"byte_end":2913,"line_start":58,"line_end":58,"column_start":1,"column_end":40}}]},{"kind":"Struct","id":{"krate":0,"index":29},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7601013,"byte_end":7601031,"line_start":27,"line_end":27,"column_start":12,"column_end":30},"name":"CompareAndSetError","qualname":"::atomic::CompareAndSetError","value":"CompareAndSetError { current, new }","parent":null,"children":[{"krate":0,"index":33},{"krate":0,"index":34}],"decl_id":null,"docs":" The error returned on failed compare-and-set operation.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":33},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7601145,"byte_end":7601152,"line_start":29,"line_end":29,"column_start":9,"column_end":16},"name":"current","qualname":"::atomic::CompareAndSetError::current","value":"atomic::Shared<'g, T>","parent":{"krate":0,"index":29},"children":[],"decl_id":null,"docs":" The value in the atomic pointer at the time of the failed operation.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7601238,"byte_end":7601241,"line_start":32,"line_end":32,"column_start":9,"column_end":12},"name":"new","qualname":"::atomic::CompareAndSetError::new","value":"P","parent":{"krate":0,"index":29},"children":[],"decl_id":null,"docs":" The new value, which the operation failed to store.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":40},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7602126,"byte_end":7602147,"line_start":55,"line_end":55,"column_start":11,"column_end":32},"name":"CompareAndSetOrdering","qualname":"::atomic::CompareAndSetOrdering","value":"CompareAndSetOrdering","parent":null,"children":[{"krate":0,"index":41},{"krate":0,"index":42}],"decl_id":null,"docs":" Memory orderings for compare-and-set operations.\n\n A compare-and-set operation can have different memory orderings depending on whether it\n succeeds or fails. This trait generalizes different ways of specifying memory orderings.\n\n The two ways of specifying orderings for compare-and-set are:\n\n 1. Just one `Ordering` for the success case. In case of failure, the strongest appropriate\n    ordering is chosen.\n 2. A pair of `Ordering`s. The first one is for the success case, while the second one is\n    for the failure case.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":41},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7602213,"byte_end":7602220,"line_start":57,"line_end":57,"column_start":8,"column_end":15},"name":"success","qualname":"::atomic::CompareAndSetOrdering::success","value":"fn (&self) -> Ordering","parent":{"krate":0,"index":40},"children":[],"decl_id":null,"docs":" The ordering of the operation when it succeeds.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":42},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7602438,"byte_end":7602445,"line_start":63,"line_end":63,"column_start":8,"column_end":15},"name":"failure","qualname":"::atomic::CompareAndSetOrdering::failure","value":"fn (&self) -> Ordering","parent":{"krate":0,"index":40},"children":[],"decl_id":null,"docs":" The ordering of the operation when it fails.\n\n The failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than\n the success ordering.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":57},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604217,"byte_end":7604223,"line_start":127,"line_end":127,"column_start":12,"column_end":18},"name":"Atomic","qualname":"::atomic::Atomic","value":"Atomic {  }","parent":null,"children":[{"krate":0,"index":59},{"krate":0,"index":60}],"decl_id":null,"docs":" An atomic pointer that can be safely shared between threads.\n\n The pointer must be properly aligned. Since it is aligned, a tag can be stored into the unused\n least significant bits of the address.  More precisely, a tag should be less than `(1 <<\n mem::align_of::<T>().trailing_zeros())`.\n\n Any method that loads the pointer must be passed a reference to a [`Guard`].\n\n [`Guard`]: struct.Guard.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":68},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7605225,"byte_end":7605229,"line_start":171,"line_end":171,"column_start":18,"column_end":22},"name":"null","qualname":"<Atomic<T>>::null","value":"fn () -> Atomic<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a new null atomic pointer.\n\n # Examples\n\n ```\n use crossbeam_epoch::Atomic;\n\n let a = Atomic::<i32>::null();\n ```\n","sig":null,"attributes":[{"value":"cfg(has_min_const_fn)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7605183,"byte_end":7605207,"line_start":170,"line_end":170,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":69},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7605589,"byte_end":7605592,"line_start":187,"line_end":187,"column_start":12,"column_end":15},"name":"new","qualname":"<Atomic<T>>::new","value":"fn (value: T) -> Atomic<T>","parent":null,"children":[],"decl_id":null,"docs":" Allocates `value` on the heap and returns a new atomic pointer pointing to it.\n\n # Examples\n\n ```\n use crossbeam_epoch::Atomic;\n\n let a = Atomic::new(1234);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":70},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7606216,"byte_end":7606220,"line_start":208,"line_end":208,"column_start":12,"column_end":16},"name":"load","qualname":"<Atomic<T>>::load","value":"fn <'g> (&self, ord: Ordering, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Loads a `Shared` from the atomic pointer.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n let p = a.load(SeqCst, guard);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":72},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7607227,"byte_end":7607239,"line_start":233,"line_end":233,"column_start":12,"column_end":24},"name":"load_consume","qualname":"<Atomic<T>>::load_consume","value":"fn <'g> (&self, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Loads a `Shared` from the atomic pointer using a \"consume\" memory ordering.\n\n This is similar to the \"acquire\" ordering, except that an ordering is\n only guaranteed with operations that \"depend on\" the result of the load.\n However consume loads are usually much faster than acquire loads on\n architectures with a weak memory model since they don't require memory\n fence instructions.\n\n The exact definition of \"depend on\" is a bit vague, but it works as you\n would expect in practice since a lot of software, especially the Linux\n kernel, rely on this behavior.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n let p = a.load_consume(guard);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":74},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7607953,"byte_end":7607958,"line_start":254,"line_end":254,"column_start":12,"column_end":17},"name":"store","qualname":"<Atomic<T>>::store","value":"fn <'g, P> (&self, new: P, ord: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a `Shared` or `Owned` pointer into the atomic pointer.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n a.store(Shared::null(), SeqCst);\n a.store(Owned::new(1234), SeqCst);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":77},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7608710,"byte_end":7608714,"line_start":276,"line_end":276,"column_start":12,"column_end":16},"name":"swap","qualname":"<Atomic<T>>::swap","value":"fn <'g, P> (&self, new: P, ord: Ordering, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Stores a `Shared` or `Owned` pointer into the atomic pointer, returning the previous\n `Shared`.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n let p = a.swap(Shared::null(), SeqCst, guard);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":80},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7610061,"byte_end":7610076,"line_start":306,"line_end":306,"column_start":12,"column_end":27},"name":"compare_and_set","qualname":"<Atomic<T>>::compare_and_set","value":"fn <'g, O, P> (&self, current: Shared<T>, new: P, ord: O, _: &'g Guard) -> Result<Shared<'g, T>, CompareAndSetError<'g, T, P>>","parent":null,"children":[],"decl_id":null,"docs":" Stores the pointer `new` (either `Shared` or `Owned`) into the atomic pointer if the current\n value is the same as `current`. The tag is also taken into account, so two pointers to the\n same object, but with different tags, will not be considered equal.\n\n The return value is a result indicating whether the new pointer was written. On success the\n pointer that was written is returned. On failure the actual current value and `new` are\n returned.\n\n This method takes a [`CompareAndSetOrdering`] argument which describes the memory\n ordering of this operation.\n\n [`CompareAndSetOrdering`]: trait.CompareAndSetOrdering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n\n let guard = &epoch::pin();\n let mut curr = a.load(SeqCst, guard);\n let res1 = a.compare_and_set(curr, Shared::null(), SeqCst, guard);\n let res2 = a.compare_and_set(curr, Owned::new(5678), SeqCst, guard);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":86},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7612627,"byte_end":7612647,"line_start":376,"line_end":376,"column_start":12,"column_end":32},"name":"compare_and_set_weak","qualname":"<Atomic<T>>::compare_and_set_weak","value":"fn <'g, O, P> (&self, current: Shared<T>, new: P, ord: O, _: &'g Guard) -> Result<Shared<'g, T>, CompareAndSetError<'g, T, P>>","parent":null,"children":[],"decl_id":null,"docs":" Stores the pointer `new` (either `Shared` or `Owned`) into the atomic pointer if the current\n value is the same as `current`. The tag is also taken into account, so two pointers to the\n same object, but with different tags, will not be considered equal.\n\n Unlike [`compare_and_set`], this method is allowed to spuriously fail even when comparison\n succeeds, which can result in more efficient code on some platforms.  The return value is a\n result indicating whether the new pointer was written. On success the pointer that was\n written is returned. On failure the actual current value and `new` are returned.\n\n This method takes a [`CompareAndSetOrdering`] argument which describes the memory\n ordering of this operation.\n\n [`compare_and_set`]: struct.Atomic.html#method.compare_and_set\n [`CompareAndSetOrdering`]: trait.CompareAndSetOrdering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n\n let mut new = Owned::new(5678);\n let mut ptr = a.load(SeqCst, guard);\n loop {\n     match a.compare_and_set_weak(ptr, new, SeqCst, guard) {\n         Ok(p) => {\n             ptr = p;\n             break;\n         }\n         Err(err) => {\n             ptr = err.current;\n             new = err.new;\n         }\n     }\n }\n\n let mut curr = a.load(SeqCst, guard);\n loop {\n     match a.compare_and_set_weak(curr, Shared::null(), SeqCst, guard) {\n         Ok(_) => break,\n         Err(err) => curr = err.current,\n     }\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":92},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7614139,"byte_end":7614148,"line_start":420,"line_end":420,"column_start":12,"column_end":21},"name":"fetch_and","qualname":"<Atomic<T>>::fetch_and","value":"fn <'g> (&self, val: usize, ord: Ordering, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Bitwise \"and\" with the current tag.\n\n Performs a bitwise \"and\" operation on the current tag and the argument `val`, and sets the\n new tag to the result. Returns the previous pointer.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::<i32>::from(Shared::null().with_tag(3));\n let guard = &epoch::pin();\n assert_eq!(a.fetch_and(2, SeqCst, guard).tag(), 3);\n assert_eq!(a.load(SeqCst, guard).tag(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":94},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7615138,"byte_end":7615146,"line_start":445,"line_end":445,"column_start":12,"column_end":20},"name":"fetch_or","qualname":"<Atomic<T>>::fetch_or","value":"fn <'g> (&self, val: usize, ord: Ordering, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Bitwise \"or\" with the current tag.\n\n Performs a bitwise \"or\" operation on the current tag and the argument `val`, and sets the\n new tag to the result. Returns the previous pointer.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::<i32>::from(Shared::null().with_tag(1));\n let guard = &epoch::pin();\n assert_eq!(a.fetch_or(2, SeqCst, guard).tag(), 1);\n assert_eq!(a.load(SeqCst, guard).tag(), 3);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":96},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7616137,"byte_end":7616146,"line_start":470,"line_end":470,"column_start":12,"column_end":21},"name":"fetch_xor","qualname":"<Atomic<T>>::fetch_xor","value":"fn <'g> (&self, val: usize, ord: Ordering, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Bitwise \"xor\" with the current tag.\n\n Performs a bitwise \"xor\" operation on the current tag and the argument `val`, and sets the\n new tag to the result. Returns the previous pointer.\n\n This method takes an [`Ordering`] argument which describes the memory ordering of this\n operation.\n\n [`Ordering`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Shared};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::<i32>::from(Shared::null().with_tag(1));\n let guard = &epoch::pin();\n assert_eq!(a.fetch_xor(3, SeqCst, guard).tag(), 1);\n assert_eq!(a.load(SeqCst, guard).tag(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":98},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7617443,"byte_end":7617453,"line_start":508,"line_end":508,"column_start":19,"column_end":29},"name":"into_owned","qualname":"<Atomic<T>>::into_owned","value":"fn (self) -> Owned<T>","parent":null,"children":[],"decl_id":null,"docs":" Takes ownership of the pointee.\n\n This consumes the atomic and converts it into [`Owned`]. As [`Atomic`] doesn't have a\n destructor and doesn't drop the pointee while [`Owned`] does, this is suitable for\n destructors of data structures.\n\n # Panics\n\n Panics if this pointer is null, but only in debug mode.\n\n # Safety\n\n This method may be called only if the pointer is valid and nobody else is holding a\n reference to the same object.\n\n # Examples\n\n ```rust\n # use std::mem;\n # use crossbeam_epoch::Atomic;\n struct DataStructure {\n     ptr: Atomic<usize>,\n }\n\n impl Drop for DataStructure {\n     fn drop(&mut self) {\n         // By now the DataStructure lives only in our thread and we are sure we don't hold\n         // any Shared or & to it ourselves.\n         unsafe {\n             drop(mem::replace(&mut self.ptr, Atomic::null()).into_owned());\n         }\n     }\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":127},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619923,"byte_end":7619930,"line_start":611,"line_end":611,"column_start":11,"column_end":18},"name":"Pointer","qualname":"::atomic::Pointer","value":"Pointer<T>","parent":null,"children":[{"krate":0,"index":129},{"krate":0,"index":130}],"decl_id":null,"docs":" A trait for either `Owned` or `Shared` pointers.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":129},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620002,"byte_end":7620012,"line_start":613,"line_end":613,"column_start":8,"column_end":18},"name":"into_usize","qualname":"::atomic::Pointer::into_usize","value":"fn (self) -> usize","parent":{"krate":0,"index":127},"children":[],"decl_id":null,"docs":" Returns the machine representation of the pointer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":130},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620113,"byte_end":7620123,"line_start":616,"line_end":616,"column_start":15,"column_end":25},"name":"from_usize","qualname":"::atomic::Pointer::from_usize","value":"fn (data: usize) -> Self","parent":{"krate":0,"index":127},"children":[],"decl_id":null,"docs":" Returns a new pointer pointing to the tagged pointer `data`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":131},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620389,"byte_end":7620394,"line_start":625,"line_end":625,"column_start":12,"column_end":17},"name":"Owned","qualname":"::atomic::Owned","value":"Owned {  }","parent":null,"children":[{"krate":0,"index":133},{"krate":0,"index":134}],"decl_id":null,"docs":" An owned heap-allocated object.\n\n This type is very similar to `Box<T>`.\n\n The pointer must be properly aligned. Since it is aligned, a tag can be stored into the unused\n least significant bits of the address.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":141},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7621240,"byte_end":7621243,"line_start":663,"line_end":663,"column_start":12,"column_end":15},"name":"new","qualname":"<Owned<T>>::new","value":"fn (value: T) -> Owned<T>","parent":null,"children":[],"decl_id":null,"docs":" Allocates `value` on the heap and returns a new owned pointer pointing to it.\n\n # Examples\n\n ```\n use crossbeam_epoch::Owned;\n\n let o = Owned::new(1234);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":142},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7621877,"byte_end":7621885,"line_start":684,"line_end":684,"column_start":19,"column_end":27},"name":"from_raw","qualname":"<Owned<T>>::from_raw","value":"fn (raw: *mut T) -> Owned<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a new owned pointer pointing to `raw`.\n\n This function is unsafe because improper use may lead to memory problems. Argument `raw`\n must be a valid pointer. Also, a double-free may occur if the function is called twice on\n the same raw pointer.\n\n # Panics\n\n Panics if `raw` is not properly aligned.\n\n # Examples\n\n ```\n use crossbeam_epoch::Owned;\n\n let o = unsafe { Owned::from_raw(Box::into_raw(Box::new(1234))) };\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":143},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7622327,"byte_end":7622338,"line_start":702,"line_end":702,"column_start":12,"column_end":23},"name":"into_shared","qualname":"<Owned<T>>::into_shared","value":"fn <'g> (self, _: &'g Guard) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Converts the owned pointer into a [`Shared`].\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Owned};\n\n let o = Owned::new(1234);\n let guard = &epoch::pin();\n let p = o.into_shared(guard);\n ```\n\n [`Shared`]: struct.Shared.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":145},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7622730,"byte_end":7622738,"line_start":717,"line_end":717,"column_start":12,"column_end":20},"name":"into_box","qualname":"<Owned<T>>::into_box","value":"fn (self) -> Box<T>","parent":null,"children":[],"decl_id":null,"docs":" Converts the owned pointer into a `Box`.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Owned};\n\n let o = Owned::new(1234);\n let b: Box<i32> = o.into_box();\n assert_eq!(*b, 1234);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":146},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623096,"byte_end":7623099,"line_start":732,"line_end":732,"column_start":12,"column_end":15},"name":"tag","qualname":"<Owned<T>>::tag","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the tag stored within the pointer.\n\n # Examples\n\n ```\n use crossbeam_epoch::Owned;\n\n assert_eq!(Owned::new(1234).tag(), 0);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":147},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623573,"byte_end":7623581,"line_start":750,"line_end":750,"column_start":12,"column_end":20},"name":"with_tag","qualname":"<Owned<T>>::with_tag","value":"fn (self, tag: usize) -> Owned<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the same pointer, but tagged with `tag`. `tag` is truncated to be fit into the\n unused bits of the pointer to `T`.\n\n # Examples\n\n ```\n use crossbeam_epoch::Owned;\n\n let o = Owned::new(0u64);\n assert_eq!(o.tag(), 0);\n let o = o.with_tag(2);\n assert_eq!(o.tag(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":182},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625861,"byte_end":7625867,"line_start":853,"line_end":853,"column_start":12,"column_end":18},"name":"Shared","qualname":"::atomic::Shared","value":"Shared {  }","parent":null,"children":[{"krate":0,"index":185},{"krate":0,"index":186}],"decl_id":null,"docs":" A pointer to an object protected by the epoch GC.\n\n The pointer is valid for use only during the lifetime `'g`.\n\n The pointer must be properly aligned. Since it is aligned, a tag can be stored into the unused\n least significant bits of the address.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":202},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626674,"byte_end":7626678,"line_start":895,"line_end":895,"column_start":12,"column_end":16},"name":"null","qualname":"<Shared>::null","value":"fn () -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a new null pointer.\n\n # Examples\n\n ```\n use crossbeam_epoch::Shared;\n\n let p = Shared::<i32>::null();\n assert!(p.is_null());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":203},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7627235,"byte_end":7627242,"line_start":916,"line_end":916,"column_start":12,"column_end":19},"name":"is_null","qualname":"<Shared>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the pointer is null.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::null();\n let guard = &epoch::pin();\n assert!(a.load(SeqCst, guard).is_null());\n a.store(Owned::new(1234), SeqCst);\n assert!(!a.load(SeqCst, guard).is_null());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":204},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7627773,"byte_end":7627779,"line_start":936,"line_end":936,"column_start":12,"column_end":18},"name":"as_raw","qualname":"<Shared>::as_raw","value":"fn (&self) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Converts the pointer to a raw pointer (without the tag).\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n let o = Owned::new(1234);\n let raw = &*o as *const _;\n let a = Atomic::from(o);\n\n let guard = &epoch::pin();\n let p = a.load(SeqCst, guard);\n assert_eq!(p.as_raw(), raw);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":205},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7629058,"byte_end":7629063,"line_start":972,"line_end":972,"column_start":19,"column_end":24},"name":"deref","qualname":"<Shared>::deref","value":"fn (&self) -> &'g T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the pointer.\n\n Returns a reference to the pointee that is valid during the lifetime `'g`.\n\n # Safety\n\n Dereferencing a pointer is unsafe because it could be pointing to invalid memory.\n\n Another concern is the possiblity of data races due to lack of proper synchronization.\n For example, consider the following scenario:\n\n 1. A thread creates a new object: `a.store(Owned::new(10), Relaxed)`\n 2. Another thread reads it: `*a.load(Relaxed, guard).as_ref().unwrap()`\n\n The problem is that relaxed orderings don't synchronize initialization of the object with\n the read from the second thread. This is a data race. A possible solution would be to use\n `Release` and `Acquire` orderings.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n let p = a.load(SeqCst, guard);\n unsafe {\n     assert_eq!(p.deref(), &1234);\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":206},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7630277,"byte_end":7630286,"line_start":1012,"line_end":1012,"column_start":19,"column_end":28},"name":"deref_mut","qualname":"<Shared>::deref_mut","value":"fn (&mut self) -> &'g mut T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the pointer.\n\n Returns a mutable reference to the pointee that is valid during the lifetime `'g`.\n\n # Safety\n\n * There is no guarantee that there are no more threads attempting to read/write from/to the\n   actual object at the same time.\n\n   The user must know that there are no concurrent accesses towards the object itself.\n\n * Other than the above, all safety concerns of `deref()` applies here.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(vec![1, 2, 3, 4]);\n let guard = &epoch::pin();\n\n let mut p = a.load(SeqCst, guard);\n unsafe {\n     assert!(!p.is_null());\n     let b = p.deref_mut();\n     assert_eq!(b, &vec![1, 2, 3, 4]);\n     b.push(5);\n     assert_eq!(b, &vec![1, 2, 3, 4, 5]);\n }\n\n let p = a.load(SeqCst, guard);\n unsafe {\n     assert_eq!(p.deref(), &vec![1, 2, 3, 4, 5]);\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":207},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7631578,"byte_end":7631584,"line_start":1047,"line_end":1047,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<Shared>::as_ref","value":"fn (&self) -> Option<&'g T>","parent":null,"children":[],"decl_id":null,"docs":" Converts the pointer to a reference.\n\n Returns `None` if the pointer is null, or else a reference to the object wrapped in `Some`.\n\n # Safety\n\n Dereferencing a pointer is unsafe because it could be pointing to invalid memory.\n\n Another concern is the possiblity of data races due to lack of proper synchronization.\n For example, consider the following scenario:\n\n 1. A thread creates a new object: `a.store(Owned::new(10), Relaxed)`\n 2. Another thread reads it: `*a.load(Relaxed, guard).as_ref().unwrap()`\n\n The problem is that relaxed orderings don't synchronize initialization of the object with\n the read from the second thread. This is a data race. A possible solution would be to use\n `Release` and `Acquire` orderings.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n let guard = &epoch::pin();\n let p = a.load(SeqCst, guard);\n unsafe {\n     assert_eq!(p.as_ref(), Some(&1234));\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":208},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7632323,"byte_end":7632333,"line_start":1075,"line_end":1075,"column_start":19,"column_end":29},"name":"into_owned","qualname":"<Shared>::into_owned","value":"fn (self) -> Owned<T>","parent":null,"children":[],"decl_id":null,"docs":" Takes ownership of the pointee.\n\n # Panics\n\n Panics if this pointer is null, but only in debug mode.\n\n # Safety\n\n This method may be called only if the pointer is valid and nobody else is holding a\n reference to the same object.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(1234);\n unsafe {\n     let guard = &epoch::unprotected();\n     let p = a.load(SeqCst, guard);\n     drop(p.into_owned());\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":209},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7632940,"byte_end":7632943,"line_start":1096,"line_end":1096,"column_start":12,"column_end":15},"name":"tag","qualname":"<Shared>::tag","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the tag stored within the pointer.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::<u64>::from(Owned::new(0u64).with_tag(2));\n let guard = &epoch::pin();\n let p = a.load(SeqCst, guard);\n assert_eq!(p.tag(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":210},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7633618,"byte_end":7633626,"line_start":1119,"line_end":1119,"column_start":12,"column_end":20},"name":"with_tag","qualname":"<Shared>::with_tag","value":"fn (&self, tag: usize) -> Shared<'g, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the same pointer, but tagged with `tag`. `tag` is truncated to be fit into the\n unused bits of the pointer to `T`.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(0u64);\n let guard = &epoch::pin();\n let p1 = a.load(SeqCst, guard);\n let p2 = p1.with_tag(2);\n\n assert_eq!(p1.tag(), 0);\n assert_eq!(p2.tag(), 2);\n assert_eq!(p1.as_raw(), p2.as_raw());\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":249},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7635954,"byte_end":7635963,"line_start":22,"line_end":22,"column_start":12,"column_end":21},"name":"Collector","qualname":"::collector::Collector","value":"Collector {  }","parent":null,"children":[{"krate":0,"index":250}],"decl_id":null,"docs":" An epoch-based garbage collector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":254},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636135,"byte_end":7636138,"line_start":31,"line_end":31,"column_start":12,"column_end":15},"name":"new","qualname":"<Collector>::new","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new collector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":255},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636294,"byte_end":7636302,"line_start":38,"line_end":38,"column_start":12,"column_end":20},"name":"register","qualname":"<Collector>::register","value":"fn (&self) -> LocalHandle","parent":null,"children":[],"decl_id":null,"docs":" Registers a new handle for the collector.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":263},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636966,"byte_end":7636977,"line_start":67,"line_end":67,"column_start":12,"column_end":23},"name":"LocalHandle","qualname":"::collector::LocalHandle","value":"LocalHandle {  }","parent":null,"children":[{"krate":0,"index":264}],"decl_id":null,"docs":" A handle to a garbage collector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":266},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637088,"byte_end":7637091,"line_start":74,"line_end":74,"column_start":12,"column_end":15},"name":"pin","qualname":"<LocalHandle>::pin","value":"fn (&self) -> Guard","parent":null,"children":[],"decl_id":null,"docs":" Pins the handle.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637067,"byte_end":7637076,"line_start":73,"line_end":73,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":267},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637229,"byte_end":7637238,"line_start":80,"line_end":80,"column_start":12,"column_end":21},"name":"is_pinned","qualname":"<LocalHandle>::is_pinned","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the handle is pinned.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637208,"byte_end":7637217,"line_start":79,"line_end":79,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":268},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637394,"byte_end":7637403,"line_start":86,"line_end":86,"column_start":12,"column_end":21},"name":"collector","qualname":"<LocalHandle>::collector","value":"fn (&self) -> &Collector","parent":null,"children":[],"decl_id":null,"docs":" Returns the `Collector` associated with this handle.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637373,"byte_end":7637382,"line_start":85,"line_end":85,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":319},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7656333,"byte_end":7656338,"line_start":68,"line_end":68,"column_start":12,"column_end":17},"name":"Guard","qualname":"::guard::Guard","value":"Guard {  }","parent":null,"children":[{"krate":0,"index":320}],"decl_id":null,"docs":" A guard that keeps the current thread pinned.\n\n # Pinning\n\n The current thread is pinned by calling [`pin`], which returns a new guard:\n\n ```\n use crossbeam_epoch as epoch;\n\n // It is often convenient to prefix a call to `pin` with a `&` in order to create a reference.\n // This is not really necessary, but makes passing references to the guard a bit easier.\n let guard = &epoch::pin();\n ```\n\n When a guard gets dropped, the current thread is automatically unpinned.\n\n # Pointers on the stack\n\n Having a guard allows us to create pointers on the stack to heap-allocated objects.\n For example:\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n // Create a heap-allocated number.\n let a = Atomic::new(777);\n\n // Pin the current thread.\n let guard = &epoch::pin();\n\n // Load the heap-allocated object and create pointer `p` on the stack.\n let p = a.load(SeqCst, guard);\n\n // Dereference the pointer and print the value:\n if let Some(num) = unsafe { p.as_ref() } {\n     println!(\"The number is {}.\", num);\n }\n ```\n\n # Multiple guards\n\n Pinning is reentrant and it is perfectly legal to create multiple guards. In that case, the\n thread will actually be pinned only when the first guard is created and unpinned when the last\n one is dropped:\n\n ```\n use crossbeam_epoch as epoch;\n\n let guard1 = epoch::pin();\n let guard2 = epoch::pin();\n assert!(epoch::is_pinned());\n drop(guard1);\n assert!(epoch::is_pinned());\n drop(guard2);\n assert!(!epoch::is_pinned());\n ```\n\n [`pin`]: fn.pin.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":322},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7657366,"byte_end":7657371,"line_start":90,"line_end":90,"column_start":12,"column_end":17},"name":"defer","qualname":"<Guard>::defer","value":"fn <F, R> (&self, f: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a function so that it can be executed at some point after all currently pinned\n threads get unpinned.\n\n This method first stores `f` into the thread-local (or handle-local) cache. If this cache\n becomes full, some functions are moved into the global cache. At the same time, some\n functions from both local and global caches may get executed in order to incrementally\n clean up the caches as they fill up.\n\n There is no guarantee when exactly `f` will be executed. The only guarantee is that it\n won't be executed until all currently pinned threads get unpinned. In theory, `f` might\n never run, but the epoch-based garbage collection will make an effort to execute it\n reasonably soon.\n\n If this method is called from an [`unprotected`] guard, the function will simply be\n executed immediately.\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":325},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7661724,"byte_end":7661739,"line_start":190,"line_end":190,"column_start":19,"column_end":34},"name":"defer_unchecked","qualname":"<Guard>::defer_unchecked","value":"fn <F, R> (&self, f: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a function so that it can be executed at some point after all currently pinned\n threads get unpinned.\n\n This method first stores `f` into the thread-local (or handle-local) cache. If this cache\n becomes full, some functions are moved into the global cache. At the same time, some\n functions from both local and global caches may get executed in order to incrementally\n clean up the caches as they fill up.\n\n There is no guarantee when exactly `f` will be executed. The only guarantee is that it\n won't be executed until all currently pinned threads get unpinned. In theory, `f` might\n never run, but the epoch-based garbage collection will make an effort to execute it\n reasonably soon.\n\n If this method is called from an [`unprotected`] guard, the function will simply be\n executed immediately.\n\n # Safety\n\n The given function must not hold reference onto the stack. It is highly recommended that\n the passed function is **always** marked with `move` in order to prevent accidental\n borrows.\n\n ```\n use crossbeam_epoch as epoch;\n\n let guard = &epoch::pin();\n let message = \"Hello!\";\n unsafe {\n     // ALWAYS use `move` when sending a closure into `defer_unchecked`.\n     guard.defer_unchecked(move || {\n         println!(\"{}\", message);\n     });\n }\n ```\n\n Apart from that, keep in mind that another thread may execute `f`, so anything accessed by\n the closure must be `Send`.\n\n We intentionally didn't require `F: Send`, because Rust's type systems usually cannot prove\n `F: Send` for typical use cases. For example, consider the following code snippet, which\n exemplifies the typical use case of deferring the deallocation of a shared reference:\n\n ```ignore\n let shared = Owned::new(7i32).into_shared(guard);\n guard.defer_unchecked(move || shared.into_owned()); // `Shared` is not `Send`!\n ```\n\n While `Shared` is not `Send`, it's safe for another thread to call the deferred function,\n because it's called only after the grace period and `shared` is no longer shared with other\n threads. But we don't expect type systems to prove this.\n\n # Examples\n\n When a heap-allocated object in a data structure becomes unreachable, it has to be\n deallocated. However, the current thread and other threads may be still holding references\n on the stack to that same object. Therefore it cannot be deallocated before those references\n get dropped. This method can defer deallocation until all those threads get unpinned and\n consequently drop all their references on the stack.\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(\"foo\");\n\n // Now suppose that `a` is shared among multiple threads and concurrently\n // accessed and modified...\n\n // Pin the current thread.\n let guard = &epoch::pin();\n\n // Steal the object currently stored in `a` and swap it with another one.\n let p = a.swap(Owned::new(\"bar\").into_shared(guard), SeqCst, guard);\n\n if !p.is_null() {\n     // The object `p` is pointing to is now unreachable.\n     // Defer its deallocation until all currently pinned threads get unpinned.\n     unsafe {\n         // ALWAYS use `move` when sending a closure into `defer_unchecked`.\n         guard.defer_unchecked(move || {\n             println!(\"{} is now being deallocated.\", p.deref());\n             // Now we have unique access to the object pointed to by `p` and can turn it\n             // into an `Owned`. Dropping the `Owned` will deallocate the object.\n             drop(p.into_owned());\n         });\n     }\n }\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":329},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7665379,"byte_end":7665392,"line_start":271,"line_end":271,"column_start":19,"column_end":32},"name":"defer_destroy","qualname":"<Guard>::defer_destroy","value":"fn <T> (&self, ptr: Shared<T>) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a destructor for an object so that it can be deallocated and dropped at some point\n after all currently pinned threads get unpinned.\n\n This method first stores the destructor into the thread-local (or handle-local) cache. If\n this cache becomes full, some destructors are moved into the global cache. At the same\n time, some destructors from both local and global caches may get executed in order to\n incrementally clean up the caches as they fill up.\n\n There is no guarantee when exactly the destructor will be executed. The only guarantee is\n that it won't be executed until all currently pinned threads get unpinned. In theory, the\n destructor might never run, but the epoch-based garbage collection will make an effort to\n execute it reasonably soon.\n\n If this method is called from an [`unprotected`] guard, the destructor will simply be\n executed immediately.\n\n # Safety\n\n The object must not be reachable by other threads anymore, otherwise it might be still in\n use when the destructor runs.\n\n Apart from that, keep in mind that another thread may execute the destructor, so the object\n must be sendable to other threads.\n\n We intentionally didn't require `T: Send`, because Rust's type systems usually cannot prove\n `T: Send` for typical use cases. For example, consider the following code snippet, which\n exemplifies the typical use case of deferring the deallocation of a shared reference:\n\n ```ignore\n let shared = Owned::new(7i32).into_shared(guard);\n guard.defer_destroy(shared); // `Shared` is not `Send`!\n ```\n\n While `Shared` is not `Send`, it's safe for another thread to call the destructor, because\n it's called only after the grace period and `shared` is no longer shared with other\n threads. But we don't expect type systems to prove this.\n\n # Examples\n\n When a heap-allocated object in a data structure becomes unreachable, it has to be\n deallocated. However, the current thread and other threads may be still holding references\n on the stack to that same object. Therefore it cannot be deallocated before those references\n get dropped. This method can defer deallocation until all those threads get unpinned and\n consequently drop all their references on the stack.\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic, Owned};\n use std::sync::atomic::Ordering::SeqCst;\n\n let a = Atomic::new(\"foo\");\n\n // Now suppose that `a` is shared among multiple threads and concurrently\n // accessed and modified...\n\n // Pin the current thread.\n let guard = &epoch::pin();\n\n // Steal the object currently stored in `a` and swap it with another one.\n let p = a.swap(Owned::new(\"bar\").into_shared(guard), SeqCst, guard);\n\n if !p.is_null() {\n     // The object `p` is pointing to is now unreachable.\n     // Defer its deallocation until all currently pinned threads get unpinned.\n     unsafe {\n         guard.defer_destroy(p);\n     }\n }\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":332},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7666365,"byte_end":7666370,"line_start":299,"line_end":299,"column_start":12,"column_end":17},"name":"flush","qualname":"<Guard>::flush","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Clears up the thread-local cache of deferred functions by executing them or moving into the\n global cache.\n\n Call this method after deferring execution of a function if you want to get it executed as\n soon as possible. Flushing will make sure it is residing in in the global cache, so that\n any thread has a chance of taking the function and executing it.\n\n If this method is called from an [`unprotected`] guard, it is a no-op (nothing happens).\n\n # Examples\n\n ```\n use crossbeam_epoch as epoch;\n\n let guard = &epoch::pin();\n unsafe {\n     guard.defer(move || {\n         println!(\"This better be printed as soon as possible!\");\n     });\n }\n guard.flush();\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":333},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7667643,"byte_end":7667648,"line_start":336,"line_end":336,"column_start":12,"column_end":17},"name":"repin","qualname":"<Guard>::repin","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Unpins and then immediately re-pins the thread.\n\n This method is useful when you don't want delay the advancement of the global epoch by\n holding an old epoch. For safety, you should not maintain any guard-based reference across\n the call (the latter is enforced by `&mut self`). The thread will only be repinned if this\n is the only active guard for the current thread.\n\n If this method is called from an [`unprotected`] guard, then the call will be just no-op.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n use std::thread;\n use std::time::Duration;\n\n let a = Atomic::new(777);\n let mut guard = epoch::pin();\n {\n     let p = a.load(SeqCst, &guard);\n     assert_eq!(unsafe { p.as_ref() }, Some(&777));\n }\n guard.repin();\n {\n     let p = a.load(SeqCst, &guard);\n     assert_eq!(unsafe { p.as_ref() }, Some(&777));\n }\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":334},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7669028,"byte_end":7669039,"line_start":374,"line_end":374,"column_start":12,"column_end":23},"name":"repin_after","qualname":"<Guard>::repin_after","value":"fn <F, R> (&mut self, f: F) -> R","parent":null,"children":[],"decl_id":null,"docs":" Temporarily unpins the thread, executes the given function and then re-pins the thread.\n\n This method is useful when you need to perform a long-running operation (e.g. sleeping)\n and don't need to maintain any guard-based reference across the call (the latter is enforced\n by `&mut self`). The thread will only be unpinned if this is the only active guard for the\n current thread.\n\n If this method is called from an [`unprotected`] guard, then the passed function is called\n directly without unpinning the thread.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::SeqCst;\n use std::thread;\n use std::time::Duration;\n\n let a = Atomic::new(777);\n let mut guard = epoch::pin();\n {\n     let p = a.load(SeqCst, &guard);\n     assert_eq!(unsafe { p.as_ref() }, Some(&777));\n }\n guard.repin_after(|| thread::sleep(Duration::from_millis(50)));\n {\n     let p = a.load(SeqCst, &guard);\n     assert_eq!(unsafe { p.as_ref() }, Some(&777));\n }\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":337},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7670246,"byte_end":7670255,"line_start":414,"line_end":414,"column_start":12,"column_end":21},"name":"collector","qualname":"<Guard>::collector","value":"fn (&self) -> Option<&Collector>","parent":null,"children":[],"decl_id":null,"docs":" Returns the `Collector` associated with this guard.\n\n This method is useful when you need to ensure that all guards used with\n a data structure come from the same collector.\n\n If this method is called from an [`unprotected`] guard, then `None` is returned.\n\n # Examples\n\n ```\n use crossbeam_epoch as epoch;\n\n let mut guard1 = epoch::pin();\n let mut guard2 = epoch::pin();\n assert!(guard1.collector() == guard2.collector());\n ```\n\n [`unprotected`]: fn.unprotected.html\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":343},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7673573,"byte_end":7673584,"line_start":520,"line_end":520,"column_start":15,"column_end":26},"name":"unprotected","qualname":"::guard::unprotected","value":"fn () -> &'static Guard","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to a dummy guard that allows unprotected access to [`Atomic`]s.\n\n This guard should be used in special occasions only. Note that it doesn't actually keep any\n thread pinned - it's just a fake guard that allows loading from [`Atomic`]s unsafely.\n\n Note that calling [`defer`] with a dummy guard will not defer the function - it will just\n execute the function immediately.\n\n If necessary, it's possible to create more dummy guards by cloning: `unprotected().clone()`.\n\n # Safety\n\n Loading and dereferencing data from an [`Atomic`] using this guard is safe only if the\n [`Atomic`] is not being concurrently modified by other threads.\n\n # Examples\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::sync::atomic::Ordering::Relaxed;\n\n let a = Atomic::new(7);\n\n unsafe {\n     // Load `a` without pinning the current thread.\n     a.load(Relaxed, epoch::unprotected());\n\n     // It's possible to create more dummy guards by calling `clone()`.\n     let dummy = &epoch::unprotected().clone();\n\n     dummy.defer(move || {\n         println!(\"This gets executed immediately.\");\n     });\n\n     // Dropping `dummy` doesn't affect the current thread - it's just a noop.\n }\n ```\n\n The most common use of this function is when constructing or destructing a data structure.\n\n For example, we can use a dummy guard in the destructor of a Treiber stack because at that\n point no other thread could concurrently modify the [`Atomic`]s we are accessing.\n\n If we were to actually pin the current thread during destruction, that would just unnecessarily\n delay garbage collection and incur some performance cost, so in cases like these `unprotected`\n is very helpful.\n\n ```\n use crossbeam_epoch::{self as epoch, Atomic};\n use std::mem::ManuallyDrop;\n use std::sync::atomic::Ordering::Relaxed;\n\n struct Stack<T> {\n     head: Atomic<Node<T>>,\n }\n\n struct Node<T> {\n     data: ManuallyDrop<T>,\n     next: Atomic<Node<T>>,\n }\n\n impl<T> Drop for Stack<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Unprotected load.\n             let mut node = self.head.load(Relaxed, epoch::unprotected());\n\n             while let Some(n) = node.as_ref() {\n                 // Unprotected load.\n                 let next = n.next.load(Relaxed, epoch::unprotected());\n\n                 // Take ownership of the node, then drop its data and deallocate it.\n                 let mut o = node.into_owned();\n                 ManuallyDrop::drop(&mut o.data);\n                 drop(o);\n\n                 node = next;\n             }\n         }\n     }\n }\n ```\n\n [`Atomic`]: struct.Atomic.html\n [`defer`]: struct.Guard.html#method.defer\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7673549,"byte_end":7673558,"line_start":519,"line_end":519,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":606},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\default.rs","byte_start":8630586,"byte_end":8630589,"line_start":22,"line_end":22,"column_start":8,"column_end":11},"name":"pin","qualname":"::default::pin","value":"fn () -> Guard","parent":null,"children":[],"decl_id":null,"docs":" Pins the current thread.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\default.rs","byte_start":8630569,"byte_end":8630578,"line_start":21,"line_end":21,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":608},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\default.rs","byte_start":8630714,"byte_end":8630723,"line_start":28,"line_end":28,"column_start":8,"column_end":17},"name":"is_pinned","qualname":"::default::is_pinned","value":"fn () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the current thread is pinned.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\default.rs","byte_start":8630697,"byte_end":8630706,"line_start":27,"line_end":27,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":610},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\default.rs","byte_start":8630833,"byte_end":8630850,"line_start":33,"line_end":33,"column_start":8,"column_end":25},"name":"default_collector","qualname":"::default::default_collector","value":"fn () -> &'static Collector","parent":null,"children":[],"decl_id":null,"docs":" Returns the default global collector.\n","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7601308,"byte_end":7601326,"line_start":35,"line_end":35,"column_start":60,"column_end":78},"value":"","parent":null,"children":[{"krate":0,"index":39}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7602500,"byte_end":7602508,"line_start":66,"line_end":66,"column_start":32,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":44},{"krate":0,"index":45}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604326,"byte_end":7604332,"line_start":132,"line_end":132,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604376,"byte_end":7604382,"line_start":133,"line_end":133,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604398,"byte_end":7604404,"line_start":135,"line_end":135,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":67},{"krate":0,"index":68},{"krate":0,"index":69},{"krate":0,"index":70},{"krate":0,"index":72},{"krate":0,"index":74},{"krate":0,"index":77},{"krate":0,"index":80},{"krate":0,"index":86},{"krate":0,"index":92},{"krate":0,"index":94},{"krate":0,"index":96},{"krate":0,"index":98}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7617556,"byte_end":7617562,"line_start":513,"line_end":513,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":101}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7617886,"byte_end":7617892,"line_start":525,"line_end":525,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":104}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618122,"byte_end":7618128,"line_start":533,"line_end":533,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":107}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618455,"byte_end":7618461,"line_start":544,"line_end":544,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":110}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618553,"byte_end":7618559,"line_start":550,"line_end":550,"column_start":28,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":113}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618954,"byte_end":7618960,"line_start":567,"line_end":567,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":116}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619063,"byte_end":7619069,"line_start":573,"line_end":573,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":119}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619169,"byte_end":7619175,"line_start":579,"line_end":579,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":123}],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619524,"byte_end":7619530,"line_start":594,"line_end":594,"column_start":28,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":126}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620477,"byte_end":7620482,"line_start":630,"line_end":630,"column_start":24,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":137},{"krate":0,"index":138}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620995,"byte_end":7621000,"line_start":653,"line_end":653,"column_start":9,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":141},{"krate":0,"index":142},{"krate":0,"index":143},{"krate":0,"index":145},{"krate":0,"index":146},{"krate":0,"index":147}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623745,"byte_end":7623750,"line_start":756,"line_end":756,"column_start":18,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":150}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623933,"byte_end":7623938,"line_start":765,"line_end":765,"column_start":24,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":153}],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624213,"byte_end":7624218,"line_start":776,"line_end":776,"column_start":26,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":156}],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624339,"byte_end":7624344,"line_start":782,"line_end":782,"column_start":19,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":159},{"krate":0,"index":160}],"docs":"","sig":null,"attributes":[]},{"id":20,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624510,"byte_end":7624515,"line_start":791,"line_end":791,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":163}],"docs":"","sig":null,"attributes":[]},{"id":21,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624674,"byte_end":7624679,"line_start":798,"line_end":798,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":166}],"docs":"","sig":null,"attributes":[]},{"id":22,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624769,"byte_end":7624774,"line_start":804,"line_end":804,"column_start":26,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":169}],"docs":"","sig":null,"attributes":[]},{"id":23,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625227,"byte_end":7625232,"line_start":823,"line_end":823,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":172}],"docs":"","sig":null,"attributes":[]},{"id":24,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625317,"byte_end":7625322,"line_start":829,"line_end":829,"column_start":26,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":175}],"docs":"","sig":null,"attributes":[]},{"id":25,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625419,"byte_end":7625424,"line_start":835,"line_end":835,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":178}],"docs":"","sig":null,"attributes":[]},{"id":26,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625505,"byte_end":7625510,"line_start":841,"line_end":841,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":181}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625969,"byte_end":7625975,"line_start":858,"line_end":858,"column_start":23,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":190}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626135,"byte_end":7626141,"line_start":867,"line_end":867,"column_start":22,"column_end":28},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626180,"byte_end":7626186,"line_start":869,"line_end":869,"column_start":28,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":197},{"krate":0,"index":198}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626438,"byte_end":7626444,"line_start":884,"line_end":884,"column_start":13,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":202},{"krate":0,"index":203},{"krate":0,"index":204},{"krate":0,"index":205},{"krate":0,"index":206},{"krate":0,"index":207},{"krate":0,"index":208},{"krate":0,"index":209},{"krate":0,"index":210}],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7633777,"byte_end":7633783,"line_start":1124,"line_end":1124,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":214}],"docs":"","sig":null,"attributes":[]},{"id":32,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634309,"byte_end":7634315,"line_start":1145,"line_end":1145,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":218}],"docs":"","sig":null,"attributes":[]},{"id":33,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634426,"byte_end":7634432,"line_start":1151,"line_end":1151,"column_start":20,"column_end":26},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634486,"byte_end":7634492,"line_start":1153,"line_end":1153,"column_start":43,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":225}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634641,"byte_end":7634647,"line_start":1159,"line_end":1159,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":229}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634779,"byte_end":7634785,"line_start":1165,"line_end":1165,"column_start":28,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":233}],"docs":"","sig":null,"attributes":[]},{"id":37,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7635069,"byte_end":7635075,"line_start":1176,"line_end":1176,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":237}],"docs":"","sig":null,"attributes":[]},{"id":38,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7635222,"byte_end":7635228,"line_start":1182,"line_end":1182,"column_start":25,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":241}],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636026,"byte_end":7636035,"line_start":26,"line_end":26,"column_start":22,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":40,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636060,"byte_end":7636069,"line_start":27,"line_end":27,"column_start":22,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":41,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636079,"byte_end":7636088,"line_start":29,"line_end":29,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":254},{"krate":0,"index":255}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636381,"byte_end":7636390,"line_start":43,"line_end":43,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":257}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636588,"byte_end":7636597,"line_start":52,"line_end":52,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":259}],"docs":"","sig":null,"attributes":[]},{"id":44,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636721,"byte_end":7636730,"line_start":58,"line_end":58,"column_start":20,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":261}],"docs":"","sig":null,"attributes":[]},{"id":45,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636904,"byte_end":7636913,"line_start":64,"line_end":64,"column_start":13,"column_end":22},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":46,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637024,"byte_end":7637035,"line_start":71,"line_end":71,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":266},{"krate":0,"index":267},{"krate":0,"index":268}],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637495,"byte_end":7637506,"line_start":91,"line_end":91,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":270}],"docs":"","sig":null,"attributes":[]},{"id":48,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637653,"byte_end":7637664,"line_start":100,"line_end":100,"column_start":21,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":272}],"docs":"","sig":null,"attributes":[]},{"id":49,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\deferred.rs","byte_start":7647568,"byte_end":7647576,"line_start":25,"line_end":25,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":287}],"docs":"","sig":null,"attributes":[]},{"id":50,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\deferred.rs","byte_start":7647696,"byte_end":7647704,"line_start":31,"line_end":31,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":289},{"krate":0,"index":295}],"docs":"","sig":null,"attributes":[]},{"id":51,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\epoch.rs","byte_start":7651675,"byte_end":7651680,"line_start":22,"line_end":22,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":301},{"krate":0,"index":302},{"krate":0,"index":303},{"krate":0,"index":304},{"krate":0,"index":305},{"krate":0,"index":306}],"docs":"","sig":null,"attributes":[]},{"id":52,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\epoch.rs","byte_start":7653435,"byte_end":7653446,"line_start":81,"line_end":81,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":308},{"krate":0,"index":309},{"krate":0,"index":310},{"krate":0,"index":311}],"docs":"","sig":null,"attributes":[]},{"id":53,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7656385,"byte_end":7656390,"line_start":72,"line_end":72,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":322},{"krate":0,"index":325},{"krate":0,"index":329},{"krate":0,"index":332},{"krate":0,"index":333},{"krate":0,"index":334},{"krate":0,"index":337}],"docs":"","sig":null,"attributes":[]},{"id":54,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7670380,"byte_end":7670385,"line_start":419,"line_end":419,"column_start":15,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":340}],"docs":"","sig":null,"attributes":[]},{"id":55,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7670555,"byte_end":7670560,"line_start":428,"line_end":428,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":342}],"docs":"","sig":null,"attributes":[]},{"id":56,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7677084,"byte_end":7677087,"line_start":69,"line_end":69,"column_start":22,"column_end":25},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":57,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7677097,"byte_end":7677100,"line_start":71,"line_end":71,"column_start":6,"column_end":9},"value":"","parent":null,"children":[{"krate":0,"index":385},{"krate":0,"index":386},{"krate":0,"index":387},{"krate":0,"index":388}],"docs":"","sig":null,"attributes":[]},{"id":58,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7678027,"byte_end":7678030,"line_start":106,"line_end":106,"column_start":18,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":390}],"docs":"","sig":null,"attributes":[]},{"id":59,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7680404,"byte_end":7680407,"line_start":133,"line_end":133,"column_start":15,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":392}],"docs":"","sig":null,"attributes":[]},{"id":60,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7680806,"byte_end":7680809,"line_start":145,"line_end":145,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":394}],"docs":"","sig":null,"attributes":[]},{"id":61,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681205,"byte_end":7681214,"line_start":161,"line_end":161,"column_start":22,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":62,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681224,"byte_end":7681233,"line_start":163,"line_end":163,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":398}],"docs":"","sig":null,"attributes":[]},{"id":63,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681908,"byte_end":7681914,"line_start":184,"line_end":184,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":404},{"krate":0,"index":405},{"krate":0,"index":406},{"krate":0,"index":407},{"krate":0,"index":409}],"docs":"","sig":null,"attributes":[]},{"id":64,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7686653,"byte_end":7686658,"line_start":314,"line_end":314,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":419},{"krate":0,"index":420},{"krate":0,"index":421},{"krate":0,"index":422},{"krate":0,"index":423},{"krate":0,"index":424},{"krate":0,"index":425},{"krate":0,"index":426},{"krate":0,"index":427},{"krate":0,"index":428},{"krate":0,"index":429},{"krate":0,"index":430},{"krate":0,"index":431}],"docs":"","sig":null,"attributes":[]},{"id":65,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7695181,"byte_end":7695186,"line_start":534,"line_end":534,"column_start":27,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":433},{"krate":0,"index":434},{"krate":0,"index":435}],"docs":"","sig":null,"attributes":[]},{"id":66,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701159,"byte_end":7701164,"line_start":131,"line_end":131,"column_start":18,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":463}],"docs":"","sig":null,"attributes":[]},{"id":67,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701300,"byte_end":7701305,"line_start":140,"line_end":140,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":465}],"docs":"","sig":null,"attributes":[]},{"id":68,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701811,"byte_end":7701815,"line_start":153,"line_end":153,"column_start":26,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":469},{"krate":0,"index":470},{"krate":0,"index":472}],"docs":"","sig":null,"attributes":[]},{"id":69,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7704367,"byte_end":7704371,"line_start":218,"line_end":218,"column_start":35,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":477}],"docs":"","sig":null,"attributes":[]},{"id":70,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7704904,"byte_end":7704908,"line_start":235,"line_end":235,"column_start":47,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":482},{"krate":0,"index":483}],"docs":"","sig":null,"attributes":[]},{"id":71,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714254,"byte_end":7714259,"line_start":39,"line_end":39,"column_start":31,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":72,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714296,"byte_end":7714301,"line_start":40,"line_end":40,"column_start":31,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":73,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714317,"byte_end":7714322,"line_start":42,"line_end":42,"column_start":9,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":506},{"krate":0,"index":507},{"krate":0,"index":508},{"krate":0,"index":509},{"krate":0,"index":512},{"krate":0,"index":516},{"krate":0,"index":517}],"docs":"","sig":null,"attributes":[]},{"id":74,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7719355,"byte_end":7719360,"line_start":182,"line_end":182,"column_start":18,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":521}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7601308,"byte_end":7601326,"line_start":35,"line_end":35,"column_start":60,"column_end":78},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":29},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7602500,"byte_end":7602508,"line_start":66,"line_end":66,"column_start":32,"column_end":40},"kind":{"Impl":{"id":1}},"from":{"krate":2,"index":28124},"to":{"krate":0,"index":40}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604326,"byte_end":7604332,"line_start":132,"line_end":132,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604376,"byte_end":7604382,"line_start":133,"line_end":133,"column_start":38,"column_end":44},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7604398,"byte_end":7604404,"line_start":135,"line_end":135,"column_start":9,"column_end":15},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":57},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7617556,"byte_end":7617562,"line_start":513,"line_end":513,"column_start":24,"column_end":30},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7617886,"byte_end":7617892,"line_start":525,"line_end":525,"column_start":26,"column_end":32},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":7658}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618122,"byte_end":7618128,"line_start":533,"line_end":533,"column_start":19,"column_end":25},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618455,"byte_end":7618461,"line_start":544,"line_end":544,"column_start":21,"column_end":27},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618553,"byte_end":7618559,"line_start":550,"line_end":550,"column_start":28,"column_end":34},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7618954,"byte_end":7618960,"line_start":567,"line_end":567,"column_start":26,"column_end":32},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619063,"byte_end":7619069,"line_start":573,"line_end":573,"column_start":21,"column_end":27},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619169,"byte_end":7619175,"line_start":579,"line_end":579,"column_start":37,"column_end":43},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7619524,"byte_end":7619530,"line_start":594,"line_end":594,"column_start":28,"column_end":34},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":57},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620477,"byte_end":7620482,"line_start":630,"line_end":630,"column_start":24,"column_end":29},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":131},"to":{"krate":0,"index":127}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7620995,"byte_end":7621000,"line_start":653,"line_end":653,"column_start":9,"column_end":14},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":131},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623745,"byte_end":7623750,"line_start":756,"line_end":756,"column_start":18,"column_end":23},"kind":{"Impl":{"id":16}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7623933,"byte_end":7623938,"line_start":765,"line_end":765,"column_start":24,"column_end":29},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624213,"byte_end":7624218,"line_start":776,"line_end":776,"column_start":26,"column_end":31},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624339,"byte_end":7624344,"line_start":782,"line_end":782,"column_start":19,"column_end":24},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624510,"byte_end":7624515,"line_start":791,"line_end":791,"column_start":22,"column_end":27},"kind":{"Impl":{"id":20}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":1715}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624674,"byte_end":7624679,"line_start":798,"line_end":798,"column_start":21,"column_end":26},"kind":{"Impl":{"id":21}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7624769,"byte_end":7624774,"line_start":804,"line_end":804,"column_start":26,"column_end":31},"kind":{"Impl":{"id":22}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625227,"byte_end":7625232,"line_start":823,"line_end":823,"column_start":23,"column_end":28},"kind":{"Impl":{"id":23}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2325}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625317,"byte_end":7625322,"line_start":829,"line_end":829,"column_start":26,"column_end":31},"kind":{"Impl":{"id":24}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2328}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625419,"byte_end":7625424,"line_start":835,"line_end":835,"column_start":22,"column_end":27},"kind":{"Impl":{"id":25}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2249}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625505,"byte_end":7625510,"line_start":841,"line_end":841,"column_start":22,"column_end":27},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":131},"to":{"krate":2,"index":2252}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7625969,"byte_end":7625975,"line_start":858,"line_end":858,"column_start":23,"column_end":29},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626135,"byte_end":7626141,"line_start":867,"line_end":867,"column_start":22,"column_end":28},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":1543}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626180,"byte_end":7626186,"line_start":869,"line_end":869,"column_start":28,"column_end":34},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":182},"to":{"krate":0,"index":127}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7626438,"byte_end":7626444,"line_start":884,"line_end":884,"column_start":13,"column_end":19},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":182},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7633777,"byte_end":7633783,"line_start":1124,"line_end":1124,"column_start":32,"column_end":38},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634309,"byte_end":7634315,"line_start":1145,"line_end":1145,"column_start":42,"column_end":48},"kind":{"Impl":{"id":32}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2040}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634426,"byte_end":7634432,"line_start":1151,"line_end":1151,"column_start":20,"column_end":26},"kind":{"Impl":{"id":33}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2045}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634486,"byte_end":7634492,"line_start":1153,"line_end":1153,"column_start":43,"column_end":49},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2077}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634641,"byte_end":7634647,"line_start":1159,"line_end":1159,"column_start":21,"column_end":27},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2066}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7634779,"byte_end":7634785,"line_start":1165,"line_end":1165,"column_start":28,"column_end":34},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7635069,"byte_end":7635075,"line_start":1176,"line_end":1176,"column_start":30,"column_end":36},"kind":{"Impl":{"id":37}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":7658}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\atomic.rs","byte_start":7635222,"byte_end":7635228,"line_start":1182,"line_end":1182,"column_start":25,"column_end":31},"kind":{"Impl":{"id":38}},"from":{"krate":0,"index":182},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636026,"byte_end":7636035,"line_start":26,"line_end":26,"column_start":22,"column_end":31},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636060,"byte_end":7636069,"line_start":27,"line_end":27,"column_start":22,"column_end":31},"kind":{"Impl":{"id":40}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636079,"byte_end":7636088,"line_start":29,"line_end":29,"column_start":6,"column_end":15},"kind":{"Impl":{"id":41}},"from":{"krate":0,"index":249},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636381,"byte_end":7636390,"line_start":43,"line_end":43,"column_start":16,"column_end":25},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636588,"byte_end":7636597,"line_start":52,"line_end":52,"column_start":21,"column_end":30},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636721,"byte_end":7636730,"line_start":58,"line_end":58,"column_start":20,"column_end":29},"kind":{"Impl":{"id":44}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":2040}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7636904,"byte_end":7636913,"line_start":64,"line_end":64,"column_start":13,"column_end":22},"kind":{"Impl":{"id":45}},"from":{"krate":0,"index":249},"to":{"krate":2,"index":2045}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637024,"byte_end":7637035,"line_start":71,"line_end":71,"column_start":6,"column_end":17},"kind":{"Impl":{"id":46}},"from":{"krate":0,"index":263},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637495,"byte_end":7637506,"line_start":91,"line_end":91,"column_start":15,"column_end":26},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":263},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\collector.rs","byte_start":7637653,"byte_end":7637664,"line_start":100,"line_end":100,"column_start":21,"column_end":32},"kind":{"Impl":{"id":48}},"from":{"krate":0,"index":263},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\deferred.rs","byte_start":7647568,"byte_end":7647576,"line_start":25,"line_end":25,"column_start":21,"column_end":29},"kind":{"Impl":{"id":49}},"from":{"krate":0,"index":282},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\deferred.rs","byte_start":7647696,"byte_end":7647704,"line_start":31,"line_end":31,"column_start":6,"column_end":14},"kind":{"Impl":{"id":50}},"from":{"krate":0,"index":282},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\epoch.rs","byte_start":7651675,"byte_end":7651680,"line_start":22,"line_end":22,"column_start":6,"column_end":11},"kind":{"Impl":{"id":51}},"from":{"krate":0,"index":535},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\epoch.rs","byte_start":7653435,"byte_end":7653446,"line_start":81,"line_end":81,"column_start":6,"column_end":17},"kind":{"Impl":{"id":52}},"from":{"krate":0,"index":551},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7656385,"byte_end":7656390,"line_start":72,"line_end":72,"column_start":6,"column_end":11},"kind":{"Impl":{"id":53}},"from":{"krate":0,"index":319},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7670380,"byte_end":7670385,"line_start":419,"line_end":419,"column_start":15,"column_end":20},"kind":{"Impl":{"id":54}},"from":{"krate":0,"index":319},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\guard.rs","byte_start":7670555,"byte_end":7670560,"line_start":428,"line_end":428,"column_start":21,"column_end":26},"kind":{"Impl":{"id":55}},"from":{"krate":0,"index":319},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7677084,"byte_end":7677087,"line_start":69,"line_end":69,"column_start":22,"column_end":25},"kind":{"Impl":{"id":56}},"from":{"krate":0,"index":379},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7677097,"byte_end":7677100,"line_start":71,"line_end":71,"column_start":6,"column_end":9},"kind":{"Impl":{"id":57}},"from":{"krate":0,"index":379},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7678027,"byte_end":7678030,"line_start":106,"line_end":106,"column_start":18,"column_end":21},"kind":{"Impl":{"id":58}},"from":{"krate":0,"index":379},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7680404,"byte_end":7680407,"line_start":133,"line_end":133,"column_start":15,"column_end":18},"kind":{"Impl":{"id":59}},"from":{"krate":0,"index":379},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7680806,"byte_end":7680809,"line_start":145,"line_end":145,"column_start":21,"column_end":24},"kind":{"Impl":{"id":60}},"from":{"krate":0,"index":379},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681205,"byte_end":7681214,"line_start":161,"line_end":161,"column_start":22,"column_end":31},"kind":{"Impl":{"id":61}},"from":{"krate":0,"index":558},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681224,"byte_end":7681233,"line_start":163,"line_end":163,"column_start":6,"column_end":15},"kind":{"Impl":{"id":62}},"from":{"krate":0,"index":558},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7681908,"byte_end":7681914,"line_start":184,"line_end":184,"column_start":6,"column_end":12},"kind":{"Impl":{"id":63}},"from":{"krate":0,"index":399},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7686653,"byte_end":7686658,"line_start":314,"line_end":314,"column_start":6,"column_end":11},"kind":{"Impl":{"id":64}},"from":{"krate":0,"index":410},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\internal.rs","byte_start":7695181,"byte_end":7695186,"line_start":534,"line_end":534,"column_start":27,"column_end":32},"kind":{"Impl":{"id":65}},"from":{"krate":0,"index":410},"to":{"krate":0,"index":448}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701159,"byte_end":7701164,"line_start":131,"line_end":131,"column_start":18,"column_end":23},"kind":{"Impl":{"id":66}},"from":{"krate":0,"index":565},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701300,"byte_end":7701305,"line_start":140,"line_end":140,"column_start":6,"column_end":11},"kind":{"Impl":{"id":67}},"from":{"krate":0,"index":565},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7701811,"byte_end":7701815,"line_start":153,"line_end":153,"column_start":26,"column_end":30},"kind":{"Impl":{"id":68}},"from":{"krate":0,"index":569},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7704367,"byte_end":7704371,"line_start":218,"line_end":218,"column_start":35,"column_end":39},"kind":{"Impl":{"id":69}},"from":{"krate":0,"index":569},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\list.rs","byte_start":7704904,"byte_end":7704908,"line_start":235,"line_end":235,"column_start":47,"column_end":51},"kind":{"Impl":{"id":70}},"from":{"krate":0,"index":453},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714254,"byte_end":7714259,"line_start":39,"line_end":39,"column_start":31,"column_end":36},"kind":{"Impl":{"id":71}},"from":{"krate":0,"index":586},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714296,"byte_end":7714301,"line_start":40,"line_end":40,"column_start":31,"column_end":36},"kind":{"Impl":{"id":72}},"from":{"krate":0,"index":586},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7714317,"byte_end":7714322,"line_start":42,"line_end":42,"column_start":9,"column_end":14},"kind":{"Impl":{"id":73}},"from":{"krate":0,"index":586},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-epoch-0.8.0\\src\\sync\\queue.rs","byte_start":7719355,"byte_end":7719360,"line_start":182,"line_end":182,"column_start":18,"column_end":23},"kind":{"Impl":{"id":74}},"from":{"krate":0,"index":586},"to":{"krate":2,"index":1726}}]}