{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","crossbeam_utils","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"lazy_static\"","--cfg","feature=\"std\"","-C","metadata=7691cda68fa03b20","-C","extra-filename=-7691cda68fa03b20","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--extern","cfg_if=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libcfg_if-ea23fff8dcc69735.rmeta","--extern","lazy_static=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\liblazy_static-79de1231268f023b.rmeta","--cap-lints","allow","--cfg","has_min_const_fn","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libcrossbeam_utils-7691cda68fa03b20.rmeta"},"prelude":{"crate_id":{"name":"crossbeam_utils","disambiguator":[7709528671052336800,4286142518779901766]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":1,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":2,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":14,"id":{"name":"cfg_if","disambiguator":[2442249708866091360,16714075183114805585]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","num":15,"id":{"name":"lazy_static","disambiguator":[17281579441627161632,7326486140096487162]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":0,"byte_end":1823,"line_start":1,"line_end":64,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":19},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\mod.rs","byte_start":2601,"byte_end":2611,"line_start":24,"line_end":24,"column_start":28,"column_end":38},"alias_span":null,"name":"AtomicCell","value":"","parent":{"krate":0,"index":5}},{"kind":"Use","ref_id":{"krate":0,"index":90},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\mod.rs","byte_start":2636,"byte_end":2649,"line_start":25,"line_end":25,"column_start":24,"column_end":37},"alias_span":null,"name":"AtomicConsume","value":"","parent":{"krate":0,"index":5}},{"kind":"Use","ref_id":{"krate":0,"index":250},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1617,"byte_end":1628,"line_start":51,"line_end":51,"column_start":23,"column_end":34},"alias_span":null,"name":"CachePadded","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":133},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1661,"byte_end":1668,"line_start":54,"line_end":54,"column_start":18,"column_end":25},"alias_span":null,"name":"Backoff","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":349},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515099,"byte_end":8515110,"line_start":15,"line_end":15,"column_start":30,"column_end":41},"alias_span":null,"name":"ShardedLock","value":"","parent":{"krate":0,"index":277}},{"kind":"Use","ref_id":{"krate":0,"index":387},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515112,"byte_end":8515132,"line_start":15,"line_end":15,"column_start":43,"column_end":63},"alias_span":null,"name":"ShardedLockReadGuard","value":"","parent":{"krate":0,"index":277}},{"kind":"Use","ref_id":{"krate":0,"index":409},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515134,"byte_end":8515155,"line_start":15,"line_end":15,"column_start":65,"column_end":86},"alias_span":null,"name":"ShardedLockWriteGuard","value":"","parent":{"krate":0,"index":277}},{"kind":"Use","ref_id":{"krate":0,"index":288},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515181,"byte_end":8515187,"line_start":16,"line_end":16,"column_start":24,"column_end":30},"alias_span":null,"name":"Parker","value":"","parent":{"krate":0,"index":277}},{"kind":"Use","ref_id":{"krate":0,"index":299},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515189,"byte_end":8515197,"line_start":16,"line_end":16,"column_start":32,"column_end":40},"alias_span":null,"name":"Unparker","value":"","parent":{"krate":0,"index":277}},{"kind":"Use","ref_id":{"krate":0,"index":455},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":8515226,"byte_end":8515235,"line_start":17,"line_end":17,"column_start":27,"column_end":36},"alias_span":null,"name":"WaitGroup","value":"","parent":{"krate":0,"index":277}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":0,"byte_end":1823,"line_start":1,"line_end":64,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":147},{"krate":0,"index":5},{"krate":0,"index":100},{"krate":0,"index":126},{"krate":0,"index":127},{"krate":0,"index":146},{"krate":0,"index":276},{"krate":0,"index":277},{"krate":0,"index":477}],"decl_id":null,"docs":" Miscellaneous tools for concurrent programming.\n\n ## Atomics\n\n * [`AtomicCell`], a thread-safe mutable memory location.\n * [`AtomicConsume`], for reading from primitive atomic types with \"consume\" ordering.\n\n ## Thread synchronization\n\n * [`Parker`], a thread parking primitive.\n * [`ShardedLock`], a sharded reader-writer lock with fast concurrent reads.\n * [`WaitGroup`], for synchronizing the beginning or end of some computation.\n\n ## Utilities\n\n * [`Backoff`], for exponential backoff in spin loops.\n * [`CachePadded`], for padding and aligning a value to the length of a cache line.\n * [`scope`], for spawning threads that borrow local variables from the stack.\n\n [`AtomicCell`]: atomic/struct.AtomicCell.html\n [`AtomicConsume`]: atomic/trait.AtomicConsume.html\n [`Parker`]: sync/struct.Parker.html\n [`ShardedLock`]: sync/struct.ShardedLock.html\n [`WaitGroup`]: sync/struct.WaitGroup.html\n [`Backoff`]: struct.Backoff.html\n [`CachePadded`]: struct.CachePadded.html\n [`scope`]: thread/fn.scope.html\n","sig":null,"attributes":[{"value":"warn(missing_docs)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1087,"byte_end":1109,"line_start":29,"line_end":29,"column_start":1,"column_end":23}},{"value":"warn(missing_debug_implementations)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1110,"byte_end":1149,"line_start":30,"line_end":30,"column_start":1,"column_end":40}}]},{"kind":"Mod","id":{"krate":0,"index":5},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"atomic","qualname":"::atomic","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\mod.rs","parent":null,"children":[{"krate":0,"index":148},{"krate":0,"index":6},{"krate":0,"index":88},{"krate":0,"index":98},{"krate":0,"index":99}],"decl_id":null,"docs":" Atomic types.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":19},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":3736,"byte_end":3746,"line_start":27,"line_end":27,"column_start":12,"column_end":22},"name":"AtomicCell","qualname":"::atomic::atomic_cell::AtomicCell","value":"AtomicCell {  }","parent":null,"children":[{"krate":0,"index":21}],"decl_id":null,"docs":" A thread-safe mutable memory location.\n\n This type is equivalent to [`Cell`], except it can also be shared among multiple threads.\n\n Operations on `AtomicCell`s use atomic instructions whenever possible, and synchronize using\n global locks otherwise. You can call [`AtomicCell::<T>::is_lock_free()`] to check whether\n atomic instructions or locks will be used.\n\n Atomic loads use the [`Acquire`] ordering and atomic stores use the [`Release`] ordering.\n\n [`Cell`]: https://doc.rust-lang.org/std/cell/struct.Cell.html\n [`AtomicCell::<T>::is_lock_free()`]: struct.AtomicCell.html#method.is_lock_free\n [`Acquire`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.Acquire\n [`Release`]: https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.Release\n","sig":null,"attributes":[{"value":"repr(transparent)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":3704,"byte_end":3724,"line_start":26,"line_end":26,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":32},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4906,"byte_end":4909,"line_start":71,"line_end":71,"column_start":18,"column_end":21},"name":"new","qualname":"<AtomicCell<T>>::new","value":"fn (val: T) -> AtomicCell<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new atomic cell initialized with `val`.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(7);\n ```\n","sig":null,"attributes":[{"value":"cfg(has_min_const_fn)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4864,"byte_end":4888,"line_start":70,"line_end":70,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":33},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":5310,"byte_end":5320,"line_start":89,"line_end":89,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<AtomicCell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps the atomic cell and returns its inner value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let mut a = AtomicCell::new(7);\n let v = a.into_inner();\n\n assert_eq!(v, 7);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":34},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":6595,"byte_end":6607,"line_start":121,"line_end":121,"column_start":12,"column_end":24},"name":"is_lock_free","qualname":"<AtomicCell<T>>::is_lock_free","value":"fn () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if operations on values of this type are lock-free.\n\n If the compiler or the platform doesn't support the necessary atomic instructions,\n `AtomicCell<T>` will use global locks for every potentially concurrent atomic operation.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n // This type is internally represented as `AtomicUsize` so we can just use atomic\n // operations provided by it.\n assert_eq!(AtomicCell::<usize>::is_lock_free(), true);\n\n // A wrapper struct around `isize`.\n struct Foo {\n     bar: isize,\n }\n // `AtomicCell<Foo>` will be internally represented as `AtomicIsize`.\n assert_eq!(AtomicCell::<Foo>::is_lock_free(), true);\n\n // Operations on zero-sized types are always lock-free.\n assert_eq!(AtomicCell::<()>::is_lock_free(), true);\n\n // Very large types cannot be represented as any of the standard atomic types, so atomic\n // operations on them will have to use global locks for synchronization.\n assert_eq!(AtomicCell::<[u8; 1000]>::is_lock_free(), false);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":35},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":6962,"byte_end":6967,"line_start":138,"line_end":138,"column_start":12,"column_end":17},"name":"store","qualname":"<AtomicCell<T>>::store","value":"fn (&self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores `val` into the atomic cell.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(7);\n\n assert_eq!(a.load(), 7);\n a.store(8);\n assert_eq!(a.load(), 8);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":36},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":7522,"byte_end":7526,"line_start":161,"line_end":161,"column_start":12,"column_end":16},"name":"swap","qualname":"<AtomicCell<T>>::swap","value":"fn (&self, val: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores `val` into the atomic cell and returns the previous value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(7);\n\n assert_eq!(a.load(), 7);\n assert_eq!(a.swap(8), 7);\n assert_eq!(a.load(), 8);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":39},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":7937,"byte_end":7943,"line_start":179,"line_end":179,"column_start":12,"column_end":18},"name":"as_ptr","qualname":"<AtomicCell<T>>::as_ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the underlying data in this atomic cell.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let mut a = AtomicCell::new(5);\n\n let ptr = a.as_ptr();\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":7916,"byte_end":7925,"line_start":178,"line_end":178,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":40},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8396,"byte_end":8403,"line_start":197,"line_end":197,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<AtomicCell<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the inner value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let mut a = AtomicCell::new(7);\n *a.get_mut() += 1;\n\n assert_eq!(a.load(), 8);\n ```\n","sig":null,"attributes":[{"value":"deprecated(note =\n             \"this method is unsound and will be removed in the next release\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8298,"byte_end":8384,"line_start":196,"line_end":196,"column_start":5,"column_end":91}}]},{"kind":"Method","id":{"krate":0,"index":43},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8866,"byte_end":8870,"line_start":216,"line_end":216,"column_start":12,"column_end":16},"name":"take","qualname":"<AtomicCell<T>>::take","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Takes the value of the atomic cell, leaving `Default::default()` in its place.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(5);\n let five = a.take();\n\n assert_eq!(five, 5);\n assert_eq!(a.into_inner(), 0);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":46},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":9189,"byte_end":9193,"line_start":233,"line_end":233,"column_start":12,"column_end":16},"name":"load","qualname":"<AtomicCell<T>>::load","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads a value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(7);\n\n assert_eq!(a.load(), 7);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":49},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":9854,"byte_end":9870,"line_start":257,"line_end":257,"column_start":12,"column_end":28},"name":"compare_and_swap","qualname":"<AtomicCell<T>>::compare_and_swap","value":"fn (&self, current: T, new: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" If the current value equals `current`, stores `new` into the atomic cell.\n\n The return value is always the previous value. If it is equal to `current`, then the value\n was updated.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(1);\n\n assert_eq!(a.compare_and_swap(2, 3), 1);\n assert_eq!(a.load(), 1);\n\n assert_eq!(a.compare_and_swap(1, 2), 1);\n assert_eq!(a.load(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":50},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":10652,"byte_end":10668,"line_start":282,"line_end":282,"column_start":12,"column_end":28},"name":"compare_exchange","qualname":"<AtomicCell<T>>::compare_exchange","value":"fn (&self, current: T, new: T) -> Result<T, T>","parent":null,"children":[],"decl_id":null,"docs":" If the current value equals `current`, stores `new` into the atomic cell.\n\n The return value is a result indicating whether the new value was written and containing\n the previous value. On success this value is guaranteed to be equal to `current`.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(1);\n\n assert_eq!(a.compare_exchange(2, 3), Err(1));\n assert_eq!(a.load(), 1);\n\n assert_eq!(a.compare_exchange(1, 2), Ok(1));\n assert_eq!(a.load(), 2);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":53},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":21694,"byte_end":21703,"line_start":582,"line_end":582,"column_start":12,"column_end":21},"name":"fetch_and","qualname":"<AtomicCell<bool>>::fetch_and","value":"fn (&self, val: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Applies logical \"and\" to the current value and returns the previous value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(true);\n\n assert_eq!(a.fetch_and(true), true);\n assert_eq!(a.load(), true);\n\n assert_eq!(a.fetch_and(false), true);\n assert_eq!(a.load(), false);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":21673,"byte_end":21682,"line_start":581,"line_end":581,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":54},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":22295,"byte_end":22303,"line_start":603,"line_end":603,"column_start":12,"column_end":20},"name":"fetch_or","qualname":"<AtomicCell<bool>>::fetch_or","value":"fn (&self, val: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Applies logical \"or\" to the current value and returns the previous value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(false);\n\n assert_eq!(a.fetch_or(false), false);\n assert_eq!(a.load(), false);\n\n assert_eq!(a.fetch_or(true), false);\n assert_eq!(a.load(), true);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":22274,"byte_end":22283,"line_start":602,"line_end":602,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":55},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":22894,"byte_end":22903,"line_start":624,"line_end":624,"column_start":12,"column_end":21},"name":"fetch_xor","qualname":"<AtomicCell<bool>>::fetch_xor","value":"fn (&self, val: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Applies logical \"xor\" to the current value and returns the previous value.\n\n # Examples\n\n ```\n use crossbeam_utils::atomic::AtomicCell;\n\n let a = AtomicCell::new(true);\n\n assert_eq!(a.fetch_xor(false), true);\n assert_eq!(a.load(), true);\n\n assert_eq!(a.fetch_xor(true), true);\n assert_eq!(a.load(), false);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":22873,"byte_end":22882,"line_start":623,"line_end":623,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":90},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\consume.rs","byte_start":32879,"byte_end":32892,"line_start":6,"line_end":6,"column_start":11,"column_end":24},"name":"AtomicConsume","qualname":"::atomic::consume::AtomicConsume","value":"AtomicConsume","parent":null,"children":[{"krate":0,"index":91},{"krate":0,"index":92}],"decl_id":null,"docs":" Trait which allows reading from primitive atomic types with \"consume\" ordering.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":91},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\consume.rs","byte_start":32945,"byte_end":32948,"line_start":8,"line_end":8,"column_start":10,"column_end":13},"name":"Val","qualname":"::atomic::consume::AtomicConsume::Val","value":"type Val;","parent":{"krate":0,"index":90},"children":[],"decl_id":null,"docs":" Type returned by `load_consume`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":92},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\consume.rs","byte_start":33786,"byte_end":33798,"line_start":25,"line_end":25,"column_start":8,"column_end":20},"name":"load_consume","qualname":"::atomic::consume::AtomicConsume::load_consume","value":"fn (&self) -> Self::Val","parent":{"krate":0,"index":90},"children":[],"decl_id":null,"docs":" Loads a value from the atomic using a \"consume\" memory ordering.\n\n This is similar to the \"acquire\" ordering, except that an ordering is\n only guaranteed with operations that \"depend on\" the result of the load.\n However consume loads are usually much faster than acquire loads on\n architectures with a weak memory model since they don't require memory\n fence instructions.\n\n The exact definition of \"depend on\" is a bit vague, but it works as you\n would expect in practice since a lot of software, especially the Linux\n kernel, rely on this behavior.\n\n This is currently only implemented on ARM and AArch64, where a fence\n can be avoided. On other architectures this will fall back to a simple\n `load(Ordering::Acquire)`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":250},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38132,"byte_end":38143,"line_start":68,"line_end":68,"column_start":12,"column_end":23},"name":"CachePadded","qualname":"::cache_padded::CachePadded","value":"CachePadded {  }","parent":null,"children":[{"krate":0,"index":252}],"decl_id":null,"docs":" Pads and aligns a value to the length of a cache line.\n\n In concurrent programming, sometimes it is desirable to make sure commonly accessed pieces of\n data are not placed into the same cache line. Updating an atomic value invalides the whole\n cache line it belongs to, which makes the next access to the same cache line slower for other\n CPU cores. Use `CachePadded` to ensure updating one piece of data doesn't invalidate other\n cached data.\n\n # Size and alignment\n\n Cache lines are assumed to be N bytes long, depending on the architecture:\n\n * On x86-64, N = 128.\n * On all others, N = 64.\n\n Note that N is just a reasonable guess and is not guaranteed to match the actual cache line\n length of the machine the program is running on. On modern Intel architectures, spatial\n prefetcher is pulling pairs of 64-byte cache lines at a time, so we pessimistically assume that\n cache lines are 128 bytes long.\n\n The size of `CachePadded<T>` is the smallest multiple of N bytes large enough to accommodate\n a value of type `T`.\n\n The alignment of `CachePadded<T>` is the maximum of N bytes and the alignment of `T`.\n\n # Examples\n\n Alignment and padding:\n\n ```\n use crossbeam_utils::CachePadded;\n\n let array = [CachePadded::new(1i8), CachePadded::new(2i8)];\n let addr1 = &*array[0] as *const i8 as usize;\n let addr2 = &*array[1] as *const i8 as usize;\n\n assert!(addr2 - addr1 >= 64);\n assert_eq!(addr1 % 64, 0);\n assert_eq!(addr2 % 64, 0);\n ```\n\n When building a concurrent queue with a head and a tail index, it is wise to place them in\n different cache lines so that concurrent threads pushing and popping elements don't invalidate\n each other's cache lines:\n\n ```\n use crossbeam_utils::CachePadded;\n use std::sync::atomic::AtomicUsize;\n\n struct Queue<T> {\n     head: CachePadded<AtomicUsize>,\n     tail: CachePadded<AtomicUsize>,\n     buffer: *mut T,\n }\n ```\n","sig":null,"attributes":[{"value":"repr(align (128))","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38044,"byte_end":38060,"line_start":66,"line_end":66,"column_start":36,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":111},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38519,"byte_end":38522,"line_start":85,"line_end":85,"column_start":12,"column_end":15},"name":"new","qualname":"<CachePadded<T>>::new","value":"fn (t: T) -> CachePadded<T>","parent":null,"children":[],"decl_id":null,"docs":" Pads and aligns a value to the length of a cache line.\n\n # Examples\n\n ```\n use crossbeam_utils::CachePadded;\n\n let padded_value = CachePadded::new(1);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":112},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38872,"byte_end":38882,"line_start":100,"line_end":100,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<CachePadded<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the inner value.\n\n # Examples\n\n ```\n use crossbeam_utils::CachePadded;\n\n let padded_value = CachePadded::new(7);\n let value = padded_value.into_inner();\n assert_eq!(value, 7);\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":133},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":41953,"byte_end":41960,"line_start":80,"line_end":80,"column_start":12,"column_end":19},"name":"Backoff","qualname":"::backoff::Backoff","value":"Backoff {  }","parent":null,"children":[{"krate":0,"index":134}],"decl_id":null,"docs":" Performs exponential backoff in spin loops.\n\n Backing off in spin loops reduces contention and improves overall performance.\n\n This primitive can execute *YIELD* and *PAUSE* instructions, yield the current thread to the OS\n scheduler, and tell when is a good time to block the thread using a different synchronization\n mechanism. Each step of the back off procedure takes roughly twice as long as the previous\n step.\n\n # Examples\n\n Backing off in a lock-free loop:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n\n fn fetch_mul(a: &AtomicUsize, b: usize) -> usize {\n     let backoff = Backoff::new();\n     loop {\n         let val = a.load(SeqCst);\n         if a.compare_and_swap(val, val.wrapping_mul(b), SeqCst) == val {\n             return val;\n         }\n         backoff.spin();\n     }\n }\n ```\n\n Waiting for an [`AtomicBool`] to become `true`:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::SeqCst;\n\n fn spin_wait(ready: &AtomicBool) {\n     let backoff = Backoff::new();\n     while !ready.load(SeqCst) {\n         backoff.snooze();\n     }\n }\n ```\n\n Waiting for an [`AtomicBool`] to become `true` and parking the thread after a long wait.\n Note that whoever sets the atomic variable to `true` must notify the parked thread by calling\n [`unpark()`]:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::SeqCst;\n use std::thread;\n\n fn blocking_wait(ready: &AtomicBool) {\n     let backoff = Backoff::new();\n     while !ready.load(SeqCst) {\n         if backoff.is_completed() {\n             thread::park();\n         } else {\n             backoff.snooze();\n         }\n     }\n }\n ```\n\n [`is_completed`]: struct.Backoff.html#method.is_completed\n [`std::thread::park()`]: https://doc.rust-lang.org/std/thread/fn.park.html\n [`Condvar`]: https://doc.rust-lang.org/std/sync/struct.Condvar.html\n [`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html\n [`unpark()`]: https://doc.rust-lang.org/std/thread/struct.Thread.html#method.unpark\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":136},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":42203,"byte_end":42206,"line_start":95,"line_end":95,"column_start":12,"column_end":15},"name":"new","qualname":"<Backoff>::new","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Backoff`.\n\n # Examples\n\n ```\n use crossbeam_utils::Backoff;\n\n let backoff = Backoff::new();\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":42182,"byte_end":42191,"line_start":94,"line_end":94,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":137},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":42488,"byte_end":42493,"line_start":110,"line_end":110,"column_start":12,"column_end":17},"name":"reset","qualname":"<Backoff>::reset","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Resets the `Backoff`.\n\n # Examples\n\n ```\n use crossbeam_utils::Backoff;\n\n let backoff = Backoff::new();\n backoff.reset();\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":42467,"byte_end":42476,"line_start":109,"line_end":109,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":138},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":43528,"byte_end":43532,"line_start":146,"line_end":146,"column_start":12,"column_end":16},"name":"spin","qualname":"<Backoff>::spin","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Backs off in a lock-free loop.\n\n This method should be used when we need to retry an operation because another thread made\n progress.\n\n The processor may yield using the *YIELD* or *PAUSE* instruction.\n\n # Examples\n\n Backing off in a lock-free loop:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n\n fn fetch_mul(a: &AtomicUsize, b: usize) -> usize {\n     let backoff = Backoff::new();\n     loop {\n         let val = a.load(SeqCst);\n         if a.compare_and_swap(val, val.wrapping_mul(b), SeqCst) == val {\n             return val;\n         }\n         backoff.spin();\n     }\n }\n\n let a = AtomicUsize::new(7);\n assert_eq!(fetch_mul(&a, 8), 7);\n assert_eq!(a.load(SeqCst), 56);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":43507,"byte_end":43516,"line_start":145,"line_end":145,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":139},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":45488,"byte_end":45494,"line_start":205,"line_end":205,"column_start":12,"column_end":18},"name":"snooze","qualname":"<Backoff>::snooze","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Backs off in a blocking loop.\n\n This method should be used when we need to wait for another thread to make progress.\n\n The processor may yield using the *YIELD* or *PAUSE* instruction and the current thread\n may yield by giving up a timeslice to the OS scheduler.\n\n In `#[no_std]` environments, this method is equivalent to [`spin`].\n\n If possible, use [`is_completed`] to check when it is advised to stop using backoff and\n block the current thread using a different synchronization mechanism instead.\n\n [`spin`]: struct.Backoff.html#method.spin\n [`is_completed`]: struct.Backoff.html#method.is_completed\n\n # Examples\n\n Waiting for an [`AtomicBool`] to become `true`:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::Arc;\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::SeqCst;\n use std::thread;\n use std::time::Duration;\n\n fn spin_wait(ready: &AtomicBool) {\n     let backoff = Backoff::new();\n     while !ready.load(SeqCst) {\n         backoff.snooze();\n     }\n }\n\n let ready = Arc::new(AtomicBool::new(false));\n let ready2 = ready.clone();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(100));\n     ready2.store(true, SeqCst);\n });\n\n assert_eq!(ready.load(SeqCst), false);\n spin_wait(&ready);\n assert_eq!(ready.load(SeqCst), true);\n ```\n\n [`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":45467,"byte_end":45476,"line_start":204,"line_end":204,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":140},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47374,"byte_end":47386,"line_start":267,"line_end":267,"column_start":12,"column_end":24},"name":"is_completed","qualname":"<Backoff>::is_completed","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if exponential backoff has completed and blocking the thread is advised.\n\n # Examples\n\n Waiting for an [`AtomicBool`] to become `true` and parking the thread after a long wait:\n\n ```\n use crossbeam_utils::Backoff;\n use std::sync::Arc;\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::SeqCst;\n use std::thread;\n use std::time::Duration;\n\n fn blocking_wait(ready: &AtomicBool) {\n     let backoff = Backoff::new();\n     while !ready.load(SeqCst) {\n         if backoff.is_completed() {\n             thread::park();\n         } else {\n             backoff.snooze();\n         }\n     }\n }\n\n let ready = Arc::new(AtomicBool::new(false));\n let ready2 = ready.clone();\n let waiter = thread::current();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(100));\n     ready2.store(true, SeqCst);\n     waiter.unpark();\n });\n\n assert_eq!(ready.load(SeqCst), false);\n blocking_wait(&ready);\n assert_eq!(ready.load(SeqCst), true);\n ```\n\n [`AtomicBool`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47353,"byte_end":47362,"line_start":266,"line_end":266,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":141},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47548,"byte_end":47559,"line_start":274,"line_end":274,"column_start":12,"column_end":23},"name":"is_complete","qualname":"<Backoff>::is_complete","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47453,"byte_end":47462,"line_start":271,"line_end":271,"column_start":5,"column_end":14}},{"value":"deprecated(note = \"use `is_completed` instead\")","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47486,"byte_end":47536,"line_start":273,"line_end":273,"column_start":5,"column_end":55}}]},{"kind":"Mod","id":{"krate":0,"index":277},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"sync","qualname":"::sync","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\mod.rs","parent":null,"children":[{"krate":0,"index":278},{"krate":0,"index":319},{"krate":0,"index":449},{"krate":0,"index":469},{"krate":0,"index":473},{"krate":0,"index":476}],"decl_id":null,"docs":" Thread synchronization primitives.\n\n * [`Parker`], a thread parking primitive.\n * [`ShardedLock`], a sharded reader-writer lock with fast concurrent reads.\n * [`WaitGroup`], for synchronizing the beginning or end of some computation.\n\n [`Parker`]: struct.Parker.html\n [`ShardedLock`]: struct.ShardedLock.html\n [`WaitGroup`]: struct.WaitGroup.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":288},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8516993,"byte_end":8516999,"line_start":54,"line_end":54,"column_start":12,"column_end":18},"name":"Parker","qualname":"::sync::parker::Parker","value":"Parker {  }","parent":null,"children":[{"krate":0,"index":289},{"krate":0,"index":290}],"decl_id":null,"docs":" A thread parking primitive.\n\n Conceptually, each `Parker` has an associated token which is initially not present:\n\n * The [`park`] method blocks the current thread unless or until the token is available, at\n   which point it automatically consumes the token. It may also return *spuriously*, without\n   consuming the token.\n\n * The [`park_timeout`] method works the same as [`park`], but blocks for a specified maximum\n   time.\n\n * The [`unpark`] method atomically makes the token available if it wasn't already. Because the\n   token is initially absent, [`unpark`] followed by [`park`] will result in the second call\n   returning immediately.\n\n In other words, each `Parker` acts a bit like a spinlock that can be locked and unlocked using\n [`park`] and [`unpark`].\n\n # Examples\n\n ```\n use std::thread;\n use std::time::Duration;\n use crossbeam_utils::sync::Parker;\n\n let mut p = Parker::new();\n let u = p.unparker().clone();\n\n // Make the token available.\n u.unpark();\n // Wakes up immediately and consumes the token.\n p.park();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(500));\n     u.unpark();\n });\n\n // Wakes up when `u.unpark()` provides the token, but may also wake up\n // spuriously before that without consuming the token.\n p.park();\n ```\n\n [`park`]: struct.Parker.html#method.park\n [`park_timeout`]: struct.Parker.html#method.park_timeout\n [`unpark`]: struct.Unparker.html#method.unpark\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":293},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8517304,"byte_end":8517307,"line_start":72,"line_end":72,"column_start":12,"column_end":15},"name":"new","qualname":"<Parker>::new","value":"fn () -> Parker","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Parker`.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::Parker;\n\n let p = Parker::new();\n ```\n\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":294},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8518190,"byte_end":8518194,"line_start":104,"line_end":104,"column_start":12,"column_end":16},"name":"park","qualname":"<Parker>::park","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Blocks the current thread until the token is made available.\n\n A call to `park` may wake up spuriously without consuming the token, and callers should be\n prepared for this possibility.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::Parker;\n\n let mut p = Parker::new();\n let u = p.unparker().clone();\n\n // Make the token available.\n u.unpark();\n\n // Wakes up immediately and consumes the token.\n p.park();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":295},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8518842,"byte_end":8518854,"line_start":124,"line_end":124,"column_start":12,"column_end":24},"name":"park_timeout","qualname":"<Parker>::park_timeout","value":"fn (&self, timeout: Duration) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Blocks the current thread until the token is made available, but only for a limited time.\n\n A call to `park_timeout` may wake up spuriously without consuming the token, and callers\n should be prepared for this possibility.\n\n # Examples\n\n ```\n use std::time::Duration;\n use crossbeam_utils::sync::Parker;\n\n let mut p = Parker::new();\n\n // Waits for the token to become available, but will not wait longer than 500 ms.\n p.park_timeout(Duration::from_millis(500));\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":296},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519608,"byte_end":8519616,"line_start":150,"line_end":150,"column_start":12,"column_end":20},"name":"unparker","qualname":"<Parker>::unparker","value":"fn (&self) -> &Unparker","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to an associated [`Unparker`].\n\n The returned [`Unparker`] doesn't have to be used by reference - it can also be cloned.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::Parker;\n\n let mut p = Parker::new();\n let u = p.unparker().clone();\n\n // Make the token available.\n u.unpark();\n // Wakes up immediately and consumes the token.\n p.park();\n ```\n\n [`park`]: struct.Parker.html#method.park\n [`park_timeout`]: struct.Parker.html#method.park_timeout\n\n [`Unparker`]: struct.Unparker.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":299},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519907,"byte_end":8519915,"line_start":164,"line_end":164,"column_start":12,"column_end":20},"name":"Unparker","qualname":"::sync::parker::Unparker","value":"Unparker {  }","parent":null,"children":[{"krate":0,"index":300}],"decl_id":null,"docs":" Unparks a thread parked by the associated [`Parker`].\n\n [`Parker`]: struct.Parker.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":304},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8520885,"byte_end":8520891,"line_start":199,"line_end":199,"column_start":12,"column_end":18},"name":"unpark","qualname":"<Unparker>::unpark","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Atomically makes the token available if it is not already.\n\n This method will wake up the thread blocked on [`park`] or [`park_timeout`], if there is\n any.\n\n # Examples\n\n ```\n use std::thread;\n use std::time::Duration;\n use crossbeam_utils::sync::Parker;\n\n let mut p = Parker::new();\n let u = p.unparker().clone();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(500));\n     u.unpark();\n });\n\n // Wakes up when `u.unpark()` provides the token, but may also wake up\n // spuriously before that without consuming the token.\n p.park();\n ```\n\n [`park`]: struct.Parker.html#method.park\n [`park_timeout`]: struct.Parker.html#method.park_timeout\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":349},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528168,"byte_end":8528179,"line_start":75,"line_end":75,"column_start":12,"column_end":23},"name":"ShardedLock","qualname":"::sync::sharded_lock::ShardedLock","value":"ShardedLock {  }","parent":null,"children":[{"krate":0,"index":351},{"krate":0,"index":352}],"decl_id":null,"docs":" A sharded reader-writer lock.\n\n This lock is equivalent to [`RwLock`], except read operations are faster and write operations\n are slower.\n\n A `ShardedLock` is internally made of a list of *shards*, each being a [`RwLock`] occupying a\n single cache line. Read operations will pick one of the shards depending on the current thread\n and lock it. Write operations need to lock all shards in succession.\n\n By splitting the lock into shards, concurrent read operations will in most cases choose\n different shards and thus update different cache lines, which is good for scalability. However,\n write operations need to do more work and are therefore slower than usual.\n\n The priority policy of the lock is dependent on the underlying operating system's\n implementation, and this type does not guarantee that any particular policy will be used.\n\n # Poisoning\n\n A `ShardedLock`, like [`RwLock`], will become poisoned on a panic. Note that it may only be\n poisoned if a panic occurs while a write operation is in progress. If a panic occurs in any\n read operation, the lock will not be poisoned.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(5);\n\n // Any number of read locks can be held at once.\n {\n     let r1 = lock.read().unwrap();\n     let r2 = lock.read().unwrap();\n     assert_eq!(*r1, 5);\n     assert_eq!(*r2, 5);\n } // Read locks are dropped at this point.\n\n // However, only one write lock may be held.\n {\n     let mut w = lock.write().unwrap();\n     *w += 1;\n     assert_eq!(*w, 6);\n } // Write lock is dropped here.\n ```\n\n [`RwLock`]: https://doc.rust-lang.org/std/sync/struct.RwLock.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":363},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528808,"byte_end":8528811,"line_start":99,"line_end":99,"column_start":12,"column_end":15},"name":"new","qualname":"<ShardedLock<T>>::new","value":"fn (value: T) -> ShardedLock<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new sharded reader-writer lock.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(5);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":365},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8529741,"byte_end":8529751,"line_start":129,"line_end":129,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<ShardedLock<T>>::into_inner","value":"fn (self) -> LockResult<T>","parent":null,"children":[],"decl_id":null,"docs":" Consumes this lock, returning the underlying data.\n\n This method will return an error if the lock is poisoned. A lock gets poisoned when a write\n operation panics.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(String::new());\n {\n     let mut s = lock.write().unwrap();\n     *s = \"modified\".to_owned();\n }\n assert_eq!(lock.into_inner().unwrap(), \"modified\");\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":368},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8530728,"byte_end":8530739,"line_start":163,"line_end":163,"column_start":12,"column_end":23},"name":"is_poisoned","qualname":"<ShardedLock<T>>::is_poisoned","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the lock is poisoned.\n\n If another thread can still access the lock, it may become poisoned at any time. A `false`\n result should not be trusted without additional synchronization.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n use std::sync::Arc;\n use std::thread;\n\n let lock = Arc::new(ShardedLock::new(0));\n let c_lock = lock.clone();\n\n let _ = thread::spawn(move || {\n     let _lock = c_lock.write().unwrap();\n     panic!(); // the lock gets poisoned\n }).join();\n assert_eq!(lock.is_poisoned(), true);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":369},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8531353,"byte_end":8531360,"line_start":183,"line_end":183,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<ShardedLock<T>>::get_mut","value":"fn (&mut self) -> LockResult<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying data.\n\n Since this call borrows the lock mutably, no actual locking needs to take place.\n\n This method will return an error if the lock is poisoned. A lock gets poisoned when a write\n operation panics.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let mut lock = ShardedLock::new(0);\n *lock.get_mut().unwrap() = 10;\n assert_eq!(*lock.read().unwrap(), 10);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":370},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8532455,"byte_end":8532463,"line_start":216,"line_end":216,"column_start":12,"column_end":20},"name":"try_read","qualname":"<ShardedLock<T>>::try_read","value":"fn (&self) -> TryLockResult<ShardedLockReadGuard<T>>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to acquire this lock with shared read access.\n\n If the access could not be granted at this time, an error is returned. Otherwise, a guard\n is returned which will release the shared access when it is dropped. This method does not\n provide any guarantees with respect to the ordering of whether contentious readers or\n writers will acquire the lock first.\n\n This method will return an error if the lock is poisoned. A lock gets poisoned when a write\n operation panics.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(1);\n\n match lock.try_read() {\n     Ok(n) => assert_eq!(*n, 1),\n     Err(_) => unreachable!(),\n };\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":371},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8534474,"byte_end":8534478,"line_start":267,"line_end":267,"column_start":12,"column_end":16},"name":"read","qualname":"<ShardedLock<T>>::read","value":"fn (&self) -> LockResult<ShardedLockReadGuard<T>>","parent":null,"children":[],"decl_id":null,"docs":" Locks with shared read access, blocking the current thread until it can be acquired.\n\n The calling thread will be blocked until there are no more writers which hold the lock.\n There may be other readers currently inside the lock when this method returns. This method\n does not provide any guarantees with respect to the ordering of whether contentious readers\n or writers will acquire the lock first.\n\n Returns a guard which will release the shared access when dropped.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n use std::sync::Arc;\n use std::thread;\n\n let lock = Arc::new(ShardedLock::new(1));\n let c_lock = lock.clone();\n\n let n = lock.read().unwrap();\n assert_eq!(*n, 1);\n\n thread::spawn(move || {\n     let r = c_lock.read();\n     assert!(r.is_ok());\n }).join().unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":372},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8536114,"byte_end":8536123,"line_start":309,"line_end":309,"column_start":12,"column_end":21},"name":"try_write","qualname":"<ShardedLock<T>>::try_write","value":"fn (&self) -> TryLockResult<ShardedLockWriteGuard<T>>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to acquire this lock with exclusive write access.\n\n If the access could not be granted at this time, an error is returned. Otherwise, a guard\n is returned which will release the exclusive access when it is dropped. This method does\n not provide any guarantees with respect to the ordering of whether contentious readers or\n writers will acquire the lock first.\n\n This method will return an error if the lock is poisoned. A lock gets poisoned when a write\n operation panics.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(1);\n\n let n = lock.read().unwrap();\n assert_eq!(*n, 1);\n\n assert!(lock.try_write().is_err());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":373},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8538621,"byte_end":8538626,"line_start":380,"line_end":380,"column_start":12,"column_end":17},"name":"write","qualname":"<ShardedLock<T>>::write","value":"fn (&self) -> LockResult<ShardedLockWriteGuard<T>>","parent":null,"children":[],"decl_id":null,"docs":" Locks with exclusive write access, blocking the current thread until it can be acquired.\n\n The calling thread will be blocked until there are no more writers which hold the lock.\n There may be other readers currently inside the lock when this method returns. This method\n does not provide any guarantees with respect to the ordering of whether contentious readers\n or writers will acquire the lock first.\n\n Returns a guard which will release the exclusive access when dropped.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::ShardedLock;\n\n let lock = ShardedLock::new(1);\n\n let mut n = lock.write().unwrap();\n *n = 2;\n\n assert!(lock.try_read().is_err());\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":387},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540885,"byte_end":8540905,"line_start":451,"line_end":451,"column_start":12,"column_end":32},"name":"ShardedLockReadGuard","qualname":"::sync::sharded_lock::ShardedLockReadGuard","value":"ShardedLockReadGuard {  }","parent":null,"children":[{"krate":0,"index":390},{"krate":0,"index":391},{"krate":0,"index":392}],"decl_id":null,"docs":" A guard used to release the shared read access of a [`ShardedLock`] when dropped.\n\n [`ShardedLock`]: struct.ShardedLock.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":409},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541854,"byte_end":8541875,"line_start":484,"line_end":484,"column_start":12,"column_end":33},"name":"ShardedLockWriteGuard","qualname":"::sync::sharded_lock::ShardedLockWriteGuard","value":"ShardedLockWriteGuard {  }","parent":null,"children":[{"krate":0,"index":412},{"krate":0,"index":413}],"decl_id":null,"docs":" A guard used to release the exclusive write access of a [`ShardedLock`] when dropped.\n\n [`ShardedLock`]: struct.ShardedLock.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":455},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8546418,"byte_end":8546427,"line_start":45,"line_end":45,"column_start":12,"column_end":21},"name":"WaitGroup","qualname":"::sync::wait_group::WaitGroup","value":"WaitGroup {  }","parent":null,"children":[{"krate":0,"index":456}],"decl_id":null,"docs":" Enables threads to synchronize the beginning or end of some computation.\n\n # Wait groups vs barriers\n\n `WaitGroup` is very similar to [`Barrier`], but there are a few differences:\n\n * `Barrier` needs to know the number of threads at construction, while `WaitGroup` is cloned to\n   register more threads.\n\n * A `Barrier` can be reused even after all threads have synchronized, while a `WaitGroup`\n   synchronizes threads only once.\n\n * All threads wait for others to reach the `Barrier`. With `WaitGroup`, each thread can choose\n   to either wait for other threads or to continue without blocking.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::WaitGroup;\n use std::thread;\n\n // Create a new wait group.\n let wg = WaitGroup::new();\n\n for _ in 0..4 {\n     // Create another reference to the wait group.\n     let wg = wg.clone();\n\n     thread::spawn(move || {\n         // Do some work.\n\n         // Drop the reference to the wait group.\n         drop(wg);\n     });\n }\n\n // Block until all threads have finished their work.\n wg.wait();\n ```\n\n [`Barrier`]: https://doc.rust-lang.org/std/sync/struct.Barrier.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":461},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8546801,"byte_end":8546804,"line_start":65,"line_end":65,"column_start":12,"column_end":15},"name":"new","qualname":"<WaitGroup>::new","value":"fn () -> WaitGroup","parent":null,"children":[],"decl_id":null,"docs":" Creates a new wait group and returns the single reference to it.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::WaitGroup;\n\n let wg = WaitGroup::new();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":462},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8547543,"byte_end":8547547,"line_start":95,"line_end":95,"column_start":12,"column_end":16},"name":"wait","qualname":"<WaitGroup>::wait","value":"fn (self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Drops this reference and waits until all other references are dropped.\n\n # Examples\n\n ```\n use crossbeam_utils::sync::WaitGroup;\n use std::thread;\n\n let wg = WaitGroup::new();\n\n thread::spawn({\n     let wg = wg.clone();\n     move || {\n         // Block until both threads have reached `wait()`.\n         wg.wait();\n     }\n });\n\n // Block until both threads have reached `wait()`.\n wg.wait();\n ```\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":477},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"thread","qualname":"::thread","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","parent":null,"children":[{"krate":0,"index":478},{"krate":0,"index":479},{"krate":0,"index":480},{"krate":0,"index":481},{"krate":0,"index":482},{"krate":0,"index":483},{"krate":0,"index":486},{"krate":0,"index":487},{"krate":0,"index":488},{"krate":0,"index":490},{"krate":0,"index":492},{"krate":0,"index":499},{"krate":0,"index":504},{"krate":0,"index":506},{"krate":0,"index":514},{"krate":0,"index":566},{"krate":0,"index":571},{"krate":0,"index":517},{"krate":0,"index":528},{"krate":0,"index":531},{"krate":0,"index":534},{"krate":0,"index":541},{"krate":0,"index":547}],"decl_id":null,"docs":" Threads that can borrow variables from the stack.\n\n Create a scope when spawned threads need to access variables on the stack:\n\n ```\n use crossbeam_utils::thread;\n\n let people = vec![\n     \"Alice\".to_string(),\n     \"Bob\".to_string(),\n     \"Carol\".to_string(),\n ];\n\n thread::scope(|s| {\n     for person in &people {\n         s.spawn(move |_| {\n             println!(\"Hello, {}!\", person);\n         });\n     }\n }).unwrap();\n ```\n\n # Why scoped threads?\n\n Suppose we wanted to re-write the previous example using plain threads:\n\n ```ignore\n use std::thread;\n\n let people = vec![\n     \"Alice\".to_string(),\n     \"Bob\".to_string(),\n     \"Carol\".to_string(),\n ];\n\n let mut threads = Vec::new();\n\n for person in &people {\n     threads.push(thread::spawn(move |_| {\n         println!(\"Hello, {}!\", person);\n     }));\n }\n\n for thread in threads {\n     thread.join().unwrap();\n }\n ```\n\n This doesn't work because the borrow checker complains about `people` not living long enough:\n\n ```text\n error[E0597]: `people` does not live long enough\n   --> src/main.rs:12:20\n    |\n 12 |     for person in &people {\n    |                    ^^^^^^ borrowed value does not live long enough\n ...\n 21 | }\n    | - borrowed value only lives until here\n    |\n    = note: borrowed value must be valid for the static lifetime...\n ```\n\n The problem here is that spawned threads are not allowed to borrow variables on stack because\n the compiler cannot prove they will be joined before `people` is destroyed.\n\n Scoped threads are a mechanism to guarantee to the compiler that spawned threads will be joined\n before the scope ends.\n\n # How scoped threads work\n\n If a variable is borrowed by a thread, the thread must complete before the variable is\n destroyed. Threads spawned using [`std::thread::spawn`] can only borrow variables with the\n `'static` lifetime because the borrow checker cannot be sure when the thread will complete.\n\n A scope creates a clear boundary between variables outside the scope and threads inside the\n scope. Whenever a scope spawns a thread, it promises to join the thread before the scope ends.\n This way we guarantee to the borrow checker that scoped threads only live within the scope and\n can safely access variables outside it.\n\n # Nesting scoped threads\n\n Sometimes scoped threads need to spawn more threads within the same scope. This is a little\n tricky because argument `s` lives *inside* the invocation of `thread::scope()` and as such\n cannot be borrowed by scoped threads:\n\n ```ignore\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     s.spawn(|_| {\n         // Not going to compile because we're trying to borrow `s`,\n         // which lives *inside* the scope! :(\n         s.spawn(|_| println!(\"nested thread\"));\n     });\n });\n ```\n\n Fortunately, there is a solution. Every scoped thread is passed a reference to its scope as an\n argument, which can be used for spawning nested threads:\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     // Note the `|s|` here.\n     s.spawn(|s| {\n         // Yay, this works because we're using a fresh argument `s`! :)\n         s.spawn(|_| println!(\"nested thread\"));\n     });\n });\n ```\n\n [`std::thread::spawn`]: https://doc.rust-lang.org/std/thread/fn.spawn.html\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":492},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8553011,"byte_end":8553016,"line_start":149,"line_end":149,"column_start":8,"column_end":13},"name":"scope","qualname":"::thread::scope","value":"fn <'env, F, R> (f: F) -> thread::Result<R>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new scope for spawning threads.\n\n All child threads that haven't been manually joined will be automatically joined just before\n this function invocation ends. If all joined threads have successfully completed, `Ok` is\n returned with the return value of `f`. If any of the joined threads has panicked, an `Err` is\n returned containing errors from panicked threads.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n let var = vec![1, 2, 3];\n\n thread::scope(|s| {\n     s.spawn(|_| {\n         println!(\"A child thread borrowing `var`: {:?}\", var);\n     });\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":499},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8554397,"byte_end":8554402,"line_start":197,"line_end":197,"column_start":12,"column_end":17},"name":"Scope","qualname":"::thread::Scope","value":"Scope {  }","parent":null,"children":[{"krate":0,"index":501},{"krate":0,"index":502},{"krate":0,"index":503}],"decl_id":null,"docs":" A scope for spawning threads.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":508},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8555828,"byte_end":8555833,"line_start":240,"line_end":240,"column_start":12,"column_end":17},"name":"spawn","qualname":"<Scope>::spawn","value":"fn <'scope, F, T> (&'scope self, f: F) -> ScopedJoinHandle<'scope, T>","parent":null,"children":[],"decl_id":null,"docs":" Spawns a scoped thread.\n\n This method is similar to the [`spawn`] function in Rust's standard library. The difference\n is that this thread is scoped, meaning it's guaranteed to terminate before the scope exits,\n allowing it to reference variables outside the scope.\n\n The scoped thread is passed a reference to this scope as an argument, which can be used for\n spawning nested threads.\n\n The returned handle can be used to manually join the thread before the scope exits.\n\n [`spawn`]: https://doc.rust-lang.org/std/thread/fn.spawn.html\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     let handle = s.spawn(|_| {\n         println!(\"A child thread is running\");\n         42\n     });\n\n     // Join the thread and retrieve its result.\n     let res = handle.join().unwrap();\n     assert_eq!(res, 42);\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":512},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8556435,"byte_end":8556442,"line_start":263,"line_end":263,"column_start":12,"column_end":19},"name":"builder","qualname":"<Scope>::builder","value":"fn <'scope> (&'scope self) -> ScopedThreadBuilder<'scope, 'env>","parent":null,"children":[],"decl_id":null,"docs":" Creates a builder that can configure a thread before spawning.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n use std::thread::current;\n\n thread::scope(|s| {\n     s.builder()\n         .spawn(|_| println!(\"A child thread is running\"))\n         .unwrap();\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":566},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8558102,"byte_end":8558121,"line_start":311,"line_end":311,"column_start":12,"column_end":31},"name":"ScopedThreadBuilder","qualname":"::thread::ScopedThreadBuilder","value":"ScopedThreadBuilder {  }","parent":null,"children":[{"krate":0,"index":569},{"krate":0,"index":570}],"decl_id":null,"docs":" Configures the properties of a new thread.\n\n The two configurable properties are:\n\n - [`name`]: Specifies an [associated name for the thread][naming-threads].\n - [`stack_size`]: Specifies the [desired stack size for the thread][stack-size].\n\n The [`spawn`] method will take ownership of the builder and return an [`io::Result`] of the\n thread handle with the given configuration.\n\n The [`Scope::spawn`] method uses a builder with default configuration and unwraps its return\n value. You may want to use this builder when you want to recover from a failure to launch a\n thread.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     s.builder()\n         .spawn(|_| println!(\"Running a child thread\"))\n         .unwrap();\n }).unwrap();\n ```\n\n [`name`]: struct.ScopedThreadBuilder.html#method.name\n [`stack_size`]: struct.ScopedThreadBuilder.html#method.stack_size\n [`spawn`]: struct.ScopedThreadBuilder.html#method.spawn\n [`Scope::spawn`]: struct.Scope.html#method.spawn\n [`io::Result`]: https://doc.rust-lang.org/std/io/type.Result.html\n [naming-threads]: https://doc.rust-lang.org/std/thread/index.html#naming-threads\n [stack-size]: https://doc.rust-lang.org/std/thread/index.html#stack-size\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":520},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8558909,"byte_end":8558913,"line_start":337,"line_end":337,"column_start":12,"column_end":16},"name":"name","qualname":"<ScopedThreadBuilder>::name","value":"fn (mut self, name: String) -> ScopedThreadBuilder<'scope, 'env>","parent":null,"children":[],"decl_id":null,"docs":" Sets the name for the new thread.\n\n The name must not contain null bytes. For more information about named threads, see\n [here][naming-threads].\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n use std::thread::current;\n\n thread::scope(|s| {\n     s.builder()\n         .name(\"my thread\".to_string())\n         .spawn(|_| assert_eq!(current().name(), Some(\"my thread\")))\n         .unwrap();\n }).unwrap();\n ```\n\n [naming-threads]: https://doc.rust-lang.org/std/thread/index.html#naming-threads\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":521},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8559470,"byte_end":8559480,"line_start":358,"line_end":358,"column_start":12,"column_end":22},"name":"stack_size","qualname":"<ScopedThreadBuilder>::stack_size","value":"fn (mut self, size: usize) -> ScopedThreadBuilder<'scope, 'env>","parent":null,"children":[],"decl_id":null,"docs":" Sets the size of the stack for the new thread.\n\n The stack size is measured in bytes.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     s.builder()\n         .stack_size(32 * 1024)\n         .spawn(|_| println!(\"Running a child thread\"))\n         .unwrap();\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":522},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8560415,"byte_end":8560420,"line_start":388,"line_end":388,"column_start":12,"column_end":17},"name":"spawn","qualname":"<ScopedThreadBuilder>::spawn","value":"fn <F, T> (self, f: F) -> io::Result<ScopedJoinHandle<'scope, T>>","parent":null,"children":[],"decl_id":null,"docs":" Spawns a scoped thread with this configuration.\n\n The scoped thread is passed a reference to this scope as an argument, which can be used for\n spawning nested threads.\n\n The returned handle can be used to manually join the thread before the scope exits.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     let handle = s.builder()\n         .spawn(|_| {\n             println!(\"A child thread is running\");\n             42\n         })\n         .unwrap();\n\n     // Join the thread and retrieve its result.\n     let res = handle.join().unwrap();\n     assert_eq!(res, 42);\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":534},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8562848,"byte_end":8562864,"line_start":455,"line_end":455,"column_start":12,"column_end":28},"name":"ScopedJoinHandle","qualname":"::thread::ScopedJoinHandle","value":"ScopedJoinHandle {  }","parent":null,"children":[{"krate":0,"index":537},{"krate":0,"index":538},{"krate":0,"index":539},{"krate":0,"index":540}],"decl_id":null,"docs":" A handle that can be used to join its scoped thread.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":544},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8564184,"byte_end":8564188,"line_start":497,"line_end":497,"column_start":12,"column_end":16},"name":"join","qualname":"<ScopedJoinHandle>::join","value":"fn (self) -> thread::Result<T>","parent":null,"children":[],"decl_id":null,"docs":" Waits for the thread to finish and returns its result.\n\n If the child thread panics, an error is returned.\n\n # Panics\n\n This function may panic on some platforms if a thread attempts to join itself or otherwise\n may create a deadlock with joining threads.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     let handle1 = s.spawn(|_| println!(\"I'm a happy thread :)\"));\n     let handle2 = s.spawn(|_| panic!(\"I'm a sad thread :(\"));\n\n     // Join the first thread and verify that it succeeded.\n     let res = handle1.join();\n     assert!(res.is_ok());\n\n     // Join the second thread and verify that it panicked.\n     let res = handle2.join();\n     assert!(res.is_err());\n }).unwrap();\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":546},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8564997,"byte_end":8565003,"line_start":520,"line_end":520,"column_start":12,"column_end":18},"name":"thread","qualname":"<ScopedJoinHandle>::thread","value":"fn (&self) -> &thread::Thread","parent":null,"children":[],"decl_id":null,"docs":" Returns a handle to the underlying thread.\n\n # Examples\n\n ```\n use crossbeam_utils::thread;\n\n thread::scope(|s| {\n     let handle = s.spawn(|_| println!(\"A child thread is running\"));\n     println!(\"The child thread ID: {:?}\", handle.thread().id());\n }).unwrap();\n ```\n","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8512492,"byte_end":8512499,"line_start":14,"line_end":14,"column_start":6,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":157},{"krate":0,"index":158},{"krate":0,"index":159},{"krate":0,"index":160}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8514082,"byte_end":8514099,"line_start":72,"line_end":72,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":165}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8514284,"byte_end":8514301,"line_start":80,"line_end":80,"column_start":15,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":167}],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4064,"byte_end":4074,"line_start":36,"line_end":36,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4111,"byte_end":4121,"line_start":37,"line_end":37,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4176,"byte_end":4186,"line_start":40,"line_end":40,"column_start":24,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4243,"byte_end":4253,"line_start":42,"line_end":42,"column_start":27,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4269,"byte_end":4279,"line_start":44,"line_end":44,"column_start":9,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":32},{"krate":0,"index":33},{"krate":0,"index":34},{"krate":0,"index":35},{"krate":0,"index":36}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":7628,"byte_end":7638,"line_start":166,"line_end":166,"column_start":17,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":39},{"krate":0,"index":40}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8495,"byte_end":8505,"line_start":202,"line_end":202,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":43}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8946,"byte_end":8956,"line_start":221,"line_end":221,"column_start":15,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":46}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":9285,"byte_end":9295,"line_start":238,"line_end":238,"column_start":20,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":49},{"krate":0,"index":50}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":21232,"byte_end":21242,"line_start":565,"line_end":565,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":53},{"krate":0,"index":54},{"krate":0,"index":55}],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":23083,"byte_end":23093,"line_start":630,"line_end":630,"column_start":30,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":58}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":23224,"byte_end":23234,"line_start":636,"line_end":636,"column_start":43,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":61}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":25985,"byte_end":25995,"line_start":704,"line_end":704,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":73},{"krate":0,"index":74},{"krate":0,"index":75},{"krate":0,"index":76}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\consume.rs","byte_start":35411,"byte_end":35420,"line_start":79,"line_end":79,"column_start":49,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":97},{"krate":0,"index":249}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38196,"byte_end":38207,"line_start":72,"line_end":72,"column_start":31,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38244,"byte_end":38255,"line_start":73,"line_end":73,"column_start":31,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38271,"byte_end":38282,"line_start":75,"line_end":75,"column_start":9,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":111},{"krate":0,"index":112}],"docs":"","sig":null,"attributes":[]},{"id":20,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38942,"byte_end":38953,"line_start":105,"line_end":105,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":115},{"krate":0,"index":116}],"docs":"","sig":null,"attributes":[]},{"id":21,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39059,"byte_end":39070,"line_start":113,"line_end":113,"column_start":22,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":119}],"docs":"","sig":null,"attributes":[]},{"id":22,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39184,"byte_end":39195,"line_start":119,"line_end":119,"column_start":36,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":122}],"docs":"","sig":null,"attributes":[]},{"id":23,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39390,"byte_end":39401,"line_start":127,"line_end":127,"column_start":21,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":125}],"docs":"","sig":null,"attributes":[]},{"id":24,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":41992,"byte_end":41999,"line_start":84,"line_end":84,"column_start":6,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":136},{"krate":0,"index":137},{"krate":0,"index":138},{"krate":0,"index":139},{"krate":0,"index":140},{"krate":0,"index":141}],"docs":"","sig":null,"attributes":[]},{"id":25,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47634,"byte_end":47641,"line_start":279,"line_end":279,"column_start":21,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":143}],"docs":"","sig":null,"attributes":[]},{"id":26,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47881,"byte_end":47888,"line_start":288,"line_end":288,"column_start":18,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":145}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8517087,"byte_end":8517093,"line_start":59,"line_end":59,"column_start":22,"column_end":28},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8517103,"byte_end":8517109,"line_start":61,"line_end":61,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":293},{"krate":0,"index":294},{"krate":0,"index":295},{"krate":0,"index":296}],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519691,"byte_end":8519697,"line_start":155,"line_end":155,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":298}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519965,"byte_end":8519973,"line_start":168,"line_end":168,"column_start":22,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519998,"byte_end":8520006,"line_start":169,"line_end":169,"column_start":22,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":32,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8520016,"byte_end":8520024,"line_start":171,"line_end":171,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":304}],"docs":"","sig":null,"attributes":[]},{"id":33,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8520958,"byte_end":8520966,"line_start":204,"line_end":204,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":306}],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8521085,"byte_end":8521093,"line_start":210,"line_end":210,"column_start":16,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":308}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8521371,"byte_end":8521376,"line_start":228,"line_end":228,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":317},{"krate":0,"index":318}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528382,"byte_end":8528393,"line_start":83,"line_end":83,"column_start":40,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":37,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528446,"byte_end":8528457,"line_start":84,"line_end":84,"column_start":47,"column_end":58},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":38,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528496,"byte_end":8528507,"line_start":86,"line_end":86,"column_start":32,"column_end":43},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528548,"byte_end":8528559,"line_start":87,"line_end":87,"column_start":35,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":40,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528575,"byte_end":8528586,"line_start":89,"line_end":89,"column_start":9,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":363},{"krate":0,"index":365}],"docs":"","sig":null,"attributes":[]},{"id":41,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8530009,"byte_end":8530020,"line_start":141,"line_end":141,"column_start":17,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":368},{"krate":0,"index":369},{"krate":0,"index":370},{"krate":0,"index":371},{"krate":0,"index":372},{"krate":0,"index":373}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8539720,"byte_end":8539731,"line_start":416,"line_end":416,"column_start":45,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":376}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540195,"byte_end":8540212,"line_start":425,"line_end":425,"column_start":37,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":380}],"docs":"","sig":null,"attributes":[]},{"id":44,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540529,"byte_end":8540540,"line_start":436,"line_end":436,"column_start":30,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":383}],"docs":"","sig":null,"attributes":[]},{"id":45,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540657,"byte_end":8540668,"line_start":442,"line_end":442,"column_start":21,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":386}],"docs":"","sig":null,"attributes":[]},{"id":46,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541091,"byte_end":8541111,"line_start":457,"line_end":457,"column_start":44,"column_end":64},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541153,"byte_end":8541173,"line_start":459,"line_end":459,"column_start":31,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":399},{"krate":0,"index":400}],"docs":"","sig":null,"attributes":[]},{"id":48,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541324,"byte_end":8541344,"line_start":467,"line_end":467,"column_start":40,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":404}],"docs":"","sig":null,"attributes":[]},{"id":49,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541582,"byte_end":8541602,"line_start":475,"line_end":475,"column_start":53,"column_end":73},"value":"","parent":null,"children":[{"krate":0,"index":408}],"docs":"","sig":null,"attributes":[]},{"id":50,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542025,"byte_end":8542046,"line_start":489,"line_end":489,"column_start":44,"column_end":65},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":51,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542087,"byte_end":8542108,"line_start":491,"line_end":491,"column_start":30,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":420}],"docs":"","sig":null,"attributes":[]},{"id":52,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542496,"byte_end":8542517,"line_start":504,"line_end":504,"column_start":40,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":424}],"docs":"","sig":null,"attributes":[]},{"id":53,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542756,"byte_end":8542777,"line_start":512,"line_end":512,"column_start":53,"column_end":74},"value":"","parent":null,"children":[{"krate":0,"index":428}],"docs":"","sig":null,"attributes":[]},{"id":54,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542909,"byte_end":8542930,"line_start":518,"line_end":518,"column_start":31,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":432},{"krate":0,"index":433}],"docs":"","sig":null,"attributes":[]},{"id":55,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8543075,"byte_end":8543096,"line_start":526,"line_end":526,"column_start":34,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":437}],"docs":"","sig":null,"attributes":[]},{"id":56,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8544394,"byte_end":8544406,"line_start":572,"line_end":572,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":448}],"docs":"","sig":null,"attributes":[]},{"id":57,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8546557,"byte_end":8546566,"line_start":55,"line_end":55,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":461},{"krate":0,"index":462}],"docs":"","sig":null,"attributes":[]},{"id":58,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8547866,"byte_end":8547875,"line_start":110,"line_end":110,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":464}],"docs":"","sig":null,"attributes":[]},{"id":59,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8548084,"byte_end":8548093,"line_start":121,"line_end":121,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":466}],"docs":"","sig":null,"attributes":[]},{"id":60,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8548309,"byte_end":8548318,"line_start":132,"line_end":132,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":468}],"docs":"","sig":null,"attributes":[]},{"id":61,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8554730,"byte_end":8554735,"line_start":208,"line_end":208,"column_start":28,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":62,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8554757,"byte_end":8554762,"line_start":210,"line_end":210,"column_start":12,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":508},{"krate":0,"index":512}],"docs":"","sig":null,"attributes":[]},{"id":63,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8556649,"byte_end":8556654,"line_start":271,"line_end":271,"column_start":27,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":516}],"docs":"","sig":null,"attributes":[]},{"id":64,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8558230,"byte_end":8558249,"line_start":316,"line_end":316,"column_start":20,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":520},{"krate":0,"index":521},{"krate":0,"index":522}],"docs":"","sig":null,"attributes":[]},{"id":65,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8562685,"byte_end":8562701,"line_start":451,"line_end":451,"column_start":33,"column_end":49},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":66,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8562748,"byte_end":8562764,"line_start":452,"line_end":452,"column_start":33,"column_end":49},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":67,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8563238,"byte_end":8563254,"line_start":469,"line_end":469,"column_start":17,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":544},{"krate":0,"index":546}],"docs":"","sig":null,"attributes":[]},{"id":68,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8565093,"byte_end":8565109,"line_start":525,"line_end":525,"column_start":32,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":550}],"docs":"","sig":null,"attributes":[]}],"refs":[{"kind":"Mod","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1568,"byte_end":1574,"line_start":48,"line_end":48,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":5}},{"kind":"Mod","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1786,"byte_end":1790,"line_start":61,"line_end":61,"column_start":17,"column_end":21},"ref_id":{"krate":0,"index":277}},{"kind":"Mod","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\lib.rs","byte_start":1808,"byte_end":1814,"line_start":62,"line_end":62,"column_start":17,"column_end":23},"ref_id":{"krate":0,"index":477}}],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8512492,"byte_end":8512499,"line_start":14,"line_end":14,"column_start":6,"column_end":13},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":154},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8514082,"byte_end":8514099,"line_start":72,"line_end":72,"column_start":6,"column_end":23},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":161},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\seq_lock.rs","byte_start":8514284,"byte_end":8514301,"line_start":80,"line_end":80,"column_start":15,"column_end":32},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":161},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4064,"byte_end":4074,"line_start":36,"line_end":36,"column_start":31,"column_end":41},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":19},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4111,"byte_end":4121,"line_start":37,"line_end":37,"column_start":31,"column_end":41},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":19},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4176,"byte_end":4186,"line_start":40,"line_end":40,"column_start":24,"column_end":34},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":3640}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4243,"byte_end":4253,"line_start":42,"line_end":42,"column_start":27,"column_end":37},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":3641}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":4269,"byte_end":4279,"line_start":44,"line_end":44,"column_start":9,"column_end":19},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":7628,"byte_end":7638,"line_start":166,"line_end":166,"column_start":17,"column_end":27},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8495,"byte_end":8505,"line_start":202,"line_end":202,"column_start":18,"column_end":28},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":8946,"byte_end":8956,"line_start":221,"line_end":221,"column_start":15,"column_end":25},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":9285,"byte_end":9295,"line_start":238,"line_end":238,"column_start":20,"column_end":30},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":21232,"byte_end":21242,"line_start":565,"line_end":565,"column_start":6,"column_end":16},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":23083,"byte_end":23093,"line_start":630,"line_end":630,"column_start":30,"column_end":40},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":19},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":23224,"byte_end":23234,"line_start":636,"line_end":636,"column_start":43,"column_end":53},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":19},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\atomic_cell.rs","byte_start":25985,"byte_end":25995,"line_start":704,"line_end":704,"column_start":6,"column_end":16},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":70},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\atomic\\consume.rs","byte_start":35411,"byte_end":35420,"line_start":79,"line_end":79,"column_start":49,"column_end":58},"kind":{"Impl":{"id":16}},"from":{"krate":2,"index":2722},"to":{"krate":0,"index":90}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38196,"byte_end":38207,"line_start":72,"line_end":72,"column_start":31,"column_end":42},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38244,"byte_end":38255,"line_start":73,"line_end":73,"column_start":31,"column_end":42},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38271,"byte_end":38282,"line_start":75,"line_end":75,"column_start":9,"column_end":20},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":250},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":38942,"byte_end":38953,"line_start":105,"line_end":105,"column_start":19,"column_end":30},"kind":{"Impl":{"id":20}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39059,"byte_end":39070,"line_start":113,"line_end":113,"column_start":22,"column_end":33},"kind":{"Impl":{"id":21}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":1715}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39184,"byte_end":39195,"line_start":119,"line_end":119,"column_start":36,"column_end":47},"kind":{"Impl":{"id":22}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\cache_padded.rs","byte_start":39390,"byte_end":39401,"line_start":127,"line_end":127,"column_start":21,"column_end":32},"kind":{"Impl":{"id":23}},"from":{"krate":0,"index":250},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":41992,"byte_end":41999,"line_start":84,"line_end":84,"column_start":6,"column_end":13},"kind":{"Impl":{"id":24}},"from":{"krate":0,"index":133},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47634,"byte_end":47641,"line_start":279,"line_end":279,"column_start":21,"column_end":28},"kind":{"Impl":{"id":25}},"from":{"krate":0,"index":133},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\backoff.rs","byte_start":47881,"byte_end":47888,"line_start":288,"line_end":288,"column_start":18,"column_end":25},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":133},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8517087,"byte_end":8517093,"line_start":59,"line_end":59,"column_start":22,"column_end":28},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":288},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8517103,"byte_end":8517109,"line_start":61,"line_end":61,"column_start":6,"column_end":12},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":288},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519691,"byte_end":8519697,"line_start":155,"line_end":155,"column_start":21,"column_end":27},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":288},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519965,"byte_end":8519973,"line_start":168,"line_end":168,"column_start":22,"column_end":30},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":299},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8519998,"byte_end":8520006,"line_start":169,"line_end":169,"column_start":22,"column_end":30},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":299},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8520016,"byte_end":8520024,"line_start":171,"line_end":171,"column_start":6,"column_end":14},"kind":{"Impl":{"id":32}},"from":{"krate":0,"index":299},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8520958,"byte_end":8520966,"line_start":204,"line_end":204,"column_start":21,"column_end":29},"kind":{"Impl":{"id":33}},"from":{"krate":0,"index":299},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8521085,"byte_end":8521093,"line_start":210,"line_end":210,"column_start":16,"column_end":24},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":299},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\parker.rs","byte_start":8521371,"byte_end":8521376,"line_start":228,"line_end":228,"column_start":6,"column_end":11},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":312},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528382,"byte_end":8528393,"line_start":83,"line_end":83,"column_start":40,"column_end":51},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":349},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528446,"byte_end":8528457,"line_start":84,"line_end":84,"column_start":47,"column_end":58},"kind":{"Impl":{"id":37}},"from":{"krate":0,"index":349},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528496,"byte_end":8528507,"line_start":86,"line_end":86,"column_start":32,"column_end":43},"kind":{"Impl":{"id":38}},"from":{"krate":0,"index":349},"to":{"krate":1,"index":3640}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528548,"byte_end":8528559,"line_start":87,"line_end":87,"column_start":35,"column_end":46},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":349},"to":{"krate":1,"index":3641}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8528575,"byte_end":8528586,"line_start":89,"line_end":89,"column_start":9,"column_end":20},"kind":{"Impl":{"id":40}},"from":{"krate":0,"index":349},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8530009,"byte_end":8530020,"line_start":141,"line_end":141,"column_start":17,"column_end":28},"kind":{"Impl":{"id":41}},"from":{"krate":0,"index":349},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8539720,"byte_end":8539731,"line_start":416,"line_end":416,"column_start":45,"column_end":56},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":349},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540195,"byte_end":8540212,"line_start":425,"line_end":425,"column_start":37,"column_end":54},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":377},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540529,"byte_end":8540540,"line_start":436,"line_end":436,"column_start":30,"column_end":41},"kind":{"Impl":{"id":44}},"from":{"krate":0,"index":349},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8540657,"byte_end":8540668,"line_start":442,"line_end":442,"column_start":21,"column_end":32},"kind":{"Impl":{"id":45}},"from":{"krate":0,"index":349},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541091,"byte_end":8541111,"line_start":457,"line_end":457,"column_start":44,"column_end":64},"kind":{"Impl":{"id":46}},"from":{"krate":0,"index":387},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541153,"byte_end":8541173,"line_start":459,"line_end":459,"column_start":31,"column_end":51},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":387},"to":{"krate":2,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541324,"byte_end":8541344,"line_start":467,"line_end":467,"column_start":40,"column_end":60},"kind":{"Impl":{"id":48}},"from":{"krate":0,"index":387},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8541582,"byte_end":8541602,"line_start":475,"line_end":475,"column_start":53,"column_end":73},"kind":{"Impl":{"id":49}},"from":{"krate":0,"index":387},"to":{"krate":2,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542025,"byte_end":8542046,"line_start":489,"line_end":489,"column_start":44,"column_end":65},"kind":{"Impl":{"id":50}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542087,"byte_end":8542108,"line_start":491,"line_end":491,"column_start":30,"column_end":51},"kind":{"Impl":{"id":51}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542496,"byte_end":8542517,"line_start":504,"line_end":504,"column_start":40,"column_end":61},"kind":{"Impl":{"id":52}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542756,"byte_end":8542777,"line_start":512,"line_end":512,"column_start":53,"column_end":74},"kind":{"Impl":{"id":53}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8542909,"byte_end":8542930,"line_start":518,"line_end":518,"column_start":31,"column_end":52},"kind":{"Impl":{"id":54}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8543075,"byte_end":8543096,"line_start":526,"line_end":526,"column_start":34,"column_end":55},"kind":{"Impl":{"id":55}},"from":{"krate":0,"index":409},"to":{"krate":2,"index":1715}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\sharded_lock.rs","byte_start":8544394,"byte_end":8544406,"line_start":572,"line_end":572,"column_start":15,"column_end":27},"kind":{"Impl":{"id":56}},"from":{"krate":0,"index":444},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8546557,"byte_end":8546566,"line_start":55,"line_end":55,"column_start":6,"column_end":15},"kind":{"Impl":{"id":57}},"from":{"krate":0,"index":455},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8547866,"byte_end":8547875,"line_start":110,"line_end":110,"column_start":15,"column_end":24},"kind":{"Impl":{"id":58}},"from":{"krate":0,"index":455},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8548084,"byte_end":8548093,"line_start":121,"line_end":121,"column_start":16,"column_end":25},"kind":{"Impl":{"id":59}},"from":{"krate":0,"index":455},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\sync\\wait_group.rs","byte_start":8548309,"byte_end":8548318,"line_start":132,"line_end":132,"column_start":21,"column_end":30},"kind":{"Impl":{"id":60}},"from":{"krate":0,"index":455},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8554730,"byte_end":8554735,"line_start":208,"line_end":208,"column_start":28,"column_end":33},"kind":{"Impl":{"id":61}},"from":{"krate":0,"index":499},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8554757,"byte_end":8554762,"line_start":210,"line_end":210,"column_start":12,"column_end":17},"kind":{"Impl":{"id":62}},"from":{"krate":0,"index":499},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8556649,"byte_end":8556654,"line_start":271,"line_end":271,"column_start":27,"column_end":32},"kind":{"Impl":{"id":63}},"from":{"krate":0,"index":499},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8558230,"byte_end":8558249,"line_start":316,"line_end":316,"column_start":20,"column_end":39},"kind":{"Impl":{"id":64}},"from":{"krate":0,"index":566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8562685,"byte_end":8562701,"line_start":451,"line_end":451,"column_start":33,"column_end":49},"kind":{"Impl":{"id":65}},"from":{"krate":0,"index":534},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8562748,"byte_end":8562764,"line_start":452,"line_end":452,"column_start":33,"column_end":49},"kind":{"Impl":{"id":66}},"from":{"krate":0,"index":534},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8563238,"byte_end":8563254,"line_start":469,"line_end":469,"column_start":17,"column_end":33},"kind":{"Impl":{"id":67}},"from":{"krate":0,"index":534},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\crossbeam-utils-0.7.0\\src\\thread.rs","byte_start":8565093,"byte_end":8565109,"line_start":525,"line_end":525,"column_start":32,"column_end":48},"kind":{"Impl":{"id":68}},"from":{"krate":0,"index":534},"to":{"krate":2,"index":7643}}]}