{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","hound","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","-C","metadata=00c215c09f4c335e","-C","extra-filename=-00c215c09f4c335e","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--cap-lints","allow","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libhound-00c215c09f4c335e.rmeta"},"prelude":{"crate_id":{"name":"hound","disambiguator":[15826694583117813707,7505290145761766379]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":1,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":2,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":631,"byte_end":26075,"line_start":13,"line_end":792,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":71},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2082,"byte_end":2091,"line_start":68,"line_end":68,"column_start":16,"column_end":25},"alias_span":null,"name":"WavReader","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":84},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2093,"byte_end":2107,"line_start":68,"line_end":68,"column_start":27,"column_end":41},"alias_span":null,"name":"WavIntoSamples","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":78},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2109,"byte_end":2119,"line_start":68,"line_end":68,"column_start":43,"column_end":53},"alias_span":null,"name":"WavSamples","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":89},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2121,"byte_end":2137,"line_start":68,"line_end":68,"column_start":55,"column_end":71},"alias_span":null,"name":"read_wave_header","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":231},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2156,"byte_end":2170,"line_start":69,"line_end":69,"column_start":17,"column_end":31},"alias_span":null,"name":"SampleWriter16","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":186},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2172,"byte_end":2181,"line_start":69,"line_end":69,"column_start":33,"column_end":42},"alias_span":null,"name":"WavWriter","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":631,"byte_end":26075,"line_start":13,"line_end":792,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":7},{"krate":0,"index":8},{"krate":0,"index":9},{"krate":0,"index":145},{"krate":0,"index":248},{"krate":0,"index":253},{"krate":0,"index":256},{"krate":0,"index":262},{"krate":0,"index":263},{"krate":0,"index":264},{"krate":0,"index":266},{"krate":0,"index":268},{"krate":0,"index":269},{"krate":0,"index":275},{"krate":0,"index":281},{"krate":0,"index":287},{"krate":0,"index":315},{"krate":0,"index":329},{"krate":0,"index":328},{"krate":0,"index":326},{"krate":0,"index":323},{"krate":0,"index":324},{"krate":0,"index":320},{"krate":0,"index":321},{"krate":0,"index":331},{"krate":0,"index":346},{"krate":0,"index":345},{"krate":0,"index":343},{"krate":0,"index":339},{"krate":0,"index":340},{"krate":0,"index":336},{"krate":0,"index":337},{"krate":0,"index":348},{"krate":0,"index":363},{"krate":0,"index":293},{"krate":0,"index":295},{"krate":0,"index":298},{"krate":0,"index":300},{"krate":0,"index":302},{"krate":0,"index":304}],"decl_id":null,"docs":" Hound, a wav encoding and decoding library.\n\n Examples\n ========\n\n The following example renders a 440 Hz sine wave, and stores it as as a\n mono wav file with a sample rate of 44.1 kHz and 16 bits per sample.\n\n ```\n use std::f32::consts::PI;\n use std::i16;\n use hound;\n\n let spec = hound::WavSpec {\n     channels: 1,\n     sample_rate: 44100,\n     bits_per_sample: 16,\n     sample_format: hound::SampleFormat::Int,\n };\n let mut writer = hound::WavWriter::create(\"sine.wav\", spec).unwrap();\n for t in (0 .. 44100).map(|x| x as f32 / 44100.0) {\n     let sample = (t * 440.0 * 2.0 * PI).sin();\n     let amplitude = i16::MAX as f32;\n     writer.write_sample((sample * amplitude) as i16).unwrap();\n }\n writer.finalize().unwrap();\n ```\n\n The following example computes the root mean square (RMS) of an audio file\n with at most 16 bits per sample.\n\n ```\n use hound;\n\n let mut reader = hound::WavReader::open(\"testsamples/pop.wav\").unwrap();\n let sqr_sum = reader.samples::<i16>()\n                     .fold(0.0, |sqr_sum, s| {\n     let sample = s.unwrap() as f64;\n     sqr_sum + sample * sample\n });\n println!(\"RMS is {}\", (sqr_sum / reader.len() as f64).sqrt());\n ```\n","sig":null,"attributes":[{"value":"warn(missing_docs)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":1920,"byte_end":1942,"line_start":56,"line_end":56,"column_start":1,"column_end":23}}]},{"kind":"Struct","id":{"krate":0,"index":71},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":33536,"byte_end":33545,"line_start":216,"line_end":216,"column_start":12,"column_end":21},"name":"WavReader","qualname":"::read::WavReader","value":"WavReader {  }","parent":null,"children":[{"krate":0,"index":73},{"krate":0,"index":74},{"krate":0,"index":75},{"krate":0,"index":76},{"krate":0,"index":77}],"decl_id":null,"docs":" A reader that reads the WAVE format from the underlying reader.\n\n A `WavReader` is a streaming reader. It reads data from the underlying\n reader on demand, and it reads no more than strictly necessary. No internal\n buffering is performed on the underlying reader, but this can easily be\n added by wrapping the reader in an `io::BufReader`. The `open` constructor\n takes care of this for you.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":78},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":34379,"byte_end":34389,"line_start":241,"line_end":241,"column_start":12,"column_end":22},"name":"WavSamples","qualname":"::read::WavSamples","value":"WavSamples {  }","parent":null,"children":[{"krate":0,"index":82},{"krate":0,"index":83}],"decl_id":null,"docs":" An iterator that yields samples of type `S` read from a `WavReader`.\n\n The type `S` must have at least as many bits as the bits per sample of the\n file, otherwise every iteration will return an error.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":84},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":34727,"byte_end":34741,"line_start":252,"line_end":252,"column_start":12,"column_end":26},"name":"WavIntoSamples","qualname":"::read::WavIntoSamples","value":"WavIntoSamples {  }","parent":null,"children":[{"krate":0,"index":87},{"krate":0,"index":88}],"decl_id":null,"docs":" An iterator that yields samples of type `S` read from a `WavReader`.\n\n The type `S` must have at least as many bits as the bits per sample of the\n file, otherwise every iteration will return an error.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":89},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":35216,"byte_end":35232,"line_start":265,"line_end":265,"column_start":8,"column_end":24},"name":"read_wave_header","qualname":"::read::read_wave_header","value":"fn <R> (reader: &mut R) -> Result<u64>","parent":null,"children":[],"decl_id":null,"docs":" Reads the RIFF WAVE header, returns the supposed file size.\n\n This function can be used to quickly check if the file could be a wav file\n by reading 12 bytes of the header. If an `Ok` is returned, the file is\n likely a wav file. If an `Err` is returned, it is definitely not a wav\n file.\n\n The returned file size cannot be larger than 2<sup>32</sup> + 7 bytes.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":106},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":49175,"byte_end":49178,"line_start":598,"line_end":598,"column_start":12,"column_end":15},"name":"new","qualname":"<WavReader<R>>::new","value":"fn (mut reader: R) -> Result<WavReader<R>>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to create a reader that reads the WAVE format.\n\n The header is read immediately. Reading the data will be done on\n demand.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":107},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":50607,"byte_end":50611,"line_start":633,"line_end":633,"column_start":12,"column_end":16},"name":"spec","qualname":"<WavReader<R>>::spec","value":"fn (&self) -> WavSpec","parent":null,"children":[],"decl_id":null,"docs":" Returns information about the WAVE file.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":108},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":51526,"byte_end":51533,"line_start":652,"line_end":652,"column_start":12,"column_end":19},"name":"samples","qualname":"<WavReader<R>>::samples","value":"fn <'wr, S> (&'wr mut self) -> WavSamples<'wr, R, S>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over all samples.\n\n The channel data is is interleaved. The iterator is streaming. That is,\n if you call this method once, read a few samples, and call this method\n again, the second iterator will not start again from the beginning of\n the file, it will continue where the first iterator stopped.\n\n The type `S` must have at least `spec().bits_per_sample` bits,\n otherwise every iteration will return an error. All bit depths up to\n 32 bits per sample can be decoded into an `i32`, but if you know\n beforehand that you will be reading a file with 16 bits per sample, you\n can save memory by decoding into an `i16`.\n\n The type of `S` (int or float) must match `spec().sample_format`,\n otherwise every iteration will return an error.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":111},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":51830,"byte_end":51842,"line_start":662,"line_end":662,"column_start":12,"column_end":24},"name":"into_samples","qualname":"<WavReader<R>>::into_samples","value":"fn <S> (self) -> WavIntoSamples<R, S>","parent":null,"children":[],"decl_id":null,"docs":" Same as `samples`, but takes ownership of the `WavReader`.\n\n See `samples()` for more info.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":113},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":52355,"byte_end":52363,"line_start":675,"line_end":675,"column_start":12,"column_end":20},"name":"duration","qualname":"<WavReader<R>>::duration","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the duration of the file in samples.\n\n The duration is independent of the number of channels. It is expressed\n in units of samples. The duration in seconds can be obtained by\n dividing this number by the sample rate. The duration is independent of\n how many samples have been read already.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":114},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":52793,"byte_end":52796,"line_start":685,"line_end":685,"column_start":12,"column_end":15},"name":"len","qualname":"<WavReader<R>>::len","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of values that the sample iterator will yield.\n\n The length of the file is its duration (in samples) times the number of\n channels. The length is independent of how many samples have been read\n already. To get the number of samples left, use `len()` on the\n `samples()` iterator.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":115},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":52924,"byte_end":52934,"line_start":690,"line_end":690,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<WavReader<R>>::into_inner","value":"fn (self) -> R","parent":null,"children":[],"decl_id":null,"docs":" Destroys the `WavReader` and returns the underlying reader.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":116},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":53579,"byte_end":53583,"line_start":704,"line_end":704,"column_start":12,"column_end":16},"name":"seek","qualname":"<WavReader<R>>::seek","value":"fn (&mut self, time: u32) -> io::Result<()>","parent":null,"children":[],"decl_id":null,"docs":" Seek to the given time within the file.\n\n The given time is measured in number of samples (independent of the\n number of channels) since the beginning of the audio data. To seek to\n a particular time in seconds, multiply the number of seconds with\n `WavSpec::sample_rate`. The given time should not exceed the duration of\n the file (returned by `duration()`). The behavior when seeking beyond\n `duration()` depends on the reader's `Seek` implementation.\n\n This method requires that the inner reader `R` implements `Seek`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":118},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":54343,"byte_end":54347,"line_start":722,"line_end":722,"column_start":12,"column_end":16},"name":"open","qualname":"<WavReader<io::BufReader<fs::File>>>::open","value":"fn <P> (filename: P) -> Result<WavReader<io::BufReader<fs::File>>>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to create a reader that reads from the specified file.\n\n This is a convenience constructor that opens a `File`, wraps it in a\n `BufReader` and then constructs a `WavReader` from it.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":186},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":75995,"byte_end":76004,"line_start":136,"line_end":136,"column_start":12,"column_end":21},"name":"WavWriter","qualname":"::write::WavWriter","value":"WavWriter {  }","parent":null,"children":[{"krate":0,"index":188},{"krate":0,"index":189},{"krate":0,"index":190},{"krate":0,"index":191},{"krate":0,"index":192},{"krate":0,"index":193},{"krate":0,"index":194}],"decl_id":null,"docs":" A writer that accepts samples and writes the WAVE format.\n\n The writer needs a `WavSpec` that describes the audio properties. Then\n samples can be written with `write_sample`. Channel data is interleaved.\n The number of samples written must be a multiple of the number of channels.\n After all samples have been written, the file must be finalized. This can\n be done by calling `finalize`. If `finalize` is not called, the file will\n be finalized upon drop. However, finalization may fail, and without calling\n `finalize`, such a failure cannot be observed.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":202},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":77530,"byte_end":77533,"line_start":185,"line_end":185,"column_start":12,"column_end":15},"name":"new","qualname":"<WavWriter<W>>::new","value":"fn (writer: W, spec: WavSpec) -> Result<WavWriter<W>>","parent":null,"children":[],"decl_id":null,"docs":" Creates a writer that writes the WAVE format to the underlying writer.\n\n The underlying writer is assumed to be at offset 0. `WavWriter` employs\n *no* buffering internally. It is recommended to wrap the writer in a\n `BufWriter` to avoid too many `write` calls. The `create()` constructor\n does this automatically.\n\n This writes parts of the header immediately, hence a `Result` is\n returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":208},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":85410,"byte_end":85422,"line_start":385,"line_end":385,"column_start":12,"column_end":24},"name":"write_sample","qualname":"<WavWriter<W>>::write_sample","value":"fn <S> (&mut self, sample: S) -> Result<()>","parent":null,"children":[],"decl_id":null,"docs":" Writes a single sample for one channel.\n\n WAVE interleaves channel data, so the channel that this writes the\n sample to depends on previous writes. This will return an error if the\n sample does not fit in the number of bits specified in the `WavSpec`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":85389,"byte_end":85398,"line_start":384,"line_end":384,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":210},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":86399,"byte_end":86413,"line_start":406,"line_end":406,"column_start":12,"column_end":26},"name":"get_i16_writer","qualname":"<WavWriter<W>>::get_i16_writer","value":"fn <'s> (&'s mut self, num_samples: u32) -> SampleWriter16<'s, W>","parent":null,"children":[],"decl_id":null,"docs":" Create an efficient writer that writes 16-bit integer samples only.\n\n When it is known what the kind of samples will be, many dynamic checks\n can be omitted. Furthermore, this writer employs buffering internally,\n which allows omitting return value checks except on flush. The internal\n buffer will be sized such that exactly `num_samples` samples can be\n written to it, and the buffer is recycled across calls to\n `get_i16_writer()` if the previous buffer was sufficiently large.\n\n # Panics\n\n Panics if the spec does not match a 16 bits per sample integer format.\n\n Attempting to write more than `num_samples` samples to the writer will\n panic too.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":213},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":89685,"byte_end":89690,"line_start":479,"line_end":479,"column_start":12,"column_end":17},"name":"flush","qualname":"<WavWriter<W>>::flush","value":"fn (&mut self) -> Result<()>","parent":null,"children":[],"decl_id":null,"docs":" Updates the WAVE header and flushes the underlying writer.\n\n Flush writes the WAVE header to the underlying writer to make the\n written bytes a valid wav file, and then flushes the writer. It is still\n possible to write more samples after flushing.\n\n Flush can be used for “checkpointing”. Even if after the flush there is\n an IO error or the writing process dies, the file can still be read by a\n compliant decoder up to the last flush.\n\n Note that if the number of samples written is not a multiple of the\n channel count, the intermediate wav file will not be valid. In that case\n `flush()` will still flush the data and write the (invalid) wav file,\n but `Error::UnfinishedSample` will be returned afterwards.\n\n It is not necessary to call `finalize()` directly after `flush()`, if no\n samples have been written after flushing.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":214},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":90266,"byte_end":90274,"line_start":492,"line_end":492,"column_start":12,"column_end":20},"name":"finalize","qualname":"<WavWriter<W>>::finalize","value":"fn (mut self) -> Result<()>","parent":null,"children":[],"decl_id":null,"docs":" Updates the WAVE header (which requires knowing all samples).\n\n This method must be called after all samples have been written. If it\n is not called, the destructor will finalize the file, but any errors\n that occur in the process cannot be observed in that manner.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":215},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":91006,"byte_end":91010,"line_start":509,"line_end":509,"column_start":12,"column_end":16},"name":"spec","qualname":"<WavWriter<W>>::spec","value":"fn (&self) -> WavSpec","parent":null,"children":[],"decl_id":null,"docs":" Returns information about the WAVE file being written.\n\n This is the same spec that was passed to `WavWriter::new()`. For a\n writer constructed with `WavWriter::new_append()` or\n `WavWriter::append()`, this method returns the spec of the file being\n appended to.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":216},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":91344,"byte_end":91352,"line_start":518,"line_end":518,"column_start":12,"column_end":20},"name":"duration","qualname":"<WavWriter<W>>::duration","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the duration of the file written so far, in samples.\n\n The duration is independent of the number of channels. It is expressed\n in units of samples. The duration in seconds can be obtained by\n dividing this number by the sample rate.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":217},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":91652,"byte_end":91655,"line_start":526,"line_end":526,"column_start":12,"column_end":15},"name":"len","qualname":"<WavWriter<W>>::len","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of samples in the file written so far.\n\n The length of the file is its duration (in samples) times the number of\n channels.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":224},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":94112,"byte_end":94118,"line_start":597,"line_end":597,"column_start":12,"column_end":18},"name":"create","qualname":"<WavWriter<io::BufWriter<fs::File>>>::create","value":"fn <P> (filename: P, spec: WavSpec) -> Result<WavWriter<io::BufWriter<fs::File>>>","parent":null,"children":[],"decl_id":null,"docs":" Creates a writer that writes the WAVE format to a file.\n\n This is a convenience constructor that creates the file, wraps it in a\n `BufWriter`, and then constructs a `WavWriter` from it. The file will\n be overwritten if it exists.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":226},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":94847,"byte_end":94853,"line_start":612,"line_end":612,"column_start":12,"column_end":18},"name":"append","qualname":"<WavWriter<io::BufWriter<fs::File>>>::append","value":"fn <P> (filename: P) -> Result<WavWriter<io::BufWriter<fs::File>>>","parent":null,"children":[],"decl_id":null,"docs":" Creates a writer that appends samples to an existing file.\n\n This is a convenience constructor that opens the file in append mode,\n reads its header using a buffered reader, and then constructs an\n appending `WavWriter` that writes to the file using a `BufWriter`.\n\n See `WavWriter::new_append()` for more details about append behavior.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":230},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":96681,"byte_end":96691,"line_start":654,"line_end":654,"column_start":12,"column_end":22},"name":"new_append","qualname":"<WavWriter<W>>::new_append","value":"fn (mut writer: W) -> Result<WavWriter<W>>","parent":null,"children":[],"decl_id":null,"docs":" Creates a writer that appends samples to an existing file stream.\n\n This first reads the existing header to obtain the spec, then seeks to\n the end of the writer. The writer then appends new samples to the end of\n the stream.\n\n The underlying writer is assumed to be at offset 0.\n\n If the existing file includes a fact chunk, it will not be updated after\n appending, and hence become outdated. For files produced by Hound this\n is not an issue, because Hound never writes a fact chunk. For all the\n formats that Hound can write, the fact chunk is redundant.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":231},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":98128,"byte_end":98142,"line_start":688,"line_end":688,"column_start":12,"column_end":26},"name":"SampleWriter16","qualname":"::write::SampleWriter16","value":"SampleWriter16 {  }","parent":null,"children":[{"krate":0,"index":234},{"krate":0,"index":235},{"krate":0,"index":236},{"krate":0,"index":237}],"decl_id":null,"docs":" A writer that specifically only writes integer samples of 16 bits per sample.\n\n The writer buffers written samples internally so they can be written in a\n single batch later on. This has two advantages when performance is\n important:\n\n  * There is no need for error handling during writing, only on flush. This\n    eliminates a lot of branches.\n  * The buffer can be written once, which reduces the overhead of the write\n    call. Because writing to an `io::BufWriter` is implemented with a\n    `memcpy` (even for single bytes), there is a large overhead to writing\n    small amounts of data such as a 16-bit sample. By writing large blocks\n    (or by not using `BufWriter`) this overhead can be avoided.\n\n A `SampleWriter16` can be obtained by calling [`WavWriter::get_i16_writer`](\n struct.WavWriter.html#method.get_i16_writer).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":241},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":99366,"byte_end":99378,"line_start":717,"line_end":717,"column_start":12,"column_end":24},"name":"write_sample","qualname":"<SampleWriter16>::write_sample","value":"fn <S> (&mut self, sample: S) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Writes a single sample for one channel.\n\n WAVE interleaves channel data, so the channel that this writes the\n sample to depends on previous writes.\n\n Unlike `WavWriter::write_sample()`, no range check is performed. Only\n the least significant 16 bits are considered, everything else is\n discarded.  Apart from that check, this method is more efficient than\n `WavWriter::write_sample()`, because it can avoid dispatching on the\n number of bits. That was done already when the `SampleWriter16` was\n constructed.\n\n Note that nothing is actually written until `flush()` is called.\n","sig":null,"attributes":[{"value":"inline(always)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":99337,"byte_end":99354,"line_start":716,"line_end":716,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":245},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":100924,"byte_end":100946,"line_start":754,"line_end":754,"column_start":19,"column_end":41},"name":"write_sample_unchecked","qualname":"<SampleWriter16>::write_sample_unchecked","value":"fn <S> (&mut self, sample: S) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Like `write_sample()`, but does not perform a bounds check when writing\n to the internal buffer.\n\n It is the responsibility of the programmer to ensure that no more\n samples are written than allocated when the writer was created.\n","sig":null,"attributes":[{"value":"inline(always)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":100888,"byte_end":100905,"line_start":753,"line_end":753,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":247},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":101321,"byte_end":101326,"line_start":765,"line_end":765,"column_start":12,"column_end":17},"name":"flush","qualname":"<SampleWriter16>::flush","value":"fn (self) -> Result<()>","parent":null,"children":[],"decl_id":null,"docs":" Flush the internal buffer to the underlying writer.\n\n # Panics\n\n Panics if insufficient samples (less than specified when the writer was\n constructed) have been written with `write_sample()`.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":256},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2599,"byte_end":2605,"line_start":79,"line_end":79,"column_start":11,"column_end":17},"name":"Sample","qualname":"::Sample","value":"Sample: Sized","parent":null,"children":[{"krate":0,"index":257},{"krate":0,"index":259},{"krate":0,"index":261}],"decl_id":null,"docs":" A type that can be used to represent audio samples.\n\n Via this trait, decoding can be generic over `i8`, `i16`, `i32` and `f32`.\n\n All integer formats with bit depths up to 32 bits per sample can be decoded\n into `i32`, but it takes up more memory. If you know beforehand that you\n will be reading a file with 16 bits per sample, then decoding into an `i16`\n will be sufficient.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":257},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2678,"byte_end":2683,"line_start":81,"line_end":81,"column_start":8,"column_end":13},"name":"write","qualname":"::Sample::write","value":"fn <W> (self, writer: &mut W, bits: u16) -> Result<()>","parent":{"krate":0,"index":256},"children":[],"decl_id":null,"docs":" Writes the audio sample to the WAVE data chunk.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":259},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2811,"byte_end":2815,"line_start":84,"line_end":84,"column_start":8,"column_end":12},"name":"read","qualname":"::Sample::read","value":"fn <R> (reader: &mut R, SampleFormat, bytes: u16, bits: u16) -> Result<Self>","parent":{"krate":0,"index":256},"children":[],"decl_id":null,"docs":" Reads the audio sample from the WAVE data chunk.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":261},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":3137,"byte_end":3143,"line_start":91,"line_end":91,"column_start":8,"column_end":14},"name":"as_i16","qualname":"::Sample::as_i16","value":"fn (self) -> i16","parent":{"krate":0,"index":256},"children":[],"decl_id":null,"docs":" Cast the sample to a 16-bit sample.\n\n This does not change the value of the sample, it only casts it. The\n value is assumed to fit within the range. This is not verified,\n truncation may occur.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":316},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":9824,"byte_end":9829,"line_start":298,"line_end":298,"column_start":5,"column_end":10},"name":"Float","qualname":"::SampleFormat::Float","value":"SampleFormat::Float","parent":{"krate":0,"index":315},"children":[],"decl_id":null,"docs":" Wave files with the `WAVE_FORMAT_IEEE_FLOAT` format tag store samples as floating point\n values.\n\n Values are normally in the range [-1.0, 1.0].\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":318},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":9925,"byte_end":9928,"line_start":300,"line_end":300,"column_start":5,"column_end":8},"name":"Int","qualname":"::SampleFormat::Int","value":"SampleFormat::Int","parent":{"krate":0,"index":315},"children":[],"decl_id":null,"docs":" Wave files with the `WAVE_FORMAT_PCM` format tag store samples as integer values.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":315},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":9631,"byte_end":9643,"line_start":293,"line_end":293,"column_start":10,"column_end":22},"name":"SampleFormat","qualname":"::SampleFormat","value":"SampleFormat::{Float, Int}","parent":null,"children":[{"krate":0,"index":316},{"krate":0,"index":318}],"decl_id":null,"docs":" Specifies whether a sample is stored as an \"IEEE Float\" or an integer.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":331},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10033,"byte_end":10040,"line_start":305,"line_end":305,"column_start":12,"column_end":19},"name":"WavSpec","qualname":"::WavSpec","value":"WavSpec { channels, sample_rate, bits_per_sample, sample_format }","parent":null,"children":[{"krate":0,"index":332},{"krate":0,"index":333},{"krate":0,"index":334},{"krate":0,"index":335}],"decl_id":null,"docs":" Specifies properties of the audio data.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":332},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10083,"byte_end":10091,"line_start":307,"line_end":307,"column_start":9,"column_end":17},"name":"channels","qualname":"::WavSpec::channels","value":"u16","parent":{"krate":0,"index":331},"children":[],"decl_id":null,"docs":" The number of channels.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":333},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10235,"byte_end":10246,"line_start":312,"line_end":312,"column_start":9,"column_end":20},"name":"sample_rate","qualname":"::WavSpec::sample_rate","value":"u32","parent":{"krate":0,"index":331},"children":[],"decl_id":null,"docs":" The number of samples per second.\n\n A common value is 44100, this is 44.1 kHz which is used for CD audio.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":334},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10383,"byte_end":10398,"line_start":317,"line_end":317,"column_start":9,"column_end":24},"name":"bits_per_sample","qualname":"::WavSpec::bits_per_sample","value":"u16","parent":{"krate":0,"index":331},"children":[],"decl_id":null,"docs":" The number of bits per sample.\n\n A common value is 16 bits per sample, which is used for CD audio.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":335},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10477,"byte_end":10490,"line_start":320,"line_end":320,"column_start":9,"column_end":22},"name":"sample_format","qualname":"::WavSpec::sample_format","value":"SampleFormat","parent":{"krate":0,"index":331},"children":[],"decl_id":null,"docs":" Whether the wav's samples are float or integer values.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":349},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10677,"byte_end":10684,"line_start":327,"line_end":327,"column_start":5,"column_end":12},"name":"IoError","qualname":"::Error::IoError","value":"Error::IoError(io::Error)","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" An IO error occured in the underlying reader or writer.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":352},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10747,"byte_end":10758,"line_start":329,"line_end":329,"column_start":5,"column_end":16},"name":"FormatError","qualname":"::Error::FormatError","value":"Error::FormatError(&'static str)","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" Ill-formed WAVE data was encountered.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":355},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11152,"byte_end":11159,"line_start":336,"line_end":336,"column_start":5,"column_end":12},"name":"TooWide","qualname":"::Error::TooWide","value":"Error::TooWide","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" The sample has more bits than the destination type.\n\n When iterating using the `samples` iterator, this means that the\n destination type (produced by the iterator) is not wide enough to hold\n the sample. When writing, this means that the sample cannot be written,\n because it requires more bits than the bits per sample specified.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":357},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11248,"byte_end":11264,"line_start":338,"line_end":338,"column_start":5,"column_end":21},"name":"UnfinishedSample","qualname":"::Error::UnfinishedSample","value":"Error::UnfinishedSample","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" The number of samples written is not a multiple of the number of channels.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":359},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11307,"byte_end":11318,"line_start":340,"line_end":340,"column_start":5,"column_end":16},"name":"Unsupported","qualname":"::Error::Unsupported","value":"Error::Unsupported","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" The format is not supported.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":361},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11809,"byte_end":11828,"line_start":350,"line_end":350,"column_start":5,"column_end":24},"name":"InvalidSampleFormat","qualname":"::Error::InvalidSampleFormat","value":"Error::InvalidSampleFormat","parent":{"krate":0,"index":348},"children":[],"decl_id":null,"docs":" The sample format is different than the destination format.\n\n When iterating using the `samples` iterator, this means the destination\n type (produced by the iterator) has a different sample format than the\n samples in the wav file.\n\n For example, this will occur if the user attempts to produce `i32`\n samples (which have a `SampleFormat::Int`) from a wav file that\n contains floating point data (`SampleFormat::Float`).\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":348},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":10601,"byte_end":10606,"line_start":325,"line_end":325,"column_start":10,"column_end":15},"name":"Error","qualname":"::Error","value":"Error::{IoError, FormatError, TooWide, UnfinishedSample, Unsupported, InvalidSampleFormat}","parent":null,"children":[{"krate":0,"index":349},{"krate":0,"index":352},{"krate":0,"index":355},{"krate":0,"index":357},{"krate":0,"index":359},{"krate":0,"index":361}],"decl_id":null,"docs":" The error type for operations on `WavReader` and `WavWriter`.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":300},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":13974,"byte_end":13980,"line_start":409,"line_end":409,"column_start":10,"column_end":16},"name":"Result","qualname":"::Result","value":"result::Result<T, Error>","parent":null,"children":[],"decl_id":null,"docs":" A type for results generated by Hound where the error type is hard-wired.\n","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":28933,"byte_end":28934,"line_start":70,"line_end":70,"column_start":21,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":37},{"krate":0,"index":38},{"krate":0,"index":40},{"krate":0,"index":41},{"krate":0,"index":43},{"krate":0,"index":45},{"krate":0,"index":47},{"krate":0,"index":49},{"krate":0,"index":51},{"krate":0,"index":53},{"krate":0,"index":55},{"krate":0,"index":57}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":38294,"byte_end":38303,"line_start":334,"line_end":334,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":95},{"krate":0,"index":97},{"krate":0,"index":102},{"krate":0,"index":103},{"krate":0,"index":104},{"krate":0,"index":106},{"krate":0,"index":107},{"krate":0,"index":108},{"krate":0,"index":111},{"krate":0,"index":113},{"krate":0,"index":114},{"krate":0,"index":115},{"krate":0,"index":116}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":54075,"byte_end":54084,"line_start":717,"line_end":717,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":118}],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55314,"byte_end":55324,"line_start":750,"line_end":750,"column_start":30,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":129},{"krate":0,"index":130},{"krate":0,"index":131}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55634,"byte_end":55644,"line_start":765,"line_end":765,"column_start":39,"column_end":49},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55728,"byte_end":55742,"line_start":771,"line_end":771,"column_start":25,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":139},{"krate":0,"index":140},{"krate":0,"index":141}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":56042,"byte_end":56056,"line_start":786,"line_end":786,"column_start":34,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":73490,"byte_end":73491,"line_start":55,"line_end":55,"column_start":22,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":172},{"krate":0,"index":173},{"krate":0,"index":174},{"krate":0,"index":176},{"krate":0,"index":177},{"krate":0,"index":179},{"krate":0,"index":180},{"krate":0,"index":182}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":77014,"byte_end":77023,"line_start":173,"line_end":173,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":202},{"krate":0,"index":203},{"krate":0,"index":205},{"krate":0,"index":206},{"krate":0,"index":207},{"krate":0,"index":208},{"krate":0,"index":210},{"krate":0,"index":212},{"krate":0,"index":213},{"krate":0,"index":214},{"krate":0,"index":215},{"krate":0,"index":216},{"krate":0,"index":217}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":91761,"byte_end":91770,"line_start":531,"line_end":531,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":220}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":93798,"byte_end":93807,"line_start":591,"line_end":591,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":224},{"krate":0,"index":226}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":95971,"byte_end":95980,"line_start":641,"line_end":641,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":230}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":98635,"byte_end":98649,"line_start":702,"line_end":702,"column_start":40,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":241},{"krate":0,"index":243},{"krate":0,"index":245},{"krate":0,"index":247}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11855,"byte_end":11860,"line_start":353,"line_end":353,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":294}],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":12856,"byte_end":12861,"line_start":378,"line_end":378,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":296},{"krate":0,"index":297}],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":13803,"byte_end":13808,"line_start":402,"line_end":402,"column_start":26,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":299}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":27018,"byte_end":27022,"line_start":24,"line_end":24,"column_start":24,"column_end":28},"kind":"SuperTrait","from":{"krate":1,"index":2849},"to":{"krate":0,"index":22}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":28933,"byte_end":28934,"line_start":70,"line_end":70,"column_start":21,"column_end":22},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":36},"to":{"krate":0,"index":22}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":38294,"byte_end":38303,"line_start":334,"line_end":334,"column_start":9,"column_end":18},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":71},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":54075,"byte_end":54084,"line_start":717,"line_end":717,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":71},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55314,"byte_end":55324,"line_start":750,"line_end":750,"column_start":30,"column_end":40},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":78},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55634,"byte_end":55644,"line_start":765,"line_end":765,"column_start":39,"column_end":49},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":78},"to":{"krate":2,"index":3939}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":55728,"byte_end":55742,"line_start":771,"line_end":771,"column_start":25,"column_end":39},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":84},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\read.rs","byte_start":56042,"byte_end":56056,"line_start":786,"line_end":786,"column_start":34,"column_end":48},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":84},"to":{"krate":2,"index":3939}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":72369,"byte_end":72374,"line_start":25,"line_end":25,"column_start":25,"column_end":30},"kind":"SuperTrait","from":{"krate":1,"index":2903},"to":{"krate":0,"index":161}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":73490,"byte_end":73491,"line_start":55,"line_end":55,"column_start":22,"column_end":23},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":171},"to":{"krate":0,"index":161}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":77014,"byte_end":77023,"line_start":173,"line_end":173,"column_start":9,"column_end":18},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":186},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":91761,"byte_end":91770,"line_start":531,"line_end":531,"column_start":18,"column_end":27},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":186},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":93798,"byte_end":93807,"line_start":591,"line_end":591,"column_start":6,"column_end":15},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":186},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":95971,"byte_end":95980,"line_start":641,"line_end":641,"column_start":9,"column_end":18},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":186},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\write.rs","byte_start":98635,"byte_end":98649,"line_start":702,"line_end":702,"column_start":40,"column_end":54},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":231},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":2607,"byte_end":2612,"line_start":79,"line_end":79,"column_start":19,"column_end":24},"kind":"SuperTrait","from":{"krate":2,"index":1538},"to":{"krate":0,"index":256}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":11855,"byte_end":11860,"line_start":353,"line_end":353,"column_start":23,"column_end":28},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":348},"to":{"krate":2,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":12856,"byte_end":12861,"line_start":378,"line_end":378,"column_start":23,"column_end":28},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":348},"to":{"krate":1,"index":1616}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\hound-3.4.0\\src\\lib.rs","byte_start":13803,"byte_end":13808,"line_start":402,"line_end":402,"column_start":26,"column_end":31},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":348},"to":{"krate":2,"index":2258}}]}