{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--crate-name","scopeguard","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","-C","metadata=f88443e170f6b83d","-C","extra-filename=-f88443e170f6b83d","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--cap-lints","allow","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libscopeguard-f88443e170f6b83d.rmeta"},"prelude":{"crate_id":{"name":"scopeguard","disambiguator":[8293681837284562385,10699146686669501925]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","num":1,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","num":2,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","num":3,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":0,"byte_end":17302,"line_start":1,"line_end":578,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":0,"byte_end":17302,"line_start":1,"line_end":578,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":7},{"krate":0,"index":10},{"krate":0,"index":13},{"krate":0,"index":14},{"krate":0,"index":60},{"krate":0,"index":61},{"krate":0,"index":16},{"krate":0,"index":18},{"krate":0,"index":19},{"krate":0,"index":26},{"krate":0,"index":32},{"krate":0,"index":35},{"krate":0,"index":39},{"krate":0,"index":45},{"krate":0,"index":50},{"krate":0,"index":55}],"decl_id":null,"docs":" A scope guard will run a given closure when it goes out of scope,\n even if the code between panics.\n (as long as panic doesn't abort)\n\n # Examples\n\n ## Hello World\n\n This example creates a scope guard with an example function:\n\n ```\n extern crate scopeguard;\n\n fn f() {\n     let _guard = scopeguard::guard((), |_| {\n         println!(\"Hello Scope Exit!\");\n     });\n\n     // rest of the code here.\n\n     // Here, at the end of `_guard`'s scope, the guard's closure is called.\n     // It is also called if we exit this scope through unwinding instead.\n }\n # fn main() {\n #    f();\n # }\n ```\n\n ## `defer!`\n\n Use the `defer` macro to run an operation at scope exit,\n either regular scope exit or during unwinding from a panic.\n\n ```\n #[macro_use(defer)] extern crate scopeguard;\n\n use std::cell::Cell;\n\n fn main() {\n     // use a cell to observe drops during and after the scope guard is active\n     let drop_counter = Cell::new(0);\n     {\n         // Create a scope guard using `defer!` for the current scope\n         defer! {{\n             drop_counter.set(1 + drop_counter.get());\n         }};\n\n         // Do regular operations here in the meantime.\n\n         // Just before scope exit: it hasn't run yet.\n         assert_eq!(drop_counter.get(), 0);\n\n         // The following scope end is where the defer closure is called\n     }\n     assert_eq!(drop_counter.get(), 1);\n }\n ```\n\n ## Scope Guard with Value\n\n If the scope guard closure needs to access an outer value that is also\n mutated outside of the scope guard, then you may want to use the scope guard\n with a value. The guard works like a smart pointer, so the inner value can\n be accessed by reference or by mutable reference.\n\n ### 1. The guard owns a file\n\n In this example, the scope guard owns a file and ensures pending writes are\n synced at scope exit.\n\n ```\n extern crate scopeguard;\n \n use std::fs::*;\n use std::io::{self, Write};\n # // Mock file so that we don't actually write a file\n # struct MockFile;\n # impl MockFile {\n #     fn create(_s: &str) -> io::Result<Self> { Ok(MockFile) }\n #     fn write_all(&self, _b: &[u8]) -> io::Result<()> { Ok(()) }\n #     fn sync_all(&self) -> io::Result<()> { Ok(()) }\n # }\n # use self::MockFile as File;\n \n fn try_main() -> io::Result<()> {\n     let f = File::create(\"newfile.txt\")?;\n     let mut file = scopeguard::guard(f, |f| {\n         // ensure we flush file at return or panic\n         let _ = f.sync_all();\n     });\n     // Access the file through the scope guard itself\n     file.write_all(b\"test me\\n\").map(|_| ())\n }\n\n fn main() {\n     try_main().unwrap();\n }\n\n ```\n\n ### 2. The guard restores an invariant on scope exit\n\n ```\n extern crate scopeguard;\n\n use std::mem::ManuallyDrop;\n use std::ptr;\n\n // This function, just for this example, takes the first element\n // and inserts it into the assumed sorted tail of the vector.\n //\n // For optimization purposes we temporarily violate an invariant of the\n // Vec, that it owns all of its elements.\n // \n // The safe approach is to use swap, which means two writes to memory,\n // the optimization is to use a “hole” which uses only one write of memory\n // for each position it moves.\n //\n // We *must* use a scope guard to run this code safely. We\n // are running arbitrary user code (comparison operators) that may panic.\n // The scope guard ensures we restore the invariant after successful\n // exit or during unwinding from panic.\n fn insertion_sort_first<T>(v: &mut Vec<T>)\n     where T: PartialOrd\n {\n     struct Hole<'a, T: 'a> {\n         v: &'a mut Vec<T>,\n         index: usize,\n         value: ManuallyDrop<T>,\n     }\n\n     unsafe {\n         // Create a moved-from location in the vector, a “hole”.\n         let value = ptr::read(&v[0]);\n         let mut hole = Hole { v: v, index: 0, value: ManuallyDrop::new(value) };\n\n         // Use a scope guard with a value.\n         // At scope exit, plug the hole so that the vector is fully\n         // initialized again.\n         // The scope guard owns the hole, but we can access it through the guard.\n         let mut hole_guard = scopeguard::guard(hole, |hole| {\n             // plug the hole in the vector with the value that was // taken out\n             let index = hole.index;\n             ptr::copy_nonoverlapping(&*hole.value, &mut hole.v[index], 1);\n         });\n\n         // run algorithm that moves the hole in the vector here\n         // move the hole until it's in a sorted position\n         for i in 1..hole_guard.v.len() {\n             if *hole_guard.value >= hole_guard.v[i] {\n                 // move the element back and the hole forward\n                 let index = hole_guard.index;\n                 ptr::copy_nonoverlapping(&hole_guard.v[index + 1], &mut hole_guard.v[index], 1);\n                 hole_guard.index += 1;\n             } else {\n                 break;\n             }\n         }\n\n         // When the scope exits here, the Vec becomes whole again!\n     }\n }\n\n fn main() {\n     let string = String::from;\n     let mut data = vec![string(\"c\"), string(\"a\"), string(\"b\"), string(\"d\")];\n     insertion_sort_first(&mut data);\n     assert_eq!(data, vec![\"a\", \"b\", \"c\", \"d\"]);\n }\n\n ```\n\n\n # Crate Features\n\n - `use_std`\n   + Enabled by default. Enables the `OnUnwind` and `OnSuccess` strategies.\n   + Disable to use `no_std`.\n\n # Rust Version\n\n This version of the crate requires Rust 1.20 or later.\n\n The scopeguard 1.x release series will use a carefully considered version\n upgrade policy, where in a later 1.x version, we will raise the minimum\n required Rust version.\n","sig":null,"attributes":[{"value":"no_std","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":49,"byte_end":55,"line_start":1,"line_end":1,"column_start":50,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":14},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":6477,"byte_end":6485,"line_start":201,"line_end":201,"column_start":11,"column_end":19},"name":"Strategy","qualname":"::Strategy","value":"Strategy","parent":null,"children":[{"krate":0,"index":15}],"decl_id":null,"docs":" Controls in which cases the associated code should be run\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":15},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":6615,"byte_end":6625,"line_start":204,"line_end":204,"column_start":8,"column_end":18},"name":"should_run","qualname":"::Strategy::should_run","value":"fn () -> bool","parent":{"krate":0,"index":14},"children":[],"decl_id":null,"docs":" Return `true` if the guard’s associated code should run\n (in the context where this method is called).\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":60},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":6886,"byte_end":6892,"line_start":213,"line_end":213,"column_start":10,"column_end":16},"name":"Always","qualname":"::Always","value":"Always::{}","parent":null,"children":[],"decl_id":null,"docs":" Always run on scope exit.\n\n “Always” run: on regular exit from a scope or on unwinding from a panic.\n Can not run on abort, process exit, and other catastrophic events where\n destructors don’t run.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":19},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":9343,"byte_end":9353,"line_start":301,"line_end":301,"column_start":12,"column_end":22},"name":"ScopeGuard","qualname":"::ScopeGuard","value":"ScopeGuard {  }","parent":null,"children":[{"krate":0,"index":23},{"krate":0,"index":24},{"krate":0,"index":25}],"decl_id":null,"docs":" `ScopeGuard` is a scope guard that may own a protected value.\n\n If you place a guard in a local variable, the closure can\n run regardless how you leave the scope — through regular return or panic\n (except if panic or other code aborts; so as long as destructors run).\n It is run only once.\n\n The `S` parameter for [`Strategy`](Strategy.t.html) determines if\n the closure actually runs.\n\n The guard's closure will be called with the held value in the destructor.\n\n The `ScopeGuard` implements `Deref` so that you can access the inner value.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":30},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":9837,"byte_end":9850,"line_start":319,"line_end":319,"column_start":12,"column_end":25},"name":"with_strategy","qualname":"<ScopeGuard<T, F, S>>::with_strategy","value":"fn (v: T, dropfn: F) -> ScopeGuard<T, F, S>","parent":null,"children":[],"decl_id":null,"docs":" Create a `ScopeGuard` that owns `v` (accessible through deref) and calls\n `dropfn` when its destructor runs.\n\n The `Strategy` decides whether the scope guard's closure should run.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":9816,"byte_end":9825,"line_start":318,"line_end":318,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":31},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":10770,"byte_end":10780,"line_start":349,"line_end":349,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<ScopeGuard<T, F, S>>::into_inner","value":"fn (guard: Self) -> T","parent":null,"children":[],"decl_id":null,"docs":" “Defuse” the guard and extract the value without calling the closure.\n\n ```\n extern crate scopeguard;\n use scopeguard::{guard, ScopeGuard};\n\n fn conditional() -> bool { true }\n\n fn main() {\n     let mut guard = guard(Vec::new(), |mut v| v.clear());\n     guard.push(1);\n     \n     if conditional() {\n         // a condition maybe makes us decide to\n         // “defuse” the guard and get back its inner parts\n         let value = ScopeGuard::into_inner(guard);\n     } else {\n         // guard still exists in this branch\n     }\n }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":10749,"byte_end":10758,"line_start":348,"line_end":348,"column_start":5,"column_end":14}}]},{"kind":"Function","id":{"krate":0,"index":32},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":11500,"byte_end":11505,"line_start":368,"line_end":368,"column_start":8,"column_end":13},"name":"guard","qualname":"::guard","value":"fn <T, F> (v: T, dropfn: F) -> ScopeGuard<T, F, Always>","parent":null,"children":[],"decl_id":null,"docs":" Create a new `ScopeGuard` owning `v` and with deferred closure `dropfn`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":11483,"byte_end":11492,"line_start":367,"line_end":367,"column_start":1,"column_end":10}}]}],"impls":[{"id":0,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":7226,"byte_end":7232,"line_start":229,"line_end":229,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":17}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":9534,"byte_end":9544,"line_start":310,"line_end":310,"column_start":15,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":30},{"krate":0,"index":31}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13119,"byte_end":13129,"line_start":423,"line_end":423,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13233,"byte_end":13243,"line_start":429,"line_end":429,"column_start":25,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":43},{"krate":0,"index":44}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13407,"byte_end":13417,"line_start":439,"line_end":439,"column_start":28,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":49}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13571,"byte_end":13581,"line_start":448,"line_end":448,"column_start":24,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":54}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13997,"byte_end":14007,"line_start":464,"line_end":464,"column_start":30,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":59}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":7226,"byte_end":7232,"line_start":229,"line_end":229,"column_start":19,"column_end":25},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":60},"to":{"krate":0,"index":14}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":9534,"byte_end":9544,"line_start":310,"line_end":310,"column_start":15,"column_end":25},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":19},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13119,"byte_end":13129,"line_start":423,"line_end":423,"column_start":31,"column_end":41},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13233,"byte_end":13243,"line_start":429,"line_end":429,"column_start":25,"column_end":35},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13407,"byte_end":13417,"line_start":439,"line_end":439,"column_start":28,"column_end":38},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":1715}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13571,"byte_end":13581,"line_start":448,"line_end":448,"column_start":24,"column_end":34},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\scopeguard-1.0.0\\src\\lib.rs","byte_start":13997,"byte_end":14007,"line_start":464,"line_end":464,"column_start":30,"column_end":40},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":19},"to":{"krate":1,"index":7643}}]}