{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--edition=2018","--crate-name","slice_deque","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"use_std\"","-C","metadata=1d201548ae58eb3e","-C","extra-filename=-1d201548ae58eb3e","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--extern","winapi=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libwinapi-978bfab176c482d4.rmeta","--cap-lints","allow","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libslice_deque-1d201548ae58eb3e.rmeta"},"prelude":{"crate_id":{"name":"slice_deque","disambiguator":[5204407757764599047,5952320756823334924]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":1,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":2,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","num":14,"id":{"name":"winapi","disambiguator":[5636639422687459420,15773350436437932257]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":0,"byte_end":171925,"line_start":1,"line_end":5956,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":99},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":6124,"byte_end":6134,"line_start":166,"line_end":166,"column_start":20,"column_end":30},"alias_span":null,"name":"AllocError","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":20},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":6136,"byte_end":6142,"line_start":166,"line_end":166,"column_start":32,"column_end":38},"alias_span":null,"name":"Buffer","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":2,"index":1168},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":9225,"byte_end":9231,"line_start":277,"line_end":277,"column_start":14,"column_end":20},"alias_span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":9235,"byte_end":9247,"line_start":277,"line_end":277,"column_start":24,"column_end":36},"name":"__mem_forget","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":0,"byte_end":171925,"line_start":1,"line_end":5956,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":14},{"krate":0,"index":15},{"krate":0,"index":16},{"krate":0,"index":106},{"krate":0,"index":109},{"krate":0,"index":120},{"krate":0,"index":121},{"krate":0,"index":128},{"krate":0,"index":130},{"krate":0,"index":133},{"krate":0,"index":135},{"krate":0,"index":137},{"krate":0,"index":141},{"krate":0,"index":143},{"krate":0,"index":145},{"krate":0,"index":146},{"krate":0,"index":147},{"krate":0,"index":216},{"krate":0,"index":220},{"krate":0,"index":223},{"krate":0,"index":229},{"krate":0,"index":232},{"krate":0,"index":235},{"krate":0,"index":239},{"krate":0,"index":242},{"krate":0,"index":245},{"krate":0,"index":249},{"krate":0,"index":253},{"krate":0,"index":257},{"krate":0,"index":261},{"krate":0,"index":453},{"krate":0,"index":459},{"krate":0,"index":465},{"krate":0,"index":471},{"krate":0,"index":262},{"krate":0,"index":477},{"krate":0,"index":485},{"krate":0,"index":493},{"krate":0,"index":501},{"krate":0,"index":509},{"krate":0,"index":517},{"krate":0,"index":525},{"krate":0,"index":533},{"krate":0,"index":541},{"krate":0,"index":549},{"krate":0,"index":557},{"krate":0,"index":565},{"krate":0,"index":573},{"krate":0,"index":581},{"krate":0,"index":589},{"krate":0,"index":597},{"krate":0,"index":605},{"krate":0,"index":613},{"krate":0,"index":621},{"krate":0,"index":629},{"krate":0,"index":637},{"krate":0,"index":645},{"krate":0,"index":653},{"krate":0,"index":661},{"krate":0,"index":669},{"krate":0,"index":677},{"krate":0,"index":685},{"krate":0,"index":693},{"krate":0,"index":701},{"krate":0,"index":709},{"krate":0,"index":717},{"krate":0,"index":725},{"krate":0,"index":733},{"krate":0,"index":741},{"krate":0,"index":749},{"krate":0,"index":757},{"krate":0,"index":765},{"krate":0,"index":773},{"krate":0,"index":781},{"krate":0,"index":789},{"krate":0,"index":797},{"krate":0,"index":805},{"krate":0,"index":813},{"krate":0,"index":821},{"krate":0,"index":829},{"krate":0,"index":837},{"krate":0,"index":845},{"krate":0,"index":853},{"krate":0,"index":861},{"krate":0,"index":869},{"krate":0,"index":877},{"krate":0,"index":885},{"krate":0,"index":893},{"krate":0,"index":901},{"krate":0,"index":909},{"krate":0,"index":917},{"krate":0,"index":925},{"krate":0,"index":933},{"krate":0,"index":941},{"krate":0,"index":949},{"krate":0,"index":957},{"krate":0,"index":965},{"krate":0,"index":973},{"krate":0,"index":981},{"krate":0,"index":989},{"krate":0,"index":997},{"krate":0,"index":263},{"krate":0,"index":265},{"krate":0,"index":268},{"krate":0,"index":272},{"krate":0,"index":279},{"krate":0,"index":283},{"krate":0,"index":286},{"krate":0,"index":289},{"krate":0,"index":296},{"krate":0,"index":301},{"krate":0,"index":306},{"krate":0,"index":312},{"krate":0,"index":315},{"krate":0,"index":319},{"krate":0,"index":321},{"krate":0,"index":323},{"krate":0,"index":329},{"krate":0,"index":332},{"krate":0,"index":335},{"krate":0,"index":338},{"krate":0,"index":343},{"krate":0,"index":349},{"krate":0,"index":355},{"krate":0,"index":359},{"krate":0,"index":364},{"krate":0,"index":367},{"krate":0,"index":372},{"krate":0,"index":378},{"krate":0,"index":382},{"krate":0,"index":386},{"krate":0,"index":390},{"krate":0,"index":394},{"krate":0,"index":396},{"krate":0,"index":400},{"krate":0,"index":402},{"krate":0,"index":404},{"krate":0,"index":407},{"krate":0,"index":408},{"krate":0,"index":1005},{"krate":0,"index":1010},{"krate":0,"index":413},{"krate":0,"index":419},{"krate":0,"index":423},{"krate":0,"index":427},{"krate":0,"index":1014},{"krate":0,"index":1023},{"krate":0,"index":433},{"krate":0,"index":440},{"krate":0,"index":445},{"krate":0,"index":448}],"decl_id":null,"docs":" A double-ended queue that `Deref`s into a slice.\n\n The double-ended queue in the standard library ([`VecDeque`]) is\n implemented using a growable ring buffer (`0` represents uninitialized\n memory, and `T` represents one element in the queue):\n\n ```rust\n // [ 0 | 0 | 0 | T | T | T | 0 ]\n //               ^:head  ^:tail\n ```\n\n When the queue grows beyond the end of the allocated buffer, its tail wraps\n around:\n\n ```rust\n // [ T | T | 0 | T | T | T | T ]\n //       ^:tail  ^:head\n ```\n\n As a consequence, [`VecDeque`] cannot `Deref` into a slice, since its\n elements do not, in general, occupy a contiguous memory region. This\n complicates the implementation and its interface (for example, there is no\n `as_slice` method, but [`as_slices`] returns a pair of slices) and has\n negative performance consequences (e.g. need to account for wrap around\n while iterating over the elements).\n\n This crates provides [`SliceDeque`], a double-ended queue implemented with\n a growable *virtual* ring-buffer.\n\n A virtual ring-buffer implementation is very similar to the one used in\n `VecDeque`. The main difference is that a virtual ring-buffer maps two\n adjacent regions of virtual memory to the same region of physical memory:\n\n ```rust\n // Virtual memory:\n //\n //  __________region_0_________ __________region_1_________\n // [ 0 | 0 | 0 | T | T | T | 0 | 0 | 0 | 0 | T | T | T | 0 ]\n //               ^:head  ^:tail\n //\n // Physical memory:\n //\n // [ 0 | 0 | 0 | T | T | T | 0 ]\n //               ^:head  ^:tail\n ```\n\n That is, both the virtual memory regions `0` and `1` above (top) map to\n the same physical memory (bottom). Just like `VecDeque`, when the queue\n grows beyond the end of the allocated physical memory region, the queue\n wraps around, and new elements continue to be appended at the beginning of\n the queue. However, because `SliceDeque` maps the physical memory to two\n adjacent memory regions, in virtual memory space the queue maintais the\n ilusion of a contiguous memory layout:\n\n ```rust\n // Virtual memory:\n //\n //  __________region_0_________ __________region_1_________\n // [ T | T | 0 | T | T | T | T | T | T | 0 | T | T | T | T ]\n //               ^:head              ^:tail\n //\n // Physical memory:\n //\n // [ T | T | 0 | T | T | T | T ]\n //       ^:tail  ^:head\n ```\n\n Since processes in many Operating Systems only deal with virtual memory\n addresses, leaving the mapping to physical memory to the CPU Memory\n Management Unit (MMU), [`SliceDeque`] is able to `Deref`s into a slice in\n those systems.\n\n This simplifies [`SliceDeque`]'s API and implementation, giving it a\n performance advantage over [`VecDeque`] in some situations.\n\n In general, you can think of [`SliceDeque`] as a `Vec` with `O(1)`\n `pop_front` and amortized `O(1)` `push_front` methods.\n\n The main drawbacks of [`SliceDeque`] are:\n\n * constrained platform support: by necessity [`SliceDeque`] must use the\n platform-specific virtual memory facilities of the underlying operating\n system. While [`SliceDeque`] can work on all major operating systems,\n currently only `MacOS X` is supported.\n\n * no global allocator support: since the `Alloc`ator API does not support\n virtual memory, to use platform-specific virtual memory support\n [`SliceDeque`] must bypass the global allocator and talk directly to the\n operating system. This can have negative performance consequences since\n growing [`SliceDeque`] is always going to incur the cost of some system\n calls.\n\n * capacity constrained by virtual memory facilities: [`SliceDeque`] must\n allocate two adjacent memory regions that map to the same region of\n physical memory. Most operating systems allow this operation to be\n performed exclusively on memory pages (or memory allocations that are\n multiples of a memory page). As a consequence, the smalles [`SliceDeque`]\n that can be created has typically a capacity of 2 memory pages, and it can\n grow only to capacities that are a multiple of a memory page.\n\n The main advantages of [`SliceDeque`] are:\n\n * nicer API: since it `Deref`s to a slice, all operations that work on\n slices are available for `SliceDeque`.\n\n * efficient iteration: as efficient as for slices.\n\n * simpler serialization: since one can just serialize/deserialize a single\n slice.\n\n All in all, if your double-ended queues are small (smaller than a memory\n page) or they get resized very often, `VecDeque` can perform better than\n [`SliceDeque`]. Otherwise, [`SliceDeque`] typically performs better (see\n the benchmarks), but platform support and global allocator bypass are two\n reasons to weight in against its usage.\n\n [`VecDeque`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html\n [`as_slices`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.as_slices\n [`SliceDeque`]: struct.SliceDeque.html\n","sig":null,"attributes":[{"value":"allow(clippy :: len_without_is_empty, clippy :: shadow_reuse, clippy ::\n        cast_possible_wrap, clippy :: cast_sign_loss, clippy ::\n        cast_possible_truncation, clippy :: inline_always, clippy ::\n        indexing_slicing)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":5443,"byte_end":5669,"line_start":133,"line_end":141,"column_start":1,"column_end":3}}]},{"kind":"Struct","id":{"krate":0,"index":20},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":175570,"byte_end":175576,"line_start":19,"line_end":19,"column_start":12,"column_end":18},"name":"Buffer","qualname":"::mirrored::buffer::Buffer","value":"Buffer {  }","parent":null,"children":[{"krate":0,"index":22},{"krate":0,"index":23}],"decl_id":null,"docs":" Mirrored memory buffer of length `len`.\n\n The buffer elements in range `[0, len/2)` are mirrored into the range\n `[len/2, len)`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":26},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":175925,"byte_end":175928,"line_start":32,"line_end":32,"column_start":12,"column_end":15},"name":"len","qualname":"<Buffer<T>>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Number of elements in the buffer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":27},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":176011,"byte_end":176019,"line_start":37,"line_end":37,"column_start":12,"column_end":20},"name":"is_empty","qualname":"<Buffer<T>>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Is the buffer empty?\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":28},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":176138,"byte_end":176141,"line_start":42,"line_end":42,"column_start":19,"column_end":22},"name":"ptr","qualname":"<Buffer<T>>::ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Pointer to the first element in the buffer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":29},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":176313,"byte_end":176321,"line_start":49,"line_end":49,"column_start":19,"column_end":27},"name":"as_slice","qualname":"<Buffer<T>>::as_slice","value":"fn (&self) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Interprets contents as a slice.\n\n Warning: Some memory might be uninitialized.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":30},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":176530,"byte_end":176542,"line_start":56,"line_end":56,"column_start":19,"column_end":31},"name":"as_mut_slice","qualname":"<Buffer<T>>::as_mut_slice","value":"fn (&mut self) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Interprets contents as a mut slice.\n\n Warning: Some memory might be uninitialized.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":31},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":176809,"byte_end":176812,"line_start":63,"line_end":63,"column_start":19,"column_end":22},"name":"get","qualname":"<Buffer<T>>::get","value":"fn (&self, i: usize) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Interprets content as a slice and access the `i`-th element.\n\n Warning: The memory of the `i`-th element might be uninitialized.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":32},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":177046,"byte_end":177053,"line_start":70,"line_end":70,"column_start":19,"column_end":26},"name":"get_mut","qualname":"<Buffer<T>>::get_mut","value":"fn (&mut self, i: usize) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Interprets content as a mut slice and access the `i`-th element.\n\n Warning: The memory of the `i`-th element might be uninitialized.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":34},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":177339,"byte_end":177342,"line_start":83,"line_end":83,"column_start":12,"column_end":15},"name":"new","qualname":"<Buffer<T>>::new","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new empty `Buffer`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":35},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":177738,"byte_end":177752,"line_start":97,"line_end":97,"column_start":19,"column_end":33},"name":"from_raw_parts","qualname":"<Buffer<T>>::from_raw_parts","value":"fn (ptr: *mut T, len: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new empty `Buffer` from a `ptr` and a `len`.\n\n # Panics\n\n If `ptr` is null.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":36},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":178105,"byte_end":178118,"line_start":110,"line_end":110,"column_start":12,"column_end":25},"name":"size_in_bytes","qualname":"<Buffer<T>>::size_in_bytes","value":"fn (len: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Total number of bytes in the buffer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":37},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":178597,"byte_end":178610,"line_start":125,"line_end":125,"column_start":12,"column_end":25},"name":"uninitialized","qualname":"<Buffer<T>>::uninitialized","value":"fn (len: usize) -> Result<Self, AllocError>","parent":null,"children":[],"decl_id":null,"docs":" Create a mirrored buffer containing `len` `T`s where the first half of\n the buffer is mirrored into the second half.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":100},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\mod.rs","byte_start":174609,"byte_end":174612,"line_start":75,"line_end":75,"column_start":5,"column_end":8},"name":"Oom","qualname":"::mirrored::AllocError::Oom","value":"AllocError::Oom","parent":{"krate":0,"index":99},"children":[],"decl_id":null,"docs":" The system is Out-of-memory.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":102},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\mod.rs","byte_start":174737,"byte_end":174742,"line_start":79,"line_end":79,"column_start":5,"column_end":10},"name":"Other","qualname":"::mirrored::AllocError::Other","value":"AllocError::Other","parent":{"krate":0,"index":99},"children":[],"decl_id":null,"docs":" Other allocation errors (not out-of-memory).\n\n Race conditions, exhausted file descriptors, etc.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":99},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\mod.rs","byte_start":174555,"byte_end":174565,"line_start":73,"line_end":73,"column_start":10,"column_end":20},"name":"AllocError","qualname":"::mirrored::AllocError","value":"AllocError::{Oom, Other}","parent":null,"children":[{"krate":0,"index":100},{"krate":0,"index":102}],"decl_id":null,"docs":" Allocation error.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":137},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":8778,"byte_end":8788,"line_start":263,"line_end":263,"column_start":12,"column_end":22},"name":"SliceDeque","qualname":"::SliceDeque","value":"SliceDeque {  }","parent":null,"children":[{"krate":0,"index":139},{"krate":0,"index":140}],"decl_id":null,"docs":" A double-ended queue that derefs into a slice.\n\n It is implemented with a growable virtual ring buffer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":149},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":11730,"byte_end":11733,"line_start":367,"line_end":367,"column_start":12,"column_end":15},"name":"new","qualname":"<SliceDeque<T>>::new","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new empty deque.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let deq = SliceDeque::new();\n # let o: SliceDeque<u32> = deq;\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":11709,"byte_end":11718,"line_start":366,"line_end":366,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":150},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":12232,"byte_end":12246,"line_start":383,"line_end":383,"column_start":19,"column_end":33},"name":"from_raw_parts","qualname":"<SliceDeque<T>>::from_raw_parts","value":"fn (ptr: *mut T, capacity: usize, elems: &mut [T]) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a SliceDeque from its raw components.\n\n The `ptr` must be a pointer to the beginning of the memory buffer from\n another `SliceDeque`, `capacity` the capacity of this `SliceDeque`, and\n `elems` the elements of this `SliceDeque`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":12204,"byte_end":12213,"line_start":382,"line_end":382,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":151},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":12911,"byte_end":12924,"line_start":406,"line_end":406,"column_start":12,"column_end":25},"name":"with_capacity","qualname":"<SliceDeque<T>>::with_capacity","value":"fn (n: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Create an empty deque with capacity to hold `n` elements.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let deq = SliceDeque::with_capacity(10);\n # let o: SliceDeque<u32> = deq;\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":12890,"byte_end":12899,"line_start":405,"line_end":405,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":153},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":13734,"byte_end":13742,"line_start":434,"line_end":434,"column_start":12,"column_end":20},"name":"capacity","qualname":"<SliceDeque<T>>::capacity","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of elements that the deque can hold without\n reallocating.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let deq = SliceDeque::with_capacity(10);\n assert!(deq.capacity() >= 10);\n # let o: SliceDeque<u32> = deq;\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":13713,"byte_end":13722,"line_start":433,"line_end":433,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":154},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14234,"byte_end":14237,"line_start":452,"line_end":452,"column_start":12,"column_end":15},"name":"len","qualname":"<SliceDeque<T>>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Number of elements in the ring buffer.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::with_capacity(10);\n assert!(deq.len() == 0);\n deq.push_back(3);\n assert!(deq.len() == 1);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14213,"byte_end":14222,"line_start":451,"line_end":451,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":155},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14644,"byte_end":14651,"line_start":469,"line_end":469,"column_start":12,"column_end":19},"name":"is_full","qualname":"<SliceDeque<T>>::is_full","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Is the ring buffer full ?\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::with_capacity(10);\n assert!(!deq.is_full());\n # let o: SliceDeque<u32> = deq;\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14623,"byte_end":14632,"line_start":468,"line_end":468,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":156},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14793,"byte_end":14801,"line_start":475,"line_end":475,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<SliceDeque<T>>::as_slice","value":"fn (&self) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Extracts a slice containing the entire deque.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14772,"byte_end":14781,"line_start":474,"line_end":474,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":157},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14953,"byte_end":14965,"line_start":481,"line_end":481,"column_start":12,"column_end":24},"name":"as_mut_slice","qualname":"<SliceDeque<T>>::as_mut_slice","value":"fn (&mut self) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Extracts a mutable slice containing the entire deque.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":14932,"byte_end":14941,"line_start":480,"line_end":480,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":158},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":15191,"byte_end":15200,"line_start":488,"line_end":488,"column_start":12,"column_end":21},"name":"as_slices","qualname":"<SliceDeque<T>>::as_slices","value":"fn (&self) -> (&[T], &[T])","parent":null,"children":[],"decl_id":null,"docs":" Returns a pair of slices, where the first slice contains the contents\n of the deque and the second one is empty.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":15170,"byte_end":15179,"line_start":487,"line_end":487,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":159},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":15577,"byte_end":15590,"line_start":500,"line_end":500,"column_start":12,"column_end":25},"name":"as_mut_slices","qualname":"<SliceDeque<T>>::as_mut_slices","value":"fn (&mut self) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Returns a pair of slices, where the first slice contains the contents\n of the deque and the second one is empty.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":15556,"byte_end":15565,"line_start":499,"line_end":499,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":160},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":16660,"byte_end":16675,"line_start":536,"line_end":536,"column_start":19,"column_end":34},"name":"tail_head_slice","qualname":"<SliceDeque<T>>::tail_head_slice","value":"fn (&mut self) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the slice of uninitialized memory between the `tail` and the\n `begin`.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # fn main() {\n let mut d = sdeq![1, 2, 3];\n let cap = d.capacity();\n let len = d.len();\n unsafe {\n     {\n         // This slice contains the uninitialized elements in\n         // the deque:\n         let mut s = d.tail_head_slice();\n         assert_eq!(s.len(), cap - len);\n         // We can write to them and for example bump the tail of\n         // the deque:\n         s[0] = 4;\n         s[1] = 5;\n     }\n     d.move_tail(2);\n }\n assert_eq!(d, sdeq![1, 2, 3, 4, 5]);\n # }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":161},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":17214,"byte_end":17225,"line_start":551,"line_end":551,"column_start":12,"column_end":23},"name":"try_reserve","qualname":"<SliceDeque<T>>::try_reserve","value":"fn (&mut self, additional: usize) -> Result<(), AllocError>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to reserve capacity for inserting at least `additional`\n elements without reallocating. Does nothing if the capacity is already\n sufficient.\n\n The collection always reserves memory in multiples of the page size.\n\n # Panics\n\n Panics if the new capacity overflows `usize`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":17193,"byte_end":17202,"line_start":550,"line_end":550,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":162},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":17872,"byte_end":17879,"line_start":570,"line_end":570,"column_start":12,"column_end":19},"name":"reserve","qualname":"<SliceDeque<T>>::reserve","value":"fn (&mut self, additional: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Reserves capacity for inserting at least `additional` elements without\n reallocating. Does nothing if the capacity is already sufficient.\n\n The collection always reserves memory in multiples of the page size.\n\n # Panics\n\n Panics if the new capacity overflows `usize` or on OOM.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":17851,"byte_end":17860,"line_start":569,"line_end":569,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":164},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":20000,"byte_end":20013,"line_start":631,"line_end":631,"column_start":12,"column_end":25},"name":"reserve_exact","qualname":"<SliceDeque<T>>::reserve_exact","value":"fn (&mut self, additional: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Reserves the minimum capacity for exactly `additional` more elements to\n be inserted in the given `SliceDeq<T>`. After calling `reserve_exact`,\n capacity will be greater than or equal to `self.len() + additional`.\n Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore capacity can not be relied upon to be precisely\n minimal. Prefer `reserve` if future insertions are expected.\n\n # Panics\n\n Panics if the new capacity overflows `usize`.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # fn main() {\n let mut deq = sdeq![1];\n deq.reserve_exact(10);\n assert!(deq.capacity() >= 11);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":19979,"byte_end":19988,"line_start":630,"line_end":630,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":166},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":21317,"byte_end":21336,"line_start":667,"line_end":667,"column_start":19,"column_end":38},"name":"move_head_unchecked","qualname":"<SliceDeque<T>>::move_head_unchecked","value":"fn (&mut self, x: isize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves the deque head by `x`.\n\n # Panics\n\n If the head wraps over the tail the behavior is undefined, that is,\n if `x` is out-of-range `[-(capacity() - len()), len()]`.\n\n If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n\n # Unsafe\n\n It does not `drop` nor initialize elements, it just moves where the\n tail of the deque points to within the allocated buffer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":21289,"byte_end":21298,"line_start":666,"line_end":666,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":167},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":23569,"byte_end":23578,"line_start":726,"line_end":726,"column_start":19,"column_end":28},"name":"move_head","qualname":"<SliceDeque<T>>::move_head","value":"fn (&mut self, x: isize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves the deque head by `x`.\n\n # Panics\n\n If the `head` wraps over the `tail`, that is, if `x` is out-of-range\n `[-(capacity() - len()), len()]`.\n\n # Unsafe\n\n It does not `drop` nor initialize elements, it just moves where the\n tail of the deque points to within the allocated buffer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":23541,"byte_end":23550,"line_start":725,"line_end":725,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":168},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":24279,"byte_end":24298,"line_start":748,"line_end":748,"column_start":19,"column_end":38},"name":"move_tail_unchecked","qualname":"<SliceDeque<T>>::move_tail_unchecked","value":"fn (&mut self, x: isize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves the deque tail by `x`.\n\n # Panics\n\n If the `tail` wraps over the `head` the behavior is undefined, that is,\n if `x` is out-of-range `[-len(), capacity() - len()]`.\n\n If `-C debug-assertions=1` violating this pre-condition `panic!`s.\n\n # Unsafe\n\n It does not `drop` nor initialize elements, it just moves where the\n tail of the deque points to within the allocated buffer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":24251,"byte_end":24260,"line_start":747,"line_end":747,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":169},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":25151,"byte_end":25160,"line_start":774,"line_end":774,"column_start":19,"column_end":28},"name":"move_tail","qualname":"<SliceDeque<T>>::move_tail","value":"fn (&mut self, x: isize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves the deque tail by `x`.\n\n # Panics\n\n If the `tail` wraps over the `head`, that is, if `x` is out-of-range\n `[-len(), capacity() - len()]`.\n\n # Unsafe\n\n It does not `drop` nor initialize elements, it just moves where the\n tail of the deque points to within the allocated buffer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":25123,"byte_end":25132,"line_start":773,"line_end":773,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":171},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":25893,"byte_end":25909,"line_start":798,"line_end":798,"column_start":19,"column_end":35},"name":"steal_from_slice","qualname":"<SliceDeque<T>>::steal_from_slice","value":"fn (s: &[T]) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Steal the elements from the slice `s`. You should `mem::forget` the\n slice afterwards.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":172},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":26602,"byte_end":26608,"line_start":824,"line_end":824,"column_start":12,"column_end":18},"name":"append","qualname":"<SliceDeque<T>>::append","value":"fn (&mut self, other: &mut Self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves all the elements of `other` into `Self`, leaving `other` empty.\n\n # Panics\n\n Panics if the number of elements in the deque overflows a `isize`.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3];\n let mut deq2 = sdeq![4, 5, 6];\n deq.append(&mut deq2);\n assert_eq!(deq, [1, 2, 3, 4, 5, 6]);\n assert_eq!(deq2, []);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":26581,"byte_end":26590,"line_start":823,"line_end":823,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":173},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":27265,"byte_end":27270,"line_start":848,"line_end":848,"column_start":12,"column_end":17},"name":"front","qualname":"<SliceDeque<T>>::front","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Provides a reference to the first element, or `None` if the deque is\n empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.front(), None);\n\n deq.push_back(1);\n deq.push_back(2);\n assert_eq!(deq.front(), Some(&1));\n deq.push_front(3);\n assert_eq!(deq.front(), Some(&3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":27244,"byte_end":27253,"line_start":847,"line_end":847,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":174},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":27811,"byte_end":27820,"line_start":869,"line_end":869,"column_start":12,"column_end":21},"name":"front_mut","qualname":"<SliceDeque<T>>::front_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Provides a mutable reference to the first element, or `None` if the\n deque is empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.front(), None);\n\n deq.push_back(1);\n deq.push_back(2);\n assert_eq!(deq.front(), Some(&1));\n (*deq.front_mut().unwrap()) = 3;\n assert_eq!(deq.front(), Some(&3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":27790,"byte_end":27799,"line_start":868,"line_end":868,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":175},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":28347,"byte_end":28351,"line_start":890,"line_end":890,"column_start":12,"column_end":16},"name":"back","qualname":"<SliceDeque<T>>::back","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Provides a reference to the last element, or `None` if the deque is\n empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.back(), None);\n\n deq.push_back(1);\n deq.push_back(2);\n assert_eq!(deq.back(), Some(&2));\n deq.push_front(3);\n assert_eq!(deq.back(), Some(&2));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":28326,"byte_end":28335,"line_start":889,"line_end":889,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":176},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":28946,"byte_end":28954,"line_start":912,"line_end":912,"column_start":12,"column_end":20},"name":"back_mut","qualname":"<SliceDeque<T>>::back_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Provides a mutable reference to the last element, or `None` if the\n deque is empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.front(), None);\n\n deq.push_back(1);\n deq.push_back(2);\n assert_eq!(deq.back(), Some(&2));\n (*deq.back_mut().unwrap()) = 3;\n assert_eq!(deq.back(), Some(&3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":28925,"byte_end":28934,"line_start":911,"line_end":911,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":177},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":29416,"byte_end":29430,"line_start":929,"line_end":929,"column_start":12,"column_end":26},"name":"try_push_front","qualname":"<SliceDeque<T>>::try_push_front","value":"fn (&mut self, value: T) -> Result<(), (T, AllocError)>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to prepend `value` to the deque.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n deq.try_push_front(1).unwrap();\n deq.try_push_front(2).unwrap();\n assert_eq!(deq.front(), Some(&2));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":29395,"byte_end":29404,"line_start":928,"line_end":928,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":178},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":30175,"byte_end":30185,"line_start":959,"line_end":959,"column_start":12,"column_end":22},"name":"push_front","qualname":"<SliceDeque<T>>::push_front","value":"fn (&mut self, value: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Prepends `value` to the deque.\n\n # Panics\n\n On OOM.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n deq.push_front(1);\n deq.push_front(2);\n assert_eq!(deq.front(), Some(&2));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":30154,"byte_end":30163,"line_start":958,"line_end":958,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":179},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":30650,"byte_end":30663,"line_start":977,"line_end":977,"column_start":12,"column_end":25},"name":"try_push_back","qualname":"<SliceDeque<T>>::try_push_back","value":"fn (&mut self, value: T) -> Result<(), (T, AllocError)>","parent":null,"children":[],"decl_id":null,"docs":" Attempts to appends `value` to the deque.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n deq.try_push_back(1).unwrap();\n deq.try_push_back(3).unwrap();\n assert_eq!(deq.back(), Some(&3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":30629,"byte_end":30638,"line_start":976,"line_end":976,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":180},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":31442,"byte_end":31451,"line_start":1007,"line_end":1007,"column_start":12,"column_end":21},"name":"push_back","qualname":"<SliceDeque<T>>::push_back","value":"fn (&mut self, value: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Appends `value` to the deque.\n\n # Panics\n\n On OOM.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n deq.push_back(1);\n deq.push_back(3);\n assert_eq!(deq.back(), Some(&3));\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":31421,"byte_end":31430,"line_start":1006,"line_end":1006,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":181},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":32078,"byte_end":32087,"line_start":1031,"line_end":1031,"column_start":12,"column_end":21},"name":"pop_front","qualname":"<SliceDeque<T>>::pop_front","value":"fn (&mut self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Removes the first element and returns it, or `None` if the deque is\n empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.pop_front(), None);\n\n deq.push_back(1);\n deq.push_back(2);\n\n assert_eq!(deq.pop_front(), Some(1));\n assert_eq!(deq.pop_front(), Some(2));\n assert_eq!(deq.pop_front(), None);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":32057,"byte_end":32066,"line_start":1030,"line_end":1030,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":182},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":32850,"byte_end":32858,"line_start":1060,"line_end":1060,"column_start":12,"column_end":20},"name":"pop_back","qualname":"<SliceDeque<T>>::pop_back","value":"fn (&mut self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Removes the last element from the deque and returns it, or `None` if it\n is empty.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.pop_back(), None);\n\n deq.push_back(1);\n deq.push_back(3);\n\n assert_eq!(deq.pop_back(), Some(3));\n assert_eq!(deq.pop_back(), Some(1));\n assert_eq!(deq.pop_back(), None);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":32829,"byte_end":32838,"line_start":1059,"line_end":1059,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":183},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":33836,"byte_end":33849,"line_start":1091,"line_end":1091,"column_start":12,"column_end":25},"name":"shrink_to_fit","qualname":"<SliceDeque<T>>::shrink_to_fit","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Shrinks the capacity of the deque as much as possible.\n\n It will drop down as close as possible to the length, but because\n `SliceDeque` allocates memory in multiples of the page size the deque\n might still have capacity for inserting new elements without\n reallocating.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::with_capacity(15);\n deq.extend(0..4);\n assert!(deq.capacity() >= 15);\n deq.shrink_to_fit();\n assert!(deq.capacity() >= 4);\n # let o: SliceDeque<u32> = deq;\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":33815,"byte_end":33824,"line_start":1090,"line_end":1090,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":184},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":35087,"byte_end":35100,"line_start":1131,"line_end":1131,"column_start":12,"column_end":25},"name":"truncate_back","qualname":"<SliceDeque<T>>::truncate_back","value":"fn (&mut self, len: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Shortens the deque by removing excess elements from the back.\n\n If `len` is greater than the SliceDeque's current length, this has no\n effect.\n\n # Examples\n\n ```rust\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![5, 10, 15];\n assert_eq!(deq, [5, 10, 15]);\n deq.truncate_back(1);\n assert_eq!(deq, [5]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":35066,"byte_end":35075,"line_start":1130,"line_end":1130,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":185},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":35821,"byte_end":35829,"line_start":1152,"line_end":1152,"column_start":12,"column_end":20},"name":"truncate","qualname":"<SliceDeque<T>>::truncate","value":"fn (&mut self, len: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Shortens the deque by removing excess elements from the back.\n\n If `len` is greater than the SliceDeque's current length, this has no\n effect. See `truncate_back` for examples.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":35800,"byte_end":35809,"line_start":1151,"line_end":1151,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":186},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":36418,"byte_end":36432,"line_start":1174,"line_end":1174,"column_start":12,"column_end":26},"name":"truncate_front","qualname":"<SliceDeque<T>>::truncate_front","value":"fn (&mut self, len: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Shortens the deque by removing excess elements from the front.\n\n If `len` is greater than the SliceDeque's current length, this has no\n effect.\n\n # Examples\n\n ```rust\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![5, 10, 15];\n assert_eq!(deq, [5, 10, 15]);\n deq.truncate_front(1);\n assert_eq!(deq, [15]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":36397,"byte_end":36406,"line_start":1173,"line_end":1173,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":187},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":37973,"byte_end":37978,"line_start":1222,"line_end":1222,"column_start":12,"column_end":17},"name":"drain","qualname":"<SliceDeque<T>>::drain","value":"fn <R> (&mut self, range: R) -> Drain<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a draining iterator that removes the specified range in the\n deque and yields the removed items.\n\n Note 1: The element range is removed even if the iterator is only\n partially consumed or not consumed at all.\n\n Note 2: It is unspecified how many elements are removed from the deque\n if the `Drain` value is leaked.\n\n # Panics\n\n Panics if the starting point is greater than the end point or if\n the end point is greater than the length of the deque.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3];\n let u: Vec<_> = deq.drain(1..).collect();\n assert_eq!(deq, &[1]);\n assert_eq!(u, &[2, 3]);\n\n // A full range clears the deque\n deq.drain(..);\n assert_eq!(deq, &[]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":37907,"byte_end":37916,"line_start":1220,"line_end":1220,"column_start":5,"column_end":14}},{"value":"allow(clippy :: needless_pass_by_value)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":37921,"byte_end":37961,"line_start":1221,"line_end":1221,"column_start":5,"column_end":45}}]},{"kind":"Method","id":{"krate":0,"index":193},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":40330,"byte_end":40335,"line_start":1293,"line_end":1293,"column_start":12,"column_end":17},"name":"clear","qualname":"<SliceDeque<T>>::clear","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Removes all values from the deque.\n\n # Examples\n\n ```rust\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1];\n assert!(!deq.is_empty());\n deq.clear();\n assert!(deq.is_empty());\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":40309,"byte_end":40318,"line_start":1292,"line_end":1292,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":194},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":40874,"byte_end":40890,"line_start":1313,"line_end":1313,"column_start":12,"column_end":28},"name":"swap_remove_back","qualname":"<SliceDeque<T>>::swap_remove_back","value":"fn (&mut self, index: usize) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Removes the element at `index` and return it in `O(1)` by swapping the\n last element into its place.\n\n # Examples\n\n ```rust\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.swap_remove_back(0), None);\n deq.extend(1..4);\n assert_eq!(deq, [1, 2, 3]);\n\n assert_eq!(deq.swap_remove_back(0), Some(1));\n assert_eq!(deq, [3, 2]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":40853,"byte_end":40862,"line_start":1312,"line_end":1312,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":195},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":41600,"byte_end":41617,"line_start":1339,"line_end":1339,"column_start":12,"column_end":29},"name":"swap_remove_front","qualname":"<SliceDeque<T>>::swap_remove_front","value":"fn (&mut self, index: usize) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Removes the element at `index` and returns it in `O(1)` by swapping the\n first element into its place.\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n assert_eq!(deq.swap_remove_front(0), None);\n deq.extend(1..4);\n assert_eq!(deq, [1, 2, 3]);\n\n assert_eq!(deq.swap_remove_front(2), Some(3));\n assert_eq!(deq, [2, 1]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":41579,"byte_end":41588,"line_start":1338,"line_end":1338,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":196},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":42481,"byte_end":42487,"line_start":1371,"line_end":1371,"column_start":12,"column_end":18},"name":"insert","qualname":"<SliceDeque<T>>::insert","value":"fn (&mut self, index: usize, element: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Inserts an `element` at `index` within the deque, shifting all elements\n with indices greater than or equal to `index` towards the back.\n\n Element at index 0 is the front of the queue.\n\n # Panics\n\n Panics if `index` is greater than deque's length\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq!['a', 'b', 'c'];\n assert_eq!(deq, &['a', 'b', 'c']);\n\n deq.insert(1, 'd');\n assert_eq!(deq, &['a', 'd', 'b', 'c']);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":42460,"byte_end":42469,"line_start":1370,"line_end":1370,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":197},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":44135,"byte_end":44141,"line_start":1420,"line_end":1420,"column_start":12,"column_end":18},"name":"remove","qualname":"<SliceDeque<T>>::remove","value":"fn (&mut self, index: usize) -> T","parent":null,"children":[],"decl_id":null,"docs":" Removes and returns the element at position `index` within the deque.\n\n # Panics\n\n Panics if `index` is out of bounds.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3, 4, 5];\n assert_eq!(deq.remove(1), 2);\n assert_eq!(deq, [1, 3, 4, 5]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":44040,"byte_end":44049,"line_start":1418,"line_end":1418,"column_start":5,"column_end":14}},{"value":"allow(clippy :: shadow_unrelated)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":44054,"byte_end":44088,"line_start":1419,"line_end":1419,"column_start":5,"column_end":39}}]},{"kind":"Method","id":{"krate":0,"index":198},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":45665,"byte_end":45674,"line_start":1468,"line_end":1468,"column_start":12,"column_end":21},"name":"split_off","qualname":"<SliceDeque<T>>::split_off","value":"fn (&mut self, at: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Splits the collection into two at the given index.\n\n Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n and the returned `Self` contains elements `[at, len)`.\n\n Note that the capacity of `self` does not change.\n\n # Panics\n\n Panics if `at > len`.\n\n # Examples\n\n ```rust\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3];\n let deq2 = deq.split_off(1);\n assert_eq!(deq, [1]);\n assert_eq!(deq2, [2, 3]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":45644,"byte_end":45653,"line_start":1467,"line_end":1467,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":199},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":46748,"byte_end":46754,"line_start":1505,"line_end":1505,"column_start":12,"column_end":18},"name":"retain","qualname":"<SliceDeque<T>>::retain","value":"fn <F> (&mut self, mut f: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Retains only the elements specified by the predicate.\n\n That is, remove all elements `e` such that `f(&e)` returns `false`.\n This method operates in place and preserves the order of the\n retained elements.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3, 4];\n deq.retain(|&x| x % 2 == 0);\n assert_eq!(deq, [2, 4]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":46727,"byte_end":46736,"line_start":1504,"line_end":1504,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":201},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":47732,"byte_end":47744,"line_start":1545,"line_end":1545,"column_start":12,"column_end":24},"name":"dedup_by_key","qualname":"<SliceDeque<T>>::dedup_by_key","value":"fn <F, K> (&mut self, mut key: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Removes all but the first of consecutive elements in the deque that\n resolve to the same key.\n\n If the deque is sorted, this removes all duplicates.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![10, 20, 21, 30, 20];\n\n deq.dedup_by_key(|i| *i / 10);\n assert_eq!(deq, [10, 20, 30, 20]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":47711,"byte_end":47720,"line_start":1544,"line_end":1544,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":205},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":48816,"byte_end":48824,"line_start":1578,"line_end":1578,"column_start":12,"column_end":20},"name":"dedup_by","qualname":"<SliceDeque<T>>::dedup_by","value":"fn <F> (&mut self, mut same_bucket: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Removes all but the first of consecutive elements in the deque\n satisfying a given equality relation.\n\n The `same_bucket` function is passed references to two elements from\n the deque, and returns `true` if the elements compare equal, or\n `false` if they do not. The elements are passed in opposite order\n from their order in the deque, so if `same_bucket(a, b)` returns\n `true`, `a` is removed.\n\n If the deque is sorted, this removes all duplicates.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n\n deq.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n\n assert_eq!(deq, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":48795,"byte_end":48804,"line_start":1577,"line_end":1577,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":211},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":55723,"byte_end":55729,"line_start":1769,"line_end":1769,"column_start":12,"column_end":18},"name":"splice","qualname":"<SliceDeque<T>>::splice","value":"fn <R, I> (&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>","parent":null,"children":[],"decl_id":null,"docs":" Creates a splicing iterator that replaces the specified range in the\n deque with the given `replace_with` iterator and yields the\n removed items. `replace_with` does not need to be the same length\n as `range`.\n\n Note 1: The element range is removed even if the iterator is not\n consumed until the end.\n\n Note 2: It is unspecified how many elements are removed from the deque,\n if the `Splice` value is leaked.\n\n Note 3: The input iterator `replace_with` is only consumed\n when the `Splice` value is dropped.\n\n Note 4: This is optimal if:\n\n * The tail (elements in the deque after `range`) is empty,\n * or `replace_with` yields fewer elements than `range`’s length\n * or the lower bound of its `size_hint()` is exact.\n\n Otherwise, a temporary deque is allocated and the tail is moved twice.\n\n # Panics\n\n Panics if the starting point is greater than the end point or if\n the end point is greater than the length of the deque.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3];\n let new = [7, 8];\n let u: SliceDeque<_> = deq.splice(..2, new.iter().cloned()).collect();\n assert_eq!(deq, &[7, 8, 3]);\n assert_eq!(u, &[1, 2]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":55702,"byte_end":55711,"line_start":1768,"line_end":1768,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":214},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":58032,"byte_end":58044,"line_start":1842,"line_end":1842,"column_start":12,"column_end":24},"name":"drain_filter","qualname":"<SliceDeque<T>>::drain_filter","value":"fn <F> (&mut self, filter: F) -> DrainFilter<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator which uses a closure to determine if an element\n should be removed.\n\n If the closure returns `true`, then the element is removed and yielded.\n If the closure returns `false`, it will try again, and call the closure\n on the next element, seeing if it passes the test.\n\n Using this method is equivalent to the following code:\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6\n # };\n let mut deq = SliceDeque::new();\n deq.extend(1..7);\n let mut i = 0;\n while i != deq.len() {\n     if some_predicate(&mut deq[i]) {\n         let val = deq.remove(i);\n     // your code here\n     } else {\n         i += 1;\n     }\n }\n # let mut expected = sdeq![1, 4, 5];\n # assert_eq!(deq, expected);\n # }\n ```\n\n But `drain_filter` is easier to use. `drain_filter` is also more\n efficient, because it can backshift the elements of the deque in\n bulk.\n\n Note that `drain_filter` also lets you mutate every element in the\n filter closure, regardless of whether you choose to keep or remove\n it.\n\n\n # Examples\n\n Splitting a deque into evens and odds, reusing the original allocation:\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut numbers = sdeq![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n\n let evens = numbers\n     .drain_filter(|x| *x % 2 == 0)\n     .collect::<SliceDeque<_>>();\n let odds = numbers;\n\n assert_eq!(sdeq![2, 4, 6, 8, 14], evens);\n assert_eq!(odds, sdeq![1, 3, 5, 9, 11, 13, 15]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":58011,"byte_end":58020,"line_start":1841,"line_end":1841,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":218},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":59270,"byte_end":59287,"line_start":1887,"line_end":1887,"column_start":12,"column_end":29},"name":"extend_from_slice","qualname":"<SliceDeque<T>>::extend_from_slice","value":"fn (&mut self, other: &[T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Clones and appends all elements in a slice to the `SliceDeque`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `SliceDeque`. The `other` slice is traversed in-order.\n\n Note that this function is same as `extend` except that it is\n specialized to work with slices instead. If and when Rust gets\n specialization this function will likely be deprecated (but still\n available).\n\n # Examples\n\n ```\n # use slice_deque::SliceDeque;\n let mut deq = SliceDeque::new();\n deq.push_back(1);\n deq.extend_from_slice(&[2, 3, 4]);\n assert_eq!(deq, [1, 2, 3, 4]);\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":59249,"byte_end":59258,"line_start":1886,"line_end":1886,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":219},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":60343,"byte_end":60349,"line_start":1924,"line_end":1924,"column_start":12,"column_end":18},"name":"resize","qualname":"<SliceDeque<T>>::resize","value":"fn (&mut self, new_len: usize, value: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Modifies the `SliceDeque` in-place so that `len()` is equal to\n `new_len`, either by removing excess elements or by appending clones of\n `value` to the back.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![5, 10, 15];\n assert_eq!(deq, [5, 10, 15]);\n\n deq.resize(2, 0);\n assert_eq!(deq, [5, 10]);\n\n deq.resize(5, 20);\n assert_eq!(deq, [5, 10, 20, 20, 20]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":60322,"byte_end":60331,"line_start":1923,"line_end":1923,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":222},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":61649,"byte_end":61663,"line_start":1967,"line_end":1967,"column_start":12,"column_end":26},"name":"resize_default","qualname":"<SliceDeque<T>>::resize_default","value":"fn (&mut self, new_len: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Resizes the `SliceDeque` in-place so that `len` is equal to `new_len`.\n\n If `new_len` is greater than `len`, the `SliceDeque` is extended by the\n difference, with each additional slot filled with `Default::default()`.\n If `new_len` is less than `len`, the `SliceDeque` is simply truncated.\n\n This method uses `Default` to create new values on every push. If\n you'd rather `Clone` a given value, use [`resize`].\n\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3];\n deq.resize_default(5);\n assert_eq!(deq, [1, 2, 3, 0, 0]);\n\n deq.resize_default(2);\n assert_eq!(deq, [1, 2]);\n # }\n ```\n\n [`resize`]: #method.resize\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":61628,"byte_end":61637,"line_start":1966,"line_end":1966,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":225},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":62497,"byte_end":62502,"line_start":2002,"line_end":2002,"column_start":12,"column_end":17},"name":"dedup","qualname":"<SliceDeque<T>>::dedup","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Removes consecutive repeated elements in the deque.\n\n If the deque is sorted, this removes all duplicates.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 2, 3, 2];\n\n deq.dedup();\n assert_eq!(deq, [1, 2, 3, 2]);\n\n deq.sort();\n assert_eq!(deq, [1, 2, 2, 3]);\n\n deq.dedup();\n assert_eq!(deq, [1, 2, 3]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":62476,"byte_end":62485,"line_start":2001,"line_end":2001,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":227},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63024,"byte_end":63035,"line_start":2023,"line_end":2023,"column_start":12,"column_end":23},"name":"remove_item","qualname":"<SliceDeque<T>>::remove_item","value":"fn (&mut self, item: &T) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Removes the first instance of `item` from the deque if the item exists.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq![1, 2, 3, 1];\n\n deq.remove_item(&1);\n assert_eq!(deq, &[2, 3, 1]);\n deq.remove_item(&1);\n assert_eq!(deq, &[2, 3]);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63003,"byte_end":63012,"line_start":2022,"line_end":2022,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":272},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":67505,"byte_end":67510,"line_start":2201,"line_end":2201,"column_start":12,"column_end":17},"name":"Drain","qualname":"::Drain","value":"Drain {  }","parent":null,"children":[{"krate":0,"index":275},{"krate":0,"index":276},{"krate":0,"index":277},{"krate":0,"index":278}],"decl_id":null,"docs":" A draining iterator for `SliceDeque<T>`.\n\n This `struct` is created by the [`drain`] method on [`SliceDeque`].\n\n [`drain`]: struct.SliceDeque.html#method.drain\n [`SliceDeque`]: struct.SliceDeque.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":306},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":69866,"byte_end":69874,"line_start":2284,"line_end":2284,"column_start":12,"column_end":20},"name":"IntoIter","qualname":"::IntoIter","value":"IntoIter {  }","parent":null,"children":[{"krate":0,"index":308},{"krate":0,"index":309},{"krate":0,"index":310},{"krate":0,"index":311}],"decl_id":null,"docs":" An iterator that moves out of a deque.\n\n This `struct` is created by the `into_iter` method on\n [`SliceDeque`][`SliceDeque`] (provided by the [`IntoIterator`] trait).\n\n [`SliceDeque`]: struct.SliceDeque.html\n [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":317},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":71187,"byte_end":71195,"line_start":2331,"line_end":2331,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<IntoIter<T>>::as_slice","value":"fn (&self) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remaining items of this iterator as a slice.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq!['a', 'b', 'c'];\n let mut into_iter = deq.into_iter();\n assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n let _ = into_iter.next().unwrap();\n assert_eq!(into_iter.as_slice(), ['b', 'c']);\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":71166,"byte_end":71175,"line_start":2330,"line_end":2330,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":318},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":71917,"byte_end":71929,"line_start":2353,"line_end":2353,"column_start":12,"column_end":24},"name":"as_mut_slice","qualname":"<IntoIter<T>>::as_mut_slice","value":"fn (&mut self) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remaining items of this iterator as a mutable slice.\n\n # Examples\n\n ```\n # #[macro_use] extern crate slice_deque;\n # use slice_deque::SliceDeque;\n # fn main() {\n let mut deq = sdeq!['a', 'b', 'c'];\n let mut into_iter = deq.into_iter();\n assert_eq!(into_iter.as_slice(), ['a', 'b', 'c']);\n into_iter.as_mut_slice()[2] = 'z';\n assert_eq!(into_iter.next().unwrap(), 'a');\n assert_eq!(into_iter.next().unwrap(), 'b');\n assert_eq!(into_iter.next().unwrap(), 'z');\n # }\n ```\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":71896,"byte_end":71905,"line_start":2352,"line_end":2352,"column_start":5,"column_end":14}}]},{"kind":"Function","id":{"krate":0,"index":400},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":83851,"byte_end":83860,"line_start":2776,"line_end":2776,"column_start":8,"column_end":17},"name":"from_elem","qualname":"::from_elem","value":"fn <T> (elem: T, n: usize) -> SliceDeque<T>","parent":null,"children":[],"decl_id":null,"docs":" TODO: docs\n FIXME: not used, this should be used by the sdeq! macro? Remove this maybe.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":1005},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":86751,"byte_end":86757,"line_start":2868,"line_end":2868,"column_start":12,"column_end":18},"name":"Splice","qualname":"::Splice","value":"Splice {  }","parent":null,"children":[{"krate":0,"index":1008},{"krate":0,"index":1009}],"decl_id":null,"docs":" A splicing iterator for `SliceDeque`.\n\n This struct is created by the [`splice()`] method on [`SliceDeque`]. See\n its documentation for more.\n\n [`splice()`]: struct.SliceDeque.html#method.splice\n [`SliceDeque`]: struct.SliceDeque.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":1014},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":90952,"byte_end":90963,"line_start":2994,"line_end":2994,"column_start":12,"column_end":23},"name":"DrainFilter","qualname":"::DrainFilter","value":"DrainFilter {  }","parent":null,"children":[{"krate":0,"index":1018},{"krate":0,"index":1019},{"krate":0,"index":1020},{"krate":0,"index":1021},{"krate":0,"index":1022}],"decl_id":null,"docs":" An iterator produced by calling `drain_filter` on `SliceDeque`.\n","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\macros.rs","byte_start":172120,"byte_end":172135,"line_start":9,"line_end":9,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":8},{"krate":0,"index":10}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\macros.rs","byte_start":172455,"byte_end":172470,"line_start":20,"line_end":20,"column_start":28,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":12}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":175860,"byte_end":175866,"line_start":30,"line_end":30,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":26},{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":30},{"krate":0,"index":31},{"krate":0,"index":32},{"krate":0,"index":33},{"krate":0,"index":34},{"krate":0,"index":35},{"krate":0,"index":36},{"krate":0,"index":37}],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":179904,"byte_end":179910,"line_start":160,"line_end":160,"column_start":18,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":40}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":180360,"byte_end":180366,"line_start":176,"line_end":176,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":43}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":180865,"byte_end":180871,"line_start":195,"line_end":195,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":46}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":181025,"byte_end":181031,"line_start":202,"line_end":202,"column_start":25,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":181142,"byte_end":181148,"line_start":204,"line_end":204,"column_start":25,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\mod.rs","byte_start":174774,"byte_end":174784,"line_start":82,"line_end":82,"column_start":28,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":105}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":8998,"byte_end":9008,"line_start":271,"line_end":271,"column_start":25,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":9119,"byte_end":9129,"line_start":273,"line_end":273,"column_start":25,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":11475,"byte_end":11485,"line_start":356,"line_end":356,"column_start":9,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":149},{"krate":0,"index":150},{"krate":0,"index":151},{"krate":0,"index":153},{"krate":0,"index":154},{"krate":0,"index":155},{"krate":0,"index":156},{"krate":0,"index":157},{"krate":0,"index":158},{"krate":0,"index":159},{"krate":0,"index":160},{"krate":0,"index":161},{"krate":0,"index":162},{"krate":0,"index":163},{"krate":0,"index":164},{"krate":0,"index":165},{"krate":0,"index":166},{"krate":0,"index":167},{"krate":0,"index":168},{"krate":0,"index":169},{"krate":0,"index":170},{"krate":0,"index":171},{"krate":0,"index":172},{"krate":0,"index":173},{"krate":0,"index":174},{"krate":0,"index":175},{"krate":0,"index":176},{"krate":0,"index":177},{"krate":0,"index":178},{"krate":0,"index":179},{"krate":0,"index":180},{"krate":0,"index":181},{"krate":0,"index":182},{"krate":0,"index":183},{"krate":0,"index":184},{"krate":0,"index":185},{"krate":0,"index":186},{"krate":0,"index":187},{"krate":0,"index":193},{"krate":0,"index":194},{"krate":0,"index":195},{"krate":0,"index":196},{"krate":0,"index":197},{"krate":0,"index":198},{"krate":0,"index":199},{"krate":0,"index":201},{"krate":0,"index":205},{"krate":0,"index":207},{"krate":0,"index":209},{"krate":0,"index":211},{"krate":0,"index":214}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":58486,"byte_end":58496,"line_start":1863,"line_end":1863,"column_start":9,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":218},{"krate":0,"index":219}],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":60725,"byte_end":60735,"line_start":1939,"line_end":1939,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":222}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":61902,"byte_end":61912,"line_start":1978,"line_end":1978,"column_start":20,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":225},{"krate":0,"index":227}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63281,"byte_end":63291,"line_start":2032,"line_end":2032,"column_start":36,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":231}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63758,"byte_end":63768,"line_start":2050,"line_end":2050,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":234}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64148,"byte_end":64158,"line_start":2064,"line_end":2064,"column_start":24,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":237},{"krate":0,"index":238}],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64299,"byte_end":64309,"line_start":2072,"line_end":2072,"column_start":27,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":241}],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64437,"byte_end":64447,"line_start":2079,"line_end":2079,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":244}],"docs":"","sig":null,"attributes":[]},{"id":20,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64548,"byte_end":64558,"line_start":2086,"line_end":2086,"column_start":26,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":247},{"krate":0,"index":248}],"docs":"","sig":null,"attributes":[]},{"id":21,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64968,"byte_end":64978,"line_start":2104,"line_end":2104,"column_start":38,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":252}],"docs":"","sig":null,"attributes":[]},{"id":22,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":65215,"byte_end":65225,"line_start":2115,"line_end":2115,"column_start":42,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":256}],"docs":"","sig":null,"attributes":[]},{"id":23,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":65460,"byte_end":65470,"line_start":2126,"line_end":2126,"column_start":36,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":259}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":66860,"byte_end":66870,"line_start":2179,"line_end":2179,"column_start":20,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":66913,"byte_end":66923,"line_start":2181,"line_end":2181,"column_start":36,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":267}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":67118,"byte_end":67128,"line_start":2188,"line_end":2188,"column_start":49,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":271}],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":67848,"byte_end":67853,"line_start":2212,"line_end":2212,"column_start":45,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":282}],"docs":"","sig":null,"attributes":[]},{"id":32,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68034,"byte_end":68039,"line_start":2218,"line_end":2218,"column_start":35,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":33,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68084,"byte_end":68089,"line_start":2219,"line_end":2219,"column_start":35,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68126,"byte_end":68131,"line_start":2221,"line_end":2221,"column_start":26,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":292},{"krate":0,"index":293},{"krate":0,"index":295}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68460,"byte_end":68465,"line_start":2236,"line_end":2236,"column_start":37,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":299}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68667,"byte_end":68672,"line_start":2245,"line_end":2245,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":304}],"docs":"","sig":null,"attributes":[]},{"id":37,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":70138,"byte_end":70146,"line_start":2295,"line_end":2295,"column_start":36,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":314}],"docs":"","sig":null,"attributes":[]},{"id":38,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":70295,"byte_end":70303,"line_start":2301,"line_end":2301,"column_start":9,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":317},{"krate":0,"index":318}],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72099,"byte_end":72107,"line_start":2360,"line_end":2360,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":40,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72144,"byte_end":72152,"line_start":2361,"line_end":2361,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":41,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72181,"byte_end":72189,"line_start":2363,"line_end":2363,"column_start":22,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":325},{"krate":0,"index":326},{"krate":0,"index":327},{"krate":0,"index":328}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":73412,"byte_end":73420,"line_start":2405,"line_end":2405,"column_start":33,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":331}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":74423,"byte_end":74431,"line_start":2442,"line_end":2442,"column_start":26,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":334}],"docs":"","sig":null,"attributes":[]},{"id":44,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":75058,"byte_end":75066,"line_start":2467,"line_end":2467,"column_start":18,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":337}],"docs":"","sig":null,"attributes":[]},{"id":45,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":75358,"byte_end":75368,"line_start":2479,"line_end":2479,"column_start":26,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":340},{"krate":0,"index":341},{"krate":0,"index":342}],"docs":"","sig":null,"attributes":[]},{"id":46,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":77372,"byte_end":77382,"line_start":2547,"line_end":2547,"column_start":23,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":357}],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":78933,"byte_end":78943,"line_start":2593,"line_end":2593,"column_start":33,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":370},{"krate":0,"index":371}],"docs":"","sig":null,"attributes":[]},{"id":48,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":81893,"byte_end":81903,"line_start":2692,"line_end":2692,"column_start":45,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":376},{"krate":0,"index":377}],"docs":"","sig":null,"attributes":[]},{"id":49,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":82994,"byte_end":83004,"line_start":2737,"line_end":2737,"column_start":35,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":380}],"docs":"","sig":null,"attributes":[]},{"id":50,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":83403,"byte_end":83416,"line_start":2753,"line_end":2753,"column_start":34,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":392},{"krate":0,"index":393}],"docs":"","sig":null,"attributes":[]},{"id":51,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":83598,"byte_end":83611,"line_start":2764,"line_end":2764,"column_start":36,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":398},{"krate":0,"index":399}],"docs":"","sig":null,"attributes":[]},{"id":52,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":84157,"byte_end":84158,"line_start":2786,"line_end":2786,"column_start":33,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":406}],"docs":"","sig":null,"attributes":[]},{"id":53,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":86331,"byte_end":86341,"line_start":2854,"line_end":2854,"column_start":42,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":411}],"docs":"","sig":null,"attributes":[]},{"id":54,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":86910,"byte_end":86916,"line_start":2875,"line_end":2875,"column_start":36,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":416},{"krate":0,"index":417},{"krate":0,"index":418}],"docs":"","sig":null,"attributes":[]},{"id":55,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":87196,"byte_end":87202,"line_start":2887,"line_end":2887,"column_start":47,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":422}],"docs":"","sig":null,"attributes":[]},{"id":56,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":87559,"byte_end":87565,"line_start":2901,"line_end":2901,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":426}],"docs":"","sig":null,"attributes":[]},{"id":57,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":89295,"byte_end":89300,"line_start":2949,"line_end":2949,"column_start":13,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":430},{"krate":0,"index":432}],"docs":"","sig":null,"attributes":[]},{"id":58,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":91239,"byte_end":91250,"line_start":3010,"line_end":3010,"column_start":29,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":437},{"krate":0,"index":438},{"krate":0,"index":439}],"docs":"","sig":null,"attributes":[]},{"id":59,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92392,"byte_end":92403,"line_start":3047,"line_end":3047,"column_start":25,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":444}],"docs":"","sig":null,"attributes":[]},{"id":60,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92691,"byte_end":92701,"line_start":3061,"line_end":3061,"column_start":33,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":447}],"docs":"","sig":null,"attributes":[]},{"id":61,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92794,"byte_end":92804,"line_start":3067,"line_end":3067,"column_start":33,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":450}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\macros.rs","byte_start":172120,"byte_end":172135,"line_start":9,"line_end":9,"column_start":6,"column_end":21},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":4},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\macros.rs","byte_start":172455,"byte_end":172470,"line_start":20,"line_end":20,"column_start":28,"column_end":43},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":4},"to":{"krate":2,"index":7602}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":175860,"byte_end":175866,"line_start":30,"line_end":30,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":20},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":179904,"byte_end":179910,"line_start":160,"line_end":160,"column_start":18,"column_end":24},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":180360,"byte_end":180366,"line_start":176,"line_end":176,"column_start":19,"column_end":25},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":180865,"byte_end":180871,"line_start":195,"line_end":195,"column_start":21,"column_end":27},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":181025,"byte_end":181031,"line_start":202,"line_end":202,"column_start":25,"column_end":31},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\buffer.rs","byte_start":181142,"byte_end":181148,"line_start":204,"line_end":204,"column_start":25,"column_end":31},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":20},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\mirrored\\mod.rs","byte_start":174774,"byte_end":174784,"line_start":82,"line_end":82,"column_start":28,"column_end":38},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":99},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":8998,"byte_end":9008,"line_start":271,"line_end":271,"column_start":25,"column_end":35},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":9119,"byte_end":9129,"line_start":273,"line_end":273,"column_start":25,"column_end":35},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":11475,"byte_end":11485,"line_start":356,"line_end":356,"column_start":9,"column_end":19},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":137},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":58486,"byte_end":58496,"line_start":1863,"line_end":1863,"column_start":9,"column_end":19},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":137},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":60725,"byte_end":60735,"line_start":1939,"line_end":1939,"column_start":18,"column_end":28},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":137},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":61902,"byte_end":61912,"line_start":1978,"line_end":1978,"column_start":20,"column_end":30},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":137},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63281,"byte_end":63291,"line_start":2032,"line_end":2032,"column_start":36,"column_end":46},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":63758,"byte_end":63768,"line_start":2050,"line_end":2050,"column_start":18,"column_end":28},"kind":{"Impl":{"id":16}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64148,"byte_end":64158,"line_start":2064,"line_end":2064,"column_start":24,"column_end":34},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":1704}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64299,"byte_end":64309,"line_start":2072,"line_end":2072,"column_start":27,"column_end":37},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":1715}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64437,"byte_end":64447,"line_start":2079,"line_end":2079,"column_start":21,"column_end":31},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2206}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64548,"byte_end":64558,"line_start":2086,"line_end":2086,"column_start":26,"column_end":36},"kind":{"Impl":{"id":20}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":64968,"byte_end":64978,"line_start":2104,"line_end":2104,"column_start":38,"column_end":48},"kind":{"Impl":{"id":21}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":65215,"byte_end":65225,"line_start":2115,"line_end":2115,"column_start":42,"column_end":52},"kind":{"Impl":{"id":22}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":65460,"byte_end":65470,"line_start":2126,"line_end":2126,"column_start":36,"column_end":46},"kind":{"Impl":{"id":23}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":7285}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":66860,"byte_end":66870,"line_start":2179,"line_end":2179,"column_start":20,"column_end":30},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2045}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":66913,"byte_end":66923,"line_start":2181,"line_end":2181,"column_start":36,"column_end":46},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2077}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":67118,"byte_end":67128,"line_start":2188,"line_end":2188,"column_start":49,"column_end":59},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2077}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":67848,"byte_end":67853,"line_start":2212,"line_end":2212,"column_start":45,"column_end":50},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68034,"byte_end":68039,"line_start":2218,"line_end":2218,"column_start":35,"column_end":40},"kind":{"Impl":{"id":32}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68084,"byte_end":68089,"line_start":2219,"line_end":2219,"column_start":35,"column_end":40},"kind":{"Impl":{"id":33}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68126,"byte_end":68131,"line_start":2221,"line_end":2221,"column_start":26,"column_end":31},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68460,"byte_end":68465,"line_start":2236,"line_end":2236,"column_start":37,"column_end":42},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":3910}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":68667,"byte_end":68672,"line_start":2245,"line_end":2245,"column_start":22,"column_end":27},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":272},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":70138,"byte_end":70146,"line_start":2295,"line_end":2295,"column_start":36,"column_end":44},"kind":{"Impl":{"id":37}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":70295,"byte_end":70303,"line_start":2301,"line_end":2301,"column_start":9,"column_end":17},"kind":{"Impl":{"id":38}},"from":{"krate":0,"index":306},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72099,"byte_end":72107,"line_start":2360,"line_end":2360,"column_start":31,"column_end":39},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":1533}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72144,"byte_end":72152,"line_start":2361,"line_end":2361,"column_start":31,"column_end":39},"kind":{"Impl":{"id":40}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":1545}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":72181,"byte_end":72189,"line_start":2363,"line_end":2363,"column_start":22,"column_end":30},"kind":{"Impl":{"id":41}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":73412,"byte_end":73420,"line_start":2405,"line_end":2405,"column_start":33,"column_end":41},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":3910}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":74423,"byte_end":74431,"line_start":2442,"line_end":2442,"column_start":26,"column_end":34},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":2181}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":75058,"byte_end":75066,"line_start":2467,"line_end":2467,"column_start":18,"column_end":26},"kind":{"Impl":{"id":44}},"from":{"krate":0,"index":306},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":75358,"byte_end":75368,"line_start":2479,"line_end":2479,"column_start":26,"column_end":36},"kind":{"Impl":{"id":45}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":3951}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":77372,"byte_end":77382,"line_start":2547,"line_end":2547,"column_start":23,"column_end":33},"kind":{"Impl":{"id":46}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":3960}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":78933,"byte_end":78943,"line_start":2593,"line_end":2593,"column_start":33,"column_end":43},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":137},"to":{"krate":0,"index":359}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":81893,"byte_end":81903,"line_start":2692,"line_end":2692,"column_start":45,"column_end":55},"kind":{"Impl":{"id":48}},"from":{"krate":0,"index":137},"to":{"krate":0,"index":359}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":82994,"byte_end":83004,"line_start":2737,"line_end":2737,"column_start":35,"column_end":45},"kind":{"Impl":{"id":49}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":3947}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":83403,"byte_end":83416,"line_start":2753,"line_end":2753,"column_start":34,"column_end":47},"kind":{"Impl":{"id":50}},"from":{"krate":0,"index":386},"to":{"krate":0,"index":382}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":83598,"byte_end":83611,"line_start":2764,"line_end":2764,"column_start":36,"column_end":49},"kind":{"Impl":{"id":51}},"from":{"krate":0,"index":394},"to":{"krate":0,"index":382}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":84035,"byte_end":84040,"line_start":2781,"line_end":2781,"column_start":21,"column_end":26},"kind":"SuperTrait","from":{"krate":2,"index":1538},"to":{"krate":0,"index":402}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":84157,"byte_end":84158,"line_start":2786,"line_end":2786,"column_start":33,"column_end":34},"kind":{"Impl":{"id":52}},"from":{"krate":0,"index":405},"to":{"krate":0,"index":402}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":86331,"byte_end":86341,"line_start":2854,"line_end":2854,"column_start":42,"column_end":52},"kind":{"Impl":{"id":53}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":3960}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":86910,"byte_end":86916,"line_start":2875,"line_end":2875,"column_start":36,"column_end":42},"kind":{"Impl":{"id":54}},"from":{"krate":0,"index":1005},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":87196,"byte_end":87202,"line_start":2887,"line_end":2887,"column_start":47,"column_end":53},"kind":{"Impl":{"id":55}},"from":{"krate":0,"index":1005},"to":{"krate":2,"index":3910}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":87559,"byte_end":87565,"line_start":2901,"line_end":2901,"column_start":32,"column_end":38},"kind":{"Impl":{"id":56}},"from":{"krate":0,"index":1005},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":89295,"byte_end":89300,"line_start":2949,"line_end":2949,"column_start":13,"column_end":18},"kind":{"Impl":{"id":57}},"from":{"krate":0,"index":272},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":91239,"byte_end":91250,"line_start":3010,"line_end":3010,"column_start":29,"column_end":40},"kind":{"Impl":{"id":58}},"from":{"krate":0,"index":1014},"to":{"krate":2,"index":3653}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92392,"byte_end":92403,"line_start":3047,"line_end":3047,"column_start":25,"column_end":36},"kind":{"Impl":{"id":59}},"from":{"krate":0,"index":1014},"to":{"krate":2,"index":1726}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92691,"byte_end":92701,"line_start":3061,"line_end":3061,"column_start":33,"column_end":43},"kind":{"Impl":{"id":60}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2249}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\slice-deque-0.2.4\\src\\lib.rs","byte_start":92794,"byte_end":92804,"line_start":3067,"line_end":3067,"column_start":33,"column_end":43},"kind":{"Impl":{"id":61}},"from":{"krate":0,"index":137},"to":{"krate":2,"index":2252}}]}