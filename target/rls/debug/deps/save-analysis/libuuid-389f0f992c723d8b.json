{"config":{"output_file":null,"full_docs":true,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1","program":"C:\\Users\\chapm\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\bin\\rls.exe","arguments":["--edition=2018","--crate-name","uuid","C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","--cfg","feature=\"default\"","--cfg","feature=\"std\"","-C","metadata=389f0f992c723d8b","-C","extra-filename=-389f0f992c723d8b","--out-dir","c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","-L","dependency=c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps","--cap-lints","allow","--error-format=json","--sysroot","C:\\Users\\chapm\\.rustup/toolchains/stable-x86_64-pc-windows-msvc"],"output":"c:\\Users\\chapm\\Documents\\Projects\\git\\mosaic\\target\\rls\\debug\\deps\\libuuid-389f0f992c723d8b.rmeta"},"prelude":{"crate_id":{"name":"uuid","disambiguator":[5742253617729644857,6682826665848002942]},"crate_root":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src","external_crates":[{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":1,"id":{"name":"core","disambiguator":[14625317234859803032,6791610349458793748]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":2,"id":{"name":"compiler_builtins","disambiguator":[13367216100517456726,18240828775391475830]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":3,"id":{"name":"rustc_std_workspace_core","disambiguator":[5927333369983577022,15909913472650230380]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":4,"id":{"name":"std","disambiguator":[12580338268255904863,12487381105248359217]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":5,"id":{"name":"alloc","disambiguator":[4800340595136090738,11980400279241392758]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":6,"id":{"name":"libc","disambiguator":[16293423844334339663,11755502083335674850]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3461810660782397055,13833665689054202598]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[12998339428753072936,5307867808309457385]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[3374893436585051705,15533137816714572843]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[3128393747248474415,2329478791457811584]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":11,"id":{"name":"hashbrown","disambiguator":[6526974580395412454,5976980321596639697]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":12,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8056933235965822994,12193290402514539467]}},{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","num":13,"id":{"name":"panic_unwind","disambiguator":[16500325717628480317,8800586121391060646]}}],"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":481,"byte_end":31079,"line_start":12,"line_end":1030,"column_start":1,"column_end":2}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":229},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":5894,"byte_end":5901,"line_start":197,"line_end":197,"column_start":26,"column_end":33},"alias_span":null,"name":"Builder","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":234},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":5910,"byte_end":5915,"line_start":197,"line_end":197,"column_start":42,"column_end":47},"alias_span":null,"name":"Error","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":481,"byte_end":31079,"line_start":12,"line_end":1030,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":46},{"krate":0,"index":62},{"krate":0,"index":88},{"krate":0,"index":96},{"krate":0,"index":165},{"krate":0,"index":168},{"krate":0,"index":171},{"krate":0,"index":621},{"krate":0,"index":641},{"krate":0,"index":640},{"krate":0,"index":638},{"krate":0,"index":635},{"krate":0,"index":636},{"krate":0,"index":643},{"krate":0,"index":659},{"krate":0,"index":658},{"krate":0,"index":656},{"krate":0,"index":653},{"krate":0,"index":654},{"krate":0,"index":661},{"krate":0,"index":683},{"krate":0,"index":682},{"krate":0,"index":679},{"krate":0,"index":680},{"krate":0,"index":676},{"krate":0,"index":674},{"krate":0,"index":670},{"krate":0,"index":671},{"krate":0,"index":664},{"krate":0,"index":173},{"krate":0,"index":197},{"krate":0,"index":199},{"krate":0,"index":201},{"krate":0,"index":203},{"krate":0,"index":205},{"krate":0,"index":207},{"krate":0,"index":210}],"decl_id":null,"docs":" Generate and parse UUIDs.\n\n Provides support for Universally Unique Identifiers (UUIDs). A UUID is a\n unique 128-bit number, stored as 16 octets. UUIDs are used to  assign\n unique identifiers to entities without requiring a central allocating\n authority.\n\n They are particularly useful in distributed systems, though can be used in\n disparate areas, such as databases and network protocols.  Typically a UUID\n is displayed in a readable string form as a sequence of hexadecimal digits,\n separated into groups by hyphens.\n\n The uniqueness property is not strictly guaranteed, however for all\n practical purposes, it can be assumed that an unintentional collision would\n be extremely unlikely.\n\n # Dependencies\n\n By default, this crate depends on nothing but `std` and cannot generate\n UUIDs. You need to enable the following Cargo features to enable\n various pieces of functionality:\n\n * `v1` - adds the [`Uuid::new_v1`] function and the ability to create a V1\n   using an implementation of [`v1::ClockSequence`] (usually\n [`v1::Context`]) and a timestamp from `time::timespec`.\n * `v3` - adds the [`Uuid::new_v3`] function and the ability to create a V3\n   UUID based on the MD5 hash of some data.\n * `v4` - adds the [`Uuid::new_v4`] function and the ability to randomly\n   generate a UUID.\n * `v5` - adds the [`Uuid::new_v5`] function and the ability to create a V5\n   UUID based on the SHA1 hash of some data.\n * `serde` - adds the ability to serialize and deserialize a UUID using the\n   `serde` crate.\n\n You need to enable one of the following Cargo features together with\n `v3`, `v4` or `v5` feature if you're targeting `wasm32` architecture:\n\n * `stdweb` - enables support for `OsRng` on `wasm32-unknown-unknown` via\n   [`stdweb`] combined with [`cargo-web`]\n * `wasm-bindgen` - enables support for `OsRng` on `wasm32-unknown-unknown`\n   via [`wasm-bindgen`]\n\n By default, `uuid` can be depended on with:\n\n ```toml\n [dependencies]\n uuid = \"0.8\"\n ```\n\n To activate various features, use syntax like:\n\n ```toml\n [dependencies]\n uuid = { version = \"0.8\", features = [\"serde\", \"v4\"] }\n ```\n\n You can disable default features with:\n\n ```toml\n [dependencies]\n uuid = { version = \"0.8\", default-features = false }\n ```\n\n # Examples\n\n To parse a UUID given in the simple format and print it as a urn:\n\n ```rust\n use uuid::Uuid;\n\n fn main() {\n     let my_uuid =\n         Uuid::parse_str(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap();\n     println!(\"{}\", my_uuid.to_urn());\n }\n ```\n\n To create a new random (V4) UUID and print it out in hexadecimal form:\n\n ```ignore,rust\n // Note that this requires the `v4` feature enabled in the uuid crate.\n\n use uuid::Uuid;\n\n fn main() {\n     let my_uuid = Uuid::new_v4();\n     println!(\"{}\", my_uuid);\n }\n ```\n\n # Strings\n\n Examples of string representations:\n\n * simple: `936DA01F9ABD4d9d80C702AF85C822A8`\n * hyphenated: `550e8400-e29b-41d4-a716-446655440000`\n * urn: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n\n # References\n\n * [Wikipedia: Universally Unique\n   Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)\n * [RFC4122: A Universally Unique IDentifier (UUID) URN\n   Namespace](http://tools.ietf.org/html/rfc4122)\n\n [`wasm-bindgen`]: https://crates.io/crates/wasm-bindgen\n [`cargo-web`]: https://crates.io/crates/cargo-web\n [`stdweb`]: https://crates.io/crates/stdweb\n [`Uuid`]: struct.Uuid.html\n [`Uuid::new_v1`]: struct.Uuid.html#method.new_v1\n [`Uuid::new_v3`]: struct.Uuid.html#method.new_v3\n [`Uuid::new_v4`]: struct.Uuid.html#method.new_v4\n [`Uuid::new_v5`]: struct.Uuid.html#method.new_v5\n [`v1::ClockSequence`]: v1/trait.ClockSequence.html\n [`v1::Context`]: v1/struct.Context.html\n","sig":null,"attributes":[{"value":"no_std","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":4485,"byte_end":4495,"line_start":128,"line_end":128,"column_start":1,"column_end":11}},{"value":"deny(missing_debug_implementations, missing_docs)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":4496,"byte_end":4549,"line_start":129,"line_end":129,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":21},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":32288,"byte_end":32291,"line_start":43,"line_end":43,"column_start":18,"column_end":21},"name":"nil","qualname":"<Uuid>::nil","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" The 'nil UUID'.\n\n The nil UUID is special form of UUID that is specified to have all\n 128 bits set to zero, as defined in [IETF RFC 4122 Section 4.1.7][RFC].\n\n [RFC]: https://tools.ietf.org/html/rfc4122.html#section-4.1.7\n\n # Examples\n\n Basic usage:\n\n ```\n use uuid::Uuid;\n\n let uuid = Uuid::nil();\n\n assert_eq!(\n     uuid.to_hyphenated().to_string(),\n     \"00000000-0000-0000-0000-000000000000\"\n );\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":23},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":32986,"byte_end":32997,"line_start":70,"line_end":70,"column_start":12,"column_end":23},"name":"from_fields","qualname":"<Uuid>::from_fields","value":"fn (d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Result<Uuid, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID from four field values in big-endian order.\n\n # Errors\n\n This function will return an error if `d4`'s length is not 8 bytes.\n\n # Examples\n\n Basic usage:\n\n ```\n use uuid::Uuid;\n\n let d4 = [12, 3, 9, 56, 54, 43, 8, 9];\n\n let uuid = Uuid::from_fields(42, 12, 5, &d4);\n let uuid = uuid.map(|uuid| uuid.to_hyphenated().to_string());\n\n let expected_uuid =\n     Ok(String::from(\"0000002a-000c-0005-0c03-0938362b0809\"));\n\n assert_eq!(expected_uuid, uuid);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":25},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":34372,"byte_end":34386,"line_start":127,"line_end":127,"column_start":12,"column_end":26},"name":"from_fields_le","qualname":"<Uuid>::from_fields_le","value":"fn (d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Result<Uuid, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID from four field values in little-endian order.\n\n The bytes in the `d1`, `d2` and `d3` fields will\n be converted into big-endian order.\n\n # Examples\n\n ```\n use uuid::Uuid;\n\n let d1 = 0xAB3F1097u32;\n let d2 = 0x501Eu16;\n let d3 = 0xB736u16;\n let d4 = [12, 3, 9, 56, 54, 43, 8, 9];\n\n let uuid = Uuid::from_fields_le(d1, d2, d3, &d4);\n let uuid = uuid.map(|uuid| uuid.to_hyphenated().to_string());\n\n let expected_uuid =\n     Ok(String::from(\"97103fab-1e50-36b7-0c03-0938362b0809\"));\n\n assert_eq!(expected_uuid, uuid);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":27},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":35137,"byte_end":35146,"line_start":162,"line_end":162,"column_start":18,"column_end":27},"name":"from_u128","qualname":"<Uuid>::from_u128","value":"fn (v: u128) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID from a 128bit value in big-endian order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":28},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":35753,"byte_end":35765,"line_start":184,"line_end":184,"column_start":18,"column_end":30},"name":"from_u128_le","qualname":"<Uuid>::from_u128_le","value":"fn (v: u128) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID from a 128bit value in little-endian order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":29},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":37207,"byte_end":37217,"line_start":240,"line_end":240,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<Uuid>::from_slice","value":"fn (b: &[u8]) -> Result<Uuid, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID using the supplied big-endian bytes.\n\n # Errors\n\n This function will return an error if `b` has any length other than 16.\n\n # Examples\n\n Basic usage:\n\n ```\n use uuid::Uuid;\n\n let bytes = [4, 54, 67, 12, 43, 2, 98, 76, 32, 50, 87, 5, 1, 33, 43, 87];\n\n let uuid = Uuid::from_slice(&bytes);\n let uuid = uuid.map(|uuid| uuid.to_hyphenated().to_string());\n\n let expected_uuid =\n     Ok(String::from(\"0436430c-2b02-624c-2032-570501212b57\"));\n\n assert_eq!(expected_uuid, uuid);\n ```\n\n An incorrect number of bytes:\n\n ```\n use uuid::Uuid;\n\n let bytes = [4, 54, 67, 12, 43, 2, 98, 76];\n\n let uuid = Uuid::from_slice(&bytes);\n\n assert!(uuid.is_err());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":32},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":37607,"byte_end":37617,"line_start":255,"line_end":255,"column_start":18,"column_end":28},"name":"from_bytes","qualname":"<Uuid>::from_bytes","value":"fn (bytes: Bytes) -> Uuid","parent":null,"children":[],"decl_id":null,"docs":" Creates a UUID using the supplied big-endian bytes.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":229},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":38219,"byte_end":38226,"line_start":281,"line_end":281,"column_start":12,"column_end":19},"name":"Builder","qualname":"::builder::Builder","value":"","parent":null,"children":[],"decl_id":null,"docs":" A builder struct for creating a UUID.\n\n # Examples\n\n Creating a v4 UUID from externally generated bytes:\n\n ```\n use uuid::{Builder, Variant, Version};\n\n # let rng = || [\n #     70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90,\n # 145, 63, 62,\n # ];\n let random_bytes = rng();\n let uuid = Builder::from_bytes(random_bytes)\n     .set_variant(Variant::RFC4122)\n     .set_version(Version::Random)\n     .build();\n ```\n","sig":null,"attributes":[{"value":"allow(missing_copy_implementations)","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":38152,"byte_end":38190,"line_start":279,"line_end":279,"column_start":1,"column_end":39}}]},{"kind":"Method","id":{"krate":0,"index":34},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":39065,"byte_end":39075,"line_start":310,"line_end":310,"column_start":18,"column_end":28},"name":"from_bytes","qualname":"<Builder>::from_bytes","value":"fn (b: Bytes) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a `Builder` using the supplied big-endian bytes.\n\n # Examples\n\n Basic usage:\n\n ```\n let bytes: uuid::Bytes = [\n     70, 235, 208, 238, 14, 109, 67, 201, 185, 13, 204, 195, 90, 145, 63, 62,\n ];\n\n let mut builder = uuid::Builder::from_bytes(bytes);\n let uuid = builder.build().to_hyphenated().to_string();\n\n let expected_uuid = String::from(\"46ebd0ee-0e6d-43c9-b90d-ccc35a913f3e\");\n\n assert_eq!(expected_uuid, uuid);\n ```\n\n An incorrect number of bytes:\n\n ```compile_fail\n let bytes: uuid::Bytes = [4, 54, 67, 12, 43, 2, 98, 76]; // doesn't compile\n\n let uuid = uuid::Builder::from_bytes(bytes);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":35},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":40042,"byte_end":40052,"line_start":346,"line_end":346,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<Builder>::from_slice","value":"fn (b: &[u8]) -> Result<Self, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `Builder` using the supplied big-endian bytes.\n\n # Errors\n\n This function will return an error if `b` has any length other than 16.\n\n # Examples\n\n Basic usage:\n\n ```\n let bytes = [4, 54, 67, 12, 43, 2, 98, 76, 32, 50, 87, 5, 1, 33, 43, 87];\n\n let builder = uuid::Builder::from_slice(&bytes);\n let uuid =\n     builder.map(|mut builder| builder.build().to_hyphenated().to_string());\n\n let expected_uuid =\n     Ok(String::from(\"0436430c-2b02-624c-2032-570501212b57\"));\n\n assert_eq!(expected_uuid, uuid);\n ```\n\n An incorrect number of bytes:\n\n ```\n let bytes = [4, 54, 67, 12, 43, 2, 98, 76];\n\n let builder = uuid::Builder::from_slice(&bytes);\n\n assert!(builder.is_err());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":38},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":41229,"byte_end":41240,"line_start":392,"line_end":392,"column_start":12,"column_end":23},"name":"from_fields","qualname":"<Builder>::from_fields","value":"fn (d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Result<Self, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `Builder` from four big-endian field values.\n\n # Errors\n\n This function will return an error if `d4`'s length is not 8 bytes.\n\n # Examples\n\n Basic usage:\n\n ```\n let d4 = [12, 3, 9, 56, 54, 43, 8, 9];\n\n let builder = uuid::Builder::from_fields(42, 12, 5, &d4);\n let uuid =\n     builder.map(|mut builder| builder.build().to_hyphenated().to_string());\n\n let expected_uuid =\n     Ok(String::from(\"0000002a-000c-0005-0c03-0938362b0809\"));\n\n assert_eq!(expected_uuid, uuid);\n ```\n\n An invalid length:\n\n ```\n let d4 = [12];\n\n let builder = uuid::Builder::from_fields(42, 12, 5, &d4);\n\n assert!(builder.is_err());\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":40},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":41576,"byte_end":41585,"line_start":406,"line_end":406,"column_start":12,"column_end":21},"name":"from_u128","qualname":"<Builder>::from_u128","value":"fn (v: u128) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a `Builder` from a big-endian 128bit value.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":41},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":42060,"byte_end":42063,"line_start":426,"line_end":426,"column_start":18,"column_end":21},"name":"nil","qualname":"<Builder>::nil","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a `Builder` with an initial [`Uuid::nil`].\n\n # Examples\n\n Basic usage:\n\n ```\n use uuid::Builder;\n\n let mut builder = Builder::nil();\n\n assert_eq!(\n     builder.build().to_hyphenated().to_string(),\n     \"00000000-0000-0000-0000-000000000000\"\n );\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":43},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":42162,"byte_end":42173,"line_start":431,"line_end":431,"column_start":12,"column_end":23},"name":"set_variant","qualname":"<Builder>::set_variant","value":"fn (&mut self, v: crate::Variant) -> &mut Self","parent":null,"children":[],"decl_id":null,"docs":" Specifies the variant of the UUID.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":44},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":42605,"byte_end":42616,"line_start":445,"line_end":445,"column_start":12,"column_end":23},"name":"set_version","qualname":"<Builder>::set_version","value":"fn (&mut self, v: crate::Version) -> &mut Self","parent":null,"children":[],"decl_id":null,"docs":" Specifies the version number of the UUID.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":45},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":43152,"byte_end":43157,"line_start":469,"line_end":469,"column_start":12,"column_end":17},"name":"build","qualname":"<Builder>::build","value":"fn (&mut self) -> Uuid","parent":null,"children":[],"decl_id":null,"docs":" Hands over the internal constructed [`Uuid`].\n\n # Examples\n\n Basic usage:\n\n ```\n use uuid::Builder;\n\n let uuid = Builder::nil().build();\n\n assert_eq!(\n     uuid.to_hyphenated().to_string(),\n     \"00000000-0000-0000-0000-000000000000\"\n );\n ```\n\n [`Uuid`]: struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":234},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":44563,"byte_end":44568,"line_start":8,"line_end":8,"column_start":12,"column_end":17},"name":"Error","qualname":"::error::Error","value":"","parent":null,"children":[],"decl_id":null,"docs":" A general error that can occur when working with UUIDs.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":86},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\mod.rs","byte_start":47979,"byte_end":47988,"line_start":57,"line_end":57,"column_start":12,"column_end":21},"name":"parse_str","qualname":"<Uuid>::parse_str","value":"fn (mut input: &str) -> Result<Uuid, crate::Error>","parent":null,"children":[],"decl_id":null,"docs":" Parses a `Uuid` from a string of hexadecimal digits with optional\n hyphens.\n\n Any of the formats generated by this module (simple, hyphenated, urn)\n are supported by this parsing function.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":96},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"adapter","qualname":"::adapter","value":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","parent":null,"children":[{"krate":0,"index":97},{"krate":0,"index":98},{"krate":0,"index":354},{"krate":0,"index":380},{"krate":0,"index":379},{"krate":0,"index":377},{"krate":0,"index":375},{"krate":0,"index":372},{"krate":0,"index":373},{"krate":0,"index":369},{"krate":0,"index":367},{"krate":0,"index":363},{"krate":0,"index":364},{"krate":0,"index":357},{"krate":0,"index":382},{"krate":0,"index":416},{"krate":0,"index":414},{"krate":0,"index":411},{"krate":0,"index":406},{"krate":0,"index":408},{"krate":0,"index":402},{"krate":0,"index":399},{"krate":0,"index":393},{"krate":0,"index":395},{"krate":0,"index":386},{"krate":0,"index":419},{"krate":0,"index":445},{"krate":0,"index":444},{"krate":0,"index":442},{"krate":0,"index":440},{"krate":0,"index":437},{"krate":0,"index":438},{"krate":0,"index":434},{"krate":0,"index":432},{"krate":0,"index":428},{"krate":0,"index":429},{"krate":0,"index":422},{"krate":0,"index":447},{"krate":0,"index":481},{"krate":0,"index":479},{"krate":0,"index":476},{"krate":0,"index":471},{"krate":0,"index":473},{"krate":0,"index":467},{"krate":0,"index":464},{"krate":0,"index":458},{"krate":0,"index":460},{"krate":0,"index":451},{"krate":0,"index":484},{"krate":0,"index":510},{"krate":0,"index":509},{"krate":0,"index":507},{"krate":0,"index":505},{"krate":0,"index":502},{"krate":0,"index":503},{"krate":0,"index":499},{"krate":0,"index":497},{"krate":0,"index":493},{"krate":0,"index":494},{"krate":0,"index":487},{"krate":0,"index":512},{"krate":0,"index":546},{"krate":0,"index":544},{"krate":0,"index":541},{"krate":0,"index":536},{"krate":0,"index":538},{"krate":0,"index":532},{"krate":0,"index":529},{"krate":0,"index":523},{"krate":0,"index":525},{"krate":0,"index":516},{"krate":0,"index":101},{"krate":0,"index":108},{"krate":0,"index":110},{"krate":0,"index":112},{"krate":0,"index":114},{"krate":0,"index":116},{"krate":0,"index":118},{"krate":0,"index":125},{"krate":0,"index":133},{"krate":0,"index":140},{"krate":0,"index":148},{"krate":0,"index":155},{"krate":0,"index":163},{"krate":0,"index":164},{"krate":0,"index":549},{"krate":0,"index":551},{"krate":0,"index":554},{"krate":0,"index":606},{"krate":0,"index":557},{"krate":0,"index":560},{"krate":0,"index":564},{"krate":0,"index":608},{"krate":0,"index":568},{"krate":0,"index":570},{"krate":0,"index":573},{"krate":0,"index":611},{"krate":0,"index":576},{"krate":0,"index":579},{"krate":0,"index":583},{"krate":0,"index":613},{"krate":0,"index":587},{"krate":0,"index":589},{"krate":0,"index":592},{"krate":0,"index":616},{"krate":0,"index":595},{"krate":0,"index":598},{"krate":0,"index":602},{"krate":0,"index":618}],"decl_id":null,"docs":" Adapters for various formats for UUIDs\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":354},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":68634,"byte_end":68644,"line_start":26,"line_end":26,"column_start":12,"column_end":22},"name":"Hyphenated","qualname":"::adapter::Hyphenated","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a hyphenated string.\n\n Takes an owned instance of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":382},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":68879,"byte_end":68892,"line_start":34,"line_end":34,"column_start":12,"column_end":25},"name":"HyphenatedRef","qualname":"::adapter::HyphenatedRef","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a hyphenated string.\n\n Takes a reference of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":419},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69146,"byte_end":69152,"line_start":42,"line_end":42,"column_start":12,"column_end":18},"name":"Simple","qualname":"::adapter::Simple","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a simple string.\n\n Takes an owned instance of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":447},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69383,"byte_end":69392,"line_start":50,"line_end":50,"column_start":12,"column_end":21},"name":"SimpleRef","qualname":"::adapter::SimpleRef","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a simple string.\n\n Takes a reference of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":484},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69643,"byte_end":69646,"line_start":58,"line_end":58,"column_start":12,"column_end":15},"name":"Urn","qualname":"::adapter::Urn","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a URN string.\n\n Takes an owned instance of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":512},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69874,"byte_end":69880,"line_start":66,"line_end":66,"column_start":12,"column_end":18},"name":"UrnRef","qualname":"::adapter::UrnRef","value":"","parent":null,"children":[],"decl_id":null,"docs":" An adaptor for formatting an [`Uuid`] as a URN string.\n\n Takes a reference of the [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":102},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70043,"byte_end":70056,"line_start":73,"line_end":73,"column_start":18,"column_end":31},"name":"to_hyphenated","qualname":"<Uuid>::to_hyphenated","value":"fn (self) -> Hyphenated","parent":null,"children":[],"decl_id":null,"docs":" Get a [`Hyphenated`] formatter.\n\n [`Hyphenated`]: adapter/struct.Hyphenated.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70016,"byte_end":70025,"line_start":72,"line_end":72,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":103},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70274,"byte_end":70291,"line_start":81,"line_end":81,"column_start":18,"column_end":35},"name":"to_hyphenated_ref","qualname":"<Uuid>::to_hyphenated_ref","value":"fn (&self) -> HyphenatedRef<'_>","parent":null,"children":[],"decl_id":null,"docs":" Get a borrowed [`HyphenatedRef`] formatter.\n\n [`HyphenatedRef`]: adapter/struct.HyphenatedRef.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70247,"byte_end":70256,"line_start":80,"line_end":80,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":104},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70494,"byte_end":70503,"line_start":89,"line_end":89,"column_start":18,"column_end":27},"name":"to_simple","qualname":"<Uuid>::to_simple","value":"fn (self) -> Simple","parent":null,"children":[],"decl_id":null,"docs":" Get a [`Simple`] formatter.\n\n [`Simple`]: adapter/struct.Simple.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70467,"byte_end":70476,"line_start":88,"line_end":88,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":105},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70701,"byte_end":70714,"line_start":97,"line_end":97,"column_start":18,"column_end":31},"name":"to_simple_ref","qualname":"<Uuid>::to_simple_ref","value":"fn (&self) -> SimpleRef<'_>","parent":null,"children":[],"decl_id":null,"docs":" Get a borrowed [`SimpleRef`] formatter.\n\n [`SimpleRef`]: adapter/struct.SimpleRef.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70674,"byte_end":70683,"line_start":96,"line_end":96,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":106},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70938,"byte_end":70944,"line_start":106,"line_end":106,"column_start":18,"column_end":24},"name":"to_urn","qualname":"<Uuid>::to_urn","value":"fn (self) -> Urn","parent":null,"children":[],"decl_id":null,"docs":" Get a [`Urn`] formatter.\n\n [`Uuid`]: ../struct.Uuid.html\n [`Urn`]: adapter/struct.Urn.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":70911,"byte_end":70920,"line_start":105,"line_end":105,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":107},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":71165,"byte_end":71175,"line_start":115,"line_end":115,"column_start":18,"column_end":28},"name":"to_urn_ref","qualname":"<Uuid>::to_urn_ref","value":"fn (&self) -> UrnRef<'_>","parent":null,"children":[],"decl_id":null,"docs":" Get a borrowed [`UrnRef`] formatter.\n\n [`Uuid`]: ../struct.Uuid.html\n [`UrnRef`]: adapter/struct.UrnRef.html\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":71138,"byte_end":71147,"line_start":114,"line_end":114,"column_start":5,"column_end":14}}]},{"kind":"Const","id":{"krate":0,"index":119},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":73451,"byte_end":73457,"line_start":184,"line_end":184,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::Hyphenated::LENGTH","value":"usize","parent":{"krate":0,"index":118},"children":[],"decl_id":null,"docs":" The length of a hyphenated [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":120},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":73632,"byte_end":73641,"line_start":190,"line_end":190,"column_start":18,"column_end":27},"name":"from_uuid","qualname":"<Hyphenated>::from_uuid","value":"fn (uuid: Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`Hyphenated`] from a [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n [`Hyphenated`]: struct.Hyphenated.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":121},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":75132,"byte_end":75144,"line_start":236,"line_end":236,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<Hyphenated>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case hyphenated string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_hyphenated()\n         .encode_lower(&mut Uuid::encode_buffer()),\n     \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 40];\n uuid.to_hyphenated().encode_lower(&mut buf);\n assert_eq!(\n     &buf as &[_],\n     b\"936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":123},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":76693,"byte_end":76705,"line_start":282,"line_end":282,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<Hyphenated>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case hyphenated string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_hyphenated()\n         .encode_upper(&mut Uuid::encode_buffer()),\n     \"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 40];\n uuid.to_hyphenated().encode_upper(&mut buf);\n assert_eq!(\n     &buf as &[_],\n     b\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":127},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":76959,"byte_end":76965,"line_start":291,"line_end":291,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::HyphenatedRef::<'a>::LENGTH","value":"usize","parent":{"krate":0,"index":125},"children":[],"decl_id":null,"docs":" The length of a hyphenated [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":128},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":77159,"byte_end":77172,"line_start":297,"line_end":297,"column_start":18,"column_end":31},"name":"from_uuid_ref","qualname":"<HyphenatedRef>::from_uuid_ref","value":"fn (uuid: &'a Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`HyphenatedRef`] from a [`Uuid`] reference.\n\n [`Uuid`]: ../struct.Uuid.html\n [`HyphenatedRef`]: struct.HyphenatedRef.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":129},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":78809,"byte_end":78821,"line_start":347,"line_end":347,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<HyphenatedRef>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case hyphenated string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_hyphenated()\n         .encode_lower(&mut Uuid::encode_buffer()),\n     \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 40];\n uuid.to_hyphenated().encode_lower(&mut buf);\n assert_eq!(\n     uuid.to_hyphenated().encode_lower(&mut buf),\n     \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":131},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":80455,"byte_end":80467,"line_start":396,"line_end":396,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<HyphenatedRef>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case hyphenated string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_hyphenated()\n         .encode_upper(&mut Uuid::encode_buffer()),\n     \"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 40];\n assert_eq!(\n     uuid.to_hyphenated().encode_upper(&mut buf),\n     \"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":134},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":80701,"byte_end":80707,"line_start":405,"line_end":405,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::Simple::LENGTH","value":"usize","parent":{"krate":0,"index":133},"children":[],"decl_id":null,"docs":" The length of a simple [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":135},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":80870,"byte_end":80879,"line_start":411,"line_end":411,"column_start":18,"column_end":27},"name":"from_uuid","qualname":"<Simple>::from_uuid","value":"fn (uuid: Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`Simple`] from a [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n [`Simple`]: struct.Simple.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":136},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":82403,"byte_end":82415,"line_start":458,"line_end":458,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<Simple>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case simple string to `buffer`,\n and returns the subslice of the buffer that contains the encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_simple().encode_lower(&mut Uuid::encode_buffer()),\n     \"936da01f9abd4d9d80c702af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 36];\n assert_eq!(\n     uuid.to_simple().encode_lower(&mut buf),\n     \"936da01f9abd4d9d80c702af85c822a8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936da01f9abd4d9d80c702af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":138},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":83837,"byte_end":83849,"line_start":501,"line_end":501,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<Simple>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case simple string to `buffer`,\n and returns the subslice of the buffer that contains the encoded UUID.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_simple().encode_upper(&mut Uuid::encode_buffer()),\n     \"936DA01F9ABD4D9D80C702AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 36];\n assert_eq!(\n     uuid.to_simple().encode_upper(&mut buf),\n     \"936DA01F9ABD4D9D80C702AF85C822A8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936DA01F9ABD4D9D80C702AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":142},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":84096,"byte_end":84102,"line_start":510,"line_end":510,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::SimpleRef::<'a>::LENGTH","value":"usize","parent":{"krate":0,"index":140},"children":[],"decl_id":null,"docs":" The length of a simple [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":143},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":84284,"byte_end":84297,"line_start":516,"line_end":516,"column_start":18,"column_end":31},"name":"from_uuid_ref","qualname":"<SimpleRef>::from_uuid_ref","value":"fn (uuid: &'a Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`SimpleRef`] from a [`Uuid`] reference.\n\n [`Uuid`]: ../struct.Uuid.html\n [`SimpleRef`]: struct.SimpleRef.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":144},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":85828,"byte_end":85840,"line_start":563,"line_end":563,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<SimpleRef>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case simple string to `buffer`,\n and returns the subslice of the buffer that contains the encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_simple().encode_lower(&mut Uuid::encode_buffer()),\n     \"936da01f9abd4d9d80c702af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 36];\n assert_eq!(\n     uuid.to_simple().encode_lower(&mut buf),\n     \"936da01f9abd4d9d80c702af85c822a8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936da01f9abd4d9d80c702af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":146},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":87261,"byte_end":87273,"line_start":606,"line_end":606,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<SimpleRef>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case simple string to `buffer`,\n and returns the subslice of the buffer that contains the encoded UUID.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_simple().encode_upper(&mut Uuid::encode_buffer()),\n     \"936DA01F9ABD4D9D80C702AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 36];\n assert_eq!(\n     uuid.to_simple().encode_upper(&mut buf),\n     \"936DA01F9ABD4D9D80C702AF85C822A8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"936DA01F9ABD4D9D80C702AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":149},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":87502,"byte_end":87508,"line_start":615,"line_end":615,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::Urn::LENGTH","value":"usize","parent":{"krate":0,"index":148},"children":[],"decl_id":null,"docs":" The length of a URN [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":150},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":87662,"byte_end":87671,"line_start":621,"line_end":621,"column_start":18,"column_end":27},"name":"from_uuid","qualname":"<Urn>::from_uuid","value":"fn (uuid: Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`Urn`] from a [`Uuid`].\n\n [`Uuid`]: ../struct.Uuid.html\n [`Urn`]: struct.Urn.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":151},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":89276,"byte_end":89288,"line_start":670,"line_end":670,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<Urn>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case URN string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_urn().encode_lower(&mut Uuid::encode_buffer()),\n     \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 49];\n uuid.to_urn().encode_lower(&mut buf);\n assert_eq!(\n     uuid.to_urn().encode_lower(&mut buf),\n     \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":153},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":90963,"byte_end":90975,"line_start":719,"line_end":719,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<Urn>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case URN string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_urn().encode_upper(&mut Uuid::encode_buffer()),\n     \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 49];\n assert_eq!(\n     uuid.to_urn().encode_upper(&mut buf),\n     \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":157},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":91266,"byte_end":91272,"line_start":729,"line_end":729,"column_start":15,"column_end":21},"name":"LENGTH","qualname":"::adapter::UrnRef::<'a>::LENGTH","value":"usize","parent":{"krate":0,"index":155},"children":[],"decl_id":null,"docs":" The length of a URN [`Uuid`] string.\n\n [`Uuid`]: ../struct.Uuid.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":158},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":91445,"byte_end":91458,"line_start":735,"line_end":735,"column_start":18,"column_end":31},"name":"from_uuid_ref","qualname":"<UrnRef>::from_uuid_ref","value":"fn (uuid: &'a Uuid) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`UrnRef`] from a [`Uuid`] reference.\n\n [`Uuid`]: ../struct.Uuid.html\n [`UrnRef`]: struct.UrnRef.html\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":159},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":93071,"byte_end":93083,"line_start":784,"line_end":784,"column_start":12,"column_end":24},"name":"encode_lower","qualname":"<UrnRef>::encode_lower","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as a lower-case URN string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_urn().encode_lower(&mut Uuid::encode_buffer()),\n     \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 49];\n uuid.to_urn().encode_lower(&mut buf);\n assert_eq!(\n     uuid.to_urn().encode_lower(&mut buf),\n     \"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":161},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":94757,"byte_end":94769,"line_start":833,"line_end":833,"column_start":12,"column_end":24},"name":"encode_upper","qualname":"<UrnRef>::encode_upper","value":"fn <'buf> (&self, buffer: &'buf mut [u8]) -> &'buf mut str","parent":null,"children":[],"decl_id":null,"docs":" Writes the [`Uuid`] as an upper-case URN string to\n `buffer`, and returns the subslice of the buffer that contains the\n encoded UUID.\n\n This is slightly more efficient than using the formatting\n infrastructure as it avoids virtual calls, and may avoid\n double buffering.\n\n [`Uuid`]: ../struct.Uuid.html\n\n # Panics\n\n Panics if the buffer is not large enough: it must have length at least\n [`LENGTH`]. [`Uuid::encode_buffer`] can be used to get a\n sufficiently-large temporary buffer.\n\n [`LENGTH`]: #associatedconstant.LENGTH\n [`Uuid::encode_buffer`]: ../struct.Uuid.html#method.encode_buffer\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936da01f9abd4d9d80c702af85c822a8\").unwrap();\n\n // the encoded portion is returned\n assert_eq!(\n     uuid.to_urn().encode_upper(&mut Uuid::encode_buffer()),\n     \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n\n // the buffer is mutated directly, and trailing contents remains\n let mut buf = [b'!'; 49];\n assert_eq!(\n     uuid.to_urn().encode_upper(&mut buf),\n     \"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8\"\n );\n assert_eq!(\n     &buf as &[_],\n     b\"urn:uuid:936DA01F-9ABD-4D9D-80C7-02AF85C822A8!!!!\" as &[_]\n );\n ```\n */\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":171},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":5978,"byte_end":5983,"line_start":200,"line_end":200,"column_start":10,"column_end":15},"name":"Bytes","qualname":"::Bytes","value":"[u8; 16]","parent":null,"children":[],"decl_id":null,"docs":" A 128-bit (16 byte) buffer containing the ID.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":622},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6162,"byte_end":6165,"line_start":206,"line_end":206,"column_start":5,"column_end":8},"name":"Nil","qualname":"::Version::Nil","value":"Version::Nil","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Special case for `nil` UUID.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":625},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6207,"byte_end":6210,"line_start":208,"line_end":208,"column_start":5,"column_end":8},"name":"Mac","qualname":"::Version::Mac","value":"Version::Mac","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Version 1: MAC address.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":627},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6249,"byte_end":6252,"line_start":210,"line_end":210,"column_start":5,"column_end":8},"name":"Dce","qualname":"::Version::Dce","value":"Version::Dce","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Version 2: DCE Security.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":629},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6287,"byte_end":6290,"line_start":212,"line_end":212,"column_start":5,"column_end":8},"name":"Md5","qualname":"::Version::Md5","value":"Version::Md5","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Version 3: MD5 hash.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":631},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6323,"byte_end":6329,"line_start":214,"line_end":214,"column_start":5,"column_end":11},"name":"Random","qualname":"::Version::Random","value":"Version::Random","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Version 4: Random.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":633},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6366,"byte_end":6370,"line_start":216,"line_end":216,"column_start":5,"column_end":9},"name":"Sha1","qualname":"::Version::Sha1","value":"Version::Sha1","parent":{"krate":0,"index":621},"children":[],"decl_id":null,"docs":" Version 5: SHA-1 hash.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":621},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6111,"byte_end":6118,"line_start":204,"line_end":204,"column_start":10,"column_end":17},"name":"Version","qualname":"::Version","value":"Version::{Nil, Mac, Dce, Md5, Random, Sha1}","parent":null,"children":[{"krate":0,"index":622},{"krate":0,"index":625},{"krate":0,"index":627},{"krate":0,"index":629},{"krate":0,"index":631},{"krate":0,"index":633}],"decl_id":null,"docs":" The version of the UUID, denoting the generating algorithm.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":644},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6531,"byte_end":6534,"line_start":223,"line_end":223,"column_start":5,"column_end":8},"name":"NCS","qualname":"::Variant::NCS","value":"Variant::NCS","parent":{"krate":0,"index":643},"children":[],"decl_id":null,"docs":" Reserved by the NCS for backward compatibility.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":647},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6605,"byte_end":6612,"line_start":225,"line_end":225,"column_start":5,"column_end":12},"name":"RFC4122","qualname":"::Variant::RFC4122","value":"Variant::RFC4122","parent":{"krate":0,"index":643},"children":[],"decl_id":null,"docs":" As described in the RFC4122 Specification (default).\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":649},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6676,"byte_end":6685,"line_start":227,"line_end":227,"column_start":5,"column_end":14},"name":"Microsoft","qualname":"::Variant::Microsoft","value":"Variant::Microsoft","parent":{"krate":0,"index":643},"children":[],"decl_id":null,"docs":" Reserved by Microsoft for backward compatibility.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":651},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6730,"byte_end":6736,"line_start":229,"line_end":229,"column_start":5,"column_end":11},"name":"Future","qualname":"::Variant::Future","value":"Variant::Future","parent":{"krate":0,"index":643},"children":[],"decl_id":null,"docs":" Reserved for future expansion.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":643},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6461,"byte_end":6468,"line_start":221,"line_end":221,"column_start":10,"column_end":17},"name":"Variant","qualname":"::Variant","value":"Variant::{NCS, RFC4122, Microsoft, Future}","parent":null,"children":[{"krate":0,"index":644},{"krate":0,"index":647},{"krate":0,"index":649},{"krate":0,"index":651}],"decl_id":null,"docs":" The reserved variants of UUIDs.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":661},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6857,"byte_end":6861,"line_start":234,"line_end":234,"column_start":12,"column_end":16},"name":"Uuid","qualname":"::Uuid","value":"","parent":null,"children":[],"decl_id":null,"docs":" A Universally Unique Identifier (UUID).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":174},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6950,"byte_end":6963,"line_start":238,"line_end":238,"column_start":15,"column_end":28},"name":"NAMESPACE_DNS","qualname":"::Uuid::NAMESPACE_DNS","value":"Self","parent":{"krate":0,"index":173},"children":[],"decl_id":null,"docs":" UUID namespace for Domain Name System (DNS).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":175},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":7172,"byte_end":7185,"line_start":244,"line_end":244,"column_start":15,"column_end":28},"name":"NAMESPACE_OID","qualname":"::Uuid::NAMESPACE_OID","value":"Self","parent":{"krate":0,"index":173},"children":[],"decl_id":null,"docs":" UUID namespace for ISO Object Identifiers (OIDs).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":176},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":7397,"byte_end":7410,"line_start":250,"line_end":250,"column_start":15,"column_end":28},"name":"NAMESPACE_URL","qualname":"::Uuid::NAMESPACE_URL","value":"Self","parent":{"krate":0,"index":173},"children":[],"decl_id":null,"docs":" UUID namespace for Uniform Resource Locators (URLs).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":177},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":7621,"byte_end":7635,"line_start":256,"line_end":256,"column_start":15,"column_end":29},"name":"NAMESPACE_X500","qualname":"::Uuid::NAMESPACE_X500","value":"Self","parent":{"krate":0,"index":173},"children":[],"decl_id":null,"docs":" UUID namespace for X.500 Distinguished Names (DNs).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":178},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":8075,"byte_end":8086,"line_start":267,"line_end":267,"column_start":12,"column_end":23},"name":"get_variant","qualname":"<Uuid>::get_variant","value":"fn (&self) -> Option<Variant>","parent":null,"children":[],"decl_id":null,"docs":" Returns the variant of the UUID structure.\n\n This determines the interpretation of the structure of the UUID.\n Currently only the RFC4122 variant is generated by this module.\n\n * [Variant Reference](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":179},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":8972,"byte_end":8987,"line_start":288,"line_end":288,"column_start":18,"column_end":33},"name":"get_version_num","qualname":"<Uuid>::get_version_num","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the version number of the UUID.\n\n This represents the algorithm used to generate the contents.\n\n Currently only the Random (V4) algorithm is supported by this\n module.  There are security and privacy implications for using\n older versions - see [Wikipedia: Universally Unique Identifier](\n http://en.wikipedia.org/wiki/Universally_unique_identifier) for\n details.\n\n * [Version Reference](http://tools.ietf.org/html/rfc4122#section-4.1.3)\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":180},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":9184,"byte_end":9195,"line_start":295,"line_end":295,"column_start":12,"column_end":23},"name":"get_version","qualname":"<Uuid>::get_version","value":"fn (&self) -> Option<Version>","parent":null,"children":[],"decl_id":null,"docs":" Returns the version of the UUID.\n\n This represents the algorithm used to generate the contents\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":181},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":11264,"byte_end":11273,"line_start":347,"line_end":347,"column_start":12,"column_end":21},"name":"as_fields","qualname":"<Uuid>::as_fields","value":"fn (&self) -> (u32, u16, u16, &[u8; 8])","parent":null,"children":[],"decl_id":null,"docs":" Returns the four field values of the UUID in big-endian order.\n\n These values can be passed to the `from_fields()` method to get the\n original `Uuid` back.\n\n * The first field value represents the first group of (eight) hex\n   digits, taken as a big-endian `u32` value.  For V1 UUIDs, this field\n   represents the low 32 bits of the timestamp.\n * The second field value represents the second group of (four) hex\n   digits, taken as a big-endian `u16` value.  For V1 UUIDs, this field\n   represents the middle 16 bits of the timestamp.\n * The third field value represents the third group of (four) hex digits,\n   taken as a big-endian `u16` value.  The 4 most significant bits give\n   the UUID version, and for V1 UUIDs, the last 12 bits represent the\n   high 12 bits of the timestamp.\n * The last field value represents the last two groups of four and twelve\n   hex digits, taken in order.  The first 1-3 bits of this indicate the\n   UUID variant, and for V1 UUIDs, the next 13-15 bits indicate the clock\n   sequence and the last 48 bits indicate the node ID.\n\n # Examples\n\n ```\n use uuid::Uuid;\n\n let uuid = Uuid::nil();\n assert_eq!(uuid.as_fields(), (0, 0, 0, &[0u8; 8]));\n\n let uuid = Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap();\n assert_eq!(\n     uuid.as_fields(),\n     (\n         0x936DA01F,\n         0x9ABD,\n         0x4D9D,\n         b\"\\x80\\xC7\\x02\\xAF\\x85\\xC8\\x22\\xA8\"\n     )\n );\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":185},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":12430,"byte_end":12442,"line_start":385,"line_end":385,"column_start":12,"column_end":24},"name":"to_fields_le","qualname":"<Uuid>::to_fields_le","value":"fn (&self) -> (u32, u16, u16, &[u8; 8])","parent":null,"children":[],"decl_id":null,"docs":" Returns the four field values of the UUID in little-endian order.\n\n The bytes in the returned integer fields will\n be converted from big-endian order.\n\n # Examples\n\n ```\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap();\n assert_eq!(\n     uuid.to_fields_le(),\n     (\n         0x1FA06D93,\n         0xBD9A,\n         0x9D4D,\n         b\"\\x80\\xC7\\x02\\xAF\\x85\\xC8\\x22\\xA8\"\n     )\n );\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":189},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":13474,"byte_end":13481,"line_start":418,"line_end":418,"column_start":12,"column_end":19},"name":"as_u128","qualname":"<Uuid>::as_u128","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns a 128bit value containing the UUID data.\n\n The bytes in the UUID will be packed into a `u128`, like the\n [`Uuid::as_bytes`] method.\n\n # Examples\n\n ```\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap();\n assert_eq!(\n     uuid.as_u128(),\n     0x936DA01F9ABD4D9D80C702AF85C822A8,\n )\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":190},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":14965,"byte_end":14975,"line_start":456,"line_end":456,"column_start":12,"column_end":22},"name":"to_u128_le","qualname":"<Uuid>::to_u128_le","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns a 128bit little-endian value containing the UUID data.\n\n The bytes in the UUID will be reversed and packed into a `u128`.\n Note that this will produce a different result than\n [`Uuid::to_fields_le`], because the entire UUID is reversed, rather\n than reversing the individual fields in-place.\n\n # Examples\n\n ```\n use uuid::Uuid;\n\n let uuid = Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap();\n\n assert_eq!(\n     uuid.to_u128_le(),\n     0xA822C885AF02C7809D4DBD9A1FA06D93,\n )\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":191},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":15893,"byte_end":15901,"line_start":476,"line_end":476,"column_start":18,"column_end":26},"name":"as_bytes","qualname":"<Uuid>::as_bytes","value":"fn (&self) -> &Bytes","parent":null,"children":[],"decl_id":null,"docs":" Returns an array of 16 octets containing the UUID data.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":192},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":15989,"byte_end":15995,"line_start":481,"line_end":481,"column_start":12,"column_end":18},"name":"is_nil","qualname":"<Uuid>::is_nil","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Tests if the UUID is nil.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":194},"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":16846,"byte_end":16859,"line_start":511,"line_end":511,"column_start":18,"column_end":31},"name":"encode_buffer","qualname":"<Uuid>::encode_buffer","value":"fn () -> [u8; adapter::Urn::LENGTH]","parent":null,"children":[],"decl_id":null,"docs":" A buffer that can be used for `encode_...` calls, that is\n guaranteed to be long enough for any of the adapters.\n\n # Examples\n\n ```rust\n use uuid::Uuid;\n\n let uuid = Uuid::nil();\n\n assert_eq!(\n     uuid.to_simple().encode_lower(&mut Uuid::encode_buffer()),\n     \"00000000000000000000000000000000\"\n );\n\n assert_eq!(\n     uuid.to_hyphenated()\n         .encode_lower(&mut Uuid::encode_buffer()),\n     \"00000000-0000-0000-0000-000000000000\"\n );\n\n assert_eq!(\n     uuid.to_urn().encode_lower(&mut Uuid::encode_buffer()),\n     \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n );\n ```\n","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":43477,"byte_end":43482,"line_start":12,"line_end":12,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":9},{"krate":0,"index":10},{"krate":0,"index":11}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":43955,"byte_end":43960,"line_start":34,"line_end":34,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":13}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":44304,"byte_end":44309,"line_start":51,"line_end":51,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":31711,"byte_end":31715,"line_start":21,"line_end":21,"column_start":6,"column_end":10},"value":"","parent":null,"children":[{"krate":0,"index":21},{"krate":0,"index":23},{"krate":0,"index":25},{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":32}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":38248,"byte_end":38255,"line_start":283,"line_end":283,"column_start":6,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":34},{"krate":0,"index":35},{"krate":0,"index":38},{"krate":0,"index":40},{"krate":0,"index":41},{"krate":0,"index":43},{"krate":0,"index":44},{"krate":0,"index":45}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45207,"byte_end":45212,"line_start":31,"line_end":31,"column_start":31,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":52}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45329,"byte_end":45334,"line_start":37,"line_end":37,"column_start":30,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":54}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45444,"byte_end":45449,"line_start":43,"line_end":43,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":56}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45802,"byte_end":45807,"line_start":57,"line_end":57,"column_start":27,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":61}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64125,"byte_end":64130,"line_start":78,"line_end":78,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":66}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64508,"byte_end":64522,"line_start":89,"line_end":89,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":68}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64792,"byte_end":64797,"line_start":98,"line_end":98,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":70}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":66192,"byte_end":66197,"line_start":147,"line_end":147,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\mod.rs","byte_start":47736,"byte_end":47740,"line_start":51,"line_end":51,"column_start":6,"column_end":10},"value":"","parent":null,"children":[{"krate":0,"index":86}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69902,"byte_end":69906,"line_start":68,"line_end":68,"column_start":6,"column_end":10},"value":"","parent":null,"children":[{"krate":0,"index":102},{"krate":0,"index":103},{"krate":0,"index":104},{"krate":0,"index":105},{"krate":0,"index":106},{"krate":0,"index":107}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":73326,"byte_end":73336,"line_start":180,"line_end":180,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":119},{"krate":0,"index":120},{"krate":0,"index":121},{"krate":0,"index":123}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":76827,"byte_end":76840,"line_start":287,"line_end":287,"column_start":10,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":127},{"krate":0,"index":128},{"krate":0,"index":129},{"krate":0,"index":131}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":80584,"byte_end":80590,"line_start":401,"line_end":401,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":134},{"krate":0,"index":135},{"krate":0,"index":136},{"krate":0,"index":138}],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":83972,"byte_end":83981,"line_start":506,"line_end":506,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":142},{"krate":0,"index":143},{"krate":0,"index":144},{"krate":0,"index":146}],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":87391,"byte_end":87394,"line_start":611,"line_end":611,"column_start":6,"column_end":9},"value":"","parent":null,"children":[{"krate":0,"index":149},{"krate":0,"index":150},{"krate":0,"index":151},{"krate":0,"index":153}],"docs":"","sig":null,"attributes":[]},{"id":20,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":91148,"byte_end":91154,"line_start":725,"line_end":725,"column_start":10,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":157},{"krate":0,"index":158},{"krate":0,"index":159},{"krate":0,"index":161}],"docs":"","sig":null,"attributes":[]},{"id":21,"kind":"Inherent","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6876,"byte_end":6880,"line_start":236,"line_end":236,"column_start":6,"column_end":10},"value":"","parent":null,"children":[{"krate":0,"index":174},{"krate":0,"index":175},{"krate":0,"index":176},{"krate":0,"index":177},{"krate":0,"index":178},{"krate":0,"index":179},{"krate":0,"index":180},{"krate":0,"index":181},{"krate":0,"index":185},{"krate":0,"index":189},{"krate":0,"index":190},{"krate":0,"index":191},{"krate":0,"index":192},{"krate":0,"index":194}],"docs":"","sig":null,"attributes":[]},{"id":22,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":16957,"byte_end":16961,"line_start":516,"line_end":516,"column_start":21,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":198}],"docs":"","sig":null,"attributes":[]},{"id":23,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17108,"byte_end":17112,"line_start":523,"line_end":523,"column_start":23,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":200}],"docs":"","sig":null,"attributes":[]},{"id":24,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17245,"byte_end":17252,"line_start":529,"line_end":529,"column_start":23,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":202}],"docs":"","sig":null,"attributes":[]},{"id":25,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17592,"byte_end":17596,"line_start":540,"line_end":540,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":204}],"docs":"","sig":null,"attributes":[]},{"id":26,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17751,"byte_end":17755,"line_start":546,"line_end":546,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":206}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17923,"byte_end":17927,"line_start":553,"line_end":553,"column_start":23,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":208},{"krate":0,"index":209}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":18074,"byte_end":18078,"line_start":561,"line_end":561,"column_start":18,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":211}],"docs":"","sig":null,"attributes":[]}],"refs":[{"kind":"Mod","span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":4969,"byte_end":4976,"line_start":149,"line_end":149,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":96}}],"macro_refs":[],"relations":[{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":43477,"byte_end":43482,"line_start":12,"line_end":12,"column_start":6,"column_end":11},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":212},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":43955,"byte_end":43960,"line_start":34,"line_end":34,"column_start":23,"column_end":28},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":212},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\error.rs","byte_start":44304,"byte_end":44309,"line_start":51,"line_end":51,"column_start":27,"column_end":32},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":212},"to":{"krate":4,"index":1616}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":31711,"byte_end":31715,"line_start":21,"line_end":21,"column_start":6,"column_end":10},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":661},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\builder\\mod.rs","byte_start":38248,"byte_end":38255,"line_start":283,"line_end":283,"column_start":6,"column_end":13},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":229},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45207,"byte_end":45212,"line_start":31,"line_end":31,"column_start":31,"column_end":36},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":234},"to":{"krate":1,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45329,"byte_end":45334,"line_start":37,"line_end":37,"column_start":30,"column_end":35},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":234},"to":{"krate":1,"index":2258}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45444,"byte_end":45449,"line_start":43,"line_end":43,"column_start":23,"column_end":28},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":234},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\error.rs","byte_start":45802,"byte_end":45807,"line_start":57,"line_end":57,"column_start":27,"column_end":32},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":234},"to":{"krate":4,"index":1616}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64125,"byte_end":64130,"line_start":78,"line_end":78,"column_start":6,"column_end":11},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":272},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64508,"byte_end":64522,"line_start":89,"line_end":89,"column_start":23,"column_end":37},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":303},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":64792,"byte_end":64797,"line_start":98,"line_end":98,"column_start":23,"column_end":28},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":272},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\error.rs","byte_start":66192,"byte_end":66197,"line_start":147,"line_end":147,"column_start":27,"column_end":32},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":272},"to":{"krate":4,"index":1616}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\parser\\mod.rs","byte_start":47736,"byte_end":47740,"line_start":51,"line_end":51,"column_start":6,"column_end":10},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":661},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":69902,"byte_end":69906,"line_start":68,"line_end":68,"column_start":6,"column_end":10},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":661},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":73326,"byte_end":73336,"line_start":180,"line_end":180,"column_start":6,"column_end":16},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":354},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":76827,"byte_end":76840,"line_start":287,"line_end":287,"column_start":10,"column_end":23},"kind":{"Impl":{"id":16}},"from":{"krate":0,"index":382},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":80584,"byte_end":80590,"line_start":401,"line_end":401,"column_start":6,"column_end":12},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":419},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":83972,"byte_end":83981,"line_start":506,"line_end":506,"column_start":10,"column_end":19},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":447},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":87391,"byte_end":87394,"line_start":611,"line_end":611,"column_start":6,"column_end":9},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":484},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\adapter\\mod.rs","byte_start":91148,"byte_end":91154,"line_start":725,"line_end":725,"column_start":10,"column_end":16},"kind":{"Impl":{"id":20}},"from":{"krate":0,"index":512},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":6876,"byte_end":6880,"line_start":236,"line_end":236,"column_start":6,"column_end":10},"kind":{"Impl":{"id":21}},"from":{"krate":0,"index":661},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":16957,"byte_end":16961,"line_start":516,"line_end":516,"column_start":21,"column_end":25},"kind":{"Impl":{"id":22}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":7643}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17108,"byte_end":17112,"line_start":523,"line_end":523,"column_start":23,"column_end":27},"kind":{"Impl":{"id":23}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17245,"byte_end":17252,"line_start":529,"line_end":529,"column_start":23,"column_end":30},"kind":{"Impl":{"id":24}},"from":{"krate":0,"index":643},"to":{"krate":1,"index":7648}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17592,"byte_end":17596,"line_start":540,"line_end":540,"column_start":24,"column_end":28},"kind":{"Impl":{"id":25}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":7654}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17751,"byte_end":17755,"line_start":546,"line_end":546,"column_start":24,"column_end":28},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":7656}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":17923,"byte_end":17927,"line_start":553,"line_end":553,"column_start":23,"column_end":27},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":6815}},{"span":{"file_name":"C:\\Users\\chapm\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\uuid-0.8.1\\src\\lib.rs","byte_start":18074,"byte_end":18078,"line_start":561,"line_end":561,"column_start":18,"column_end":22},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":661},"to":{"krate":1,"index":2206}}]}